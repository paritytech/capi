// import { runCmd } from "/util/runCmd.ts";
// import * as path from "std/path/mod.ts";

// // const OutDir = (feature: string) => {
// //   return path.join("target", "wasm", feature);
// // };

// // const buildWasm = async (feature: string): Promise<void> => {
// //   await runCmd([
// //     "cargo",
// //     "build",
// //     "--features",
// //     feature,
// //     "--release",
// //     "--target",
// //     "wasm32-unknown-unknown",
// //   ]);
// //   await runCmd([
// //     "wasm-bindgen",
// //     path.join("target", "wasm32-unknown-unknown", "release", "mod.wasm"),
// //     "--target",
// //     "web",
// //     "--weak-refs",
// //     "--out-dir",
// //     OutDir(feature),
// //   ]);
// // };

// // // TODO: zip & inline! Perform gzip(base64(gzip(wasm))) like @tomaka does in Smoldot.
// // await buildWasm("crypto");
// // const outWasmPath = path.join(OutDir("crypto"), "mod_bg.wasm");
// // await runCmd(["wasm-opt", "-g", "-Oz", outWasmPath, "-o", outWasmPath]);

// import * as base64 from "std/encoding/base64.ts";

// await runCmd([
//   "cargo",
//   "build",
//   "--release",
//   "--target",
//   "wasm32-unknown-unknown",
// ]);

// await runCmd([
//   "wasm-bindgen",
//   "target/wasm32-unknown-unknown/release/mod.wasm",
//   "--target",
//   "web",
//   "--weak-refs",
//   "--out-dir",
//   "target/wasm",
// ]);

// const generatedWasm = await Deno.readFile("./target/wasm/mod_bg.wasm");

// const formattedWasmSize = generatedWasm.length.toString().padStart(
//   Math.ceil(generatedWasm.length.toString().length / 3) * 3,
// ).replace(/...\B/g, "$&_").trim();

// const wasmIntegrity = `sha256-${base64.encode(await crypto.subtle!.digest("SHA-256", generatedWasm))}`;

// const wasmJs = `// This file was generated
// // It is not intended for manual editing.
// import * as base64 from "../encoding/base64.ts";
// export const size = ${formattedWasmSize};
// export const name = "bindings.wasm";
// export const type = "application/wasm";
// export const hash = ${JSON.stringify(wasmIntegrity)};
// export const data = base64.decode("\\\n${base64.encode(generatedWasm).replace(/.{78}/g, "$&\\\n")}\\\n");
// export default data;
// `;

// const generatedScript = await Deno.readTextFile("./target/wasm/mod_bg.wasm");
// const bindingsJs = `// This file is generated
// // It is not intended for manual editing.
// // deno-lint-ignore-file
// import wasmBytes from "./wasm/mod.wasm.mjs";
// ${
//   generatedScript.replace(
//     /^const wasm_url =.*?;\nlet wasmCode =.*?;\n.*?const wasmInstance =.*?;\n/sm,
//     `const wasmModule = new WebAssembly.Module(wasmBytes);\n`
//       + `const wasmInstance = new WebAssembly.Instance(wasmModule, imports);`,
//   )
// }
// // for testing/debugging
// export const _wasm = wasm;
// export const _wasmModule = wasmModule;
// export const _wasmInstance = wasmInstance;
// export const _wasmBytes = wasmBytes;
// `;

// await Deno.writeTextFile("./target/wasm/mod.wasm.mjs", wasmJs);
// await Deno.writeTextFile("./target/wasm/mod.mjs", bindingsJs);

//
//
//

import { runCmd } from "/util/mod.ts";
import * as base64 from "std/encoding/base64.ts";

const home = Deno.env.get("HOME");
const root = new URL(".", import.meta.url).pathname;

// Run in the same directory as this script is located.
if (new URL(import.meta.url).protocol === "file:") {
  Deno.chdir(root);
} else {
  console.error("build.ts can only be run locally (from a file: URL).");
  Deno.exit(1);
}

// Compile the Rust code to WASM.
await runCmd([
  "cargo",
  "build",
  "--release",
  "--target",
  "wasm32-unknown-unknown",
]);

await runCmd([
  "wasm-bindgen",
  "../target/wasm32-unknown-unknown/release/mod.wasm",
  "--target",
  "deno",
  "--weak-refs",
  "--out-dir",
  "../target/wasm32-bindgen-deno-js",
]);

const generatedWasm = await Deno.readFile("../target/wasm32-bindgen-deno-js/mod_bg.wasm");

// Format WASM binary size with _ thousands separators for human readability,
// so that any changes in size will be clear in diffs.
const formattedWasmSize = generatedWasm.length.toString().padStart(
  Math.ceil(generatedWasm.length.toString().length / 3) * 3,
).replace(/...\B/g, "$&_").trim();

// Generate a hash of the WASM in the format required by subresource integrity.
const wasmIntegrity = `sha256-${base64.encode(await crypto.subtle!.digest("SHA-256", generatedWasm))}`;

const wasmJs = `// This file is automatically @generated by _build.ts
// It is not intended for manual editing.
import * as base64 from "std/encoding/base64.ts";
export const size = ${formattedWasmSize};
export const name = "bindings.wasm";
export const type = "application/wasm";
export const hash = ${JSON.stringify(wasmIntegrity)};
export const data = base64.decode("\\\n${base64.encode(generatedWasm).replace(/.{78}/g, "$&\\\n")}\\\n");
export default data;
`;

// Modify the generated WASM bindings, replacing the runtime fetching of the
// WASM binary file with a static TypeScript import of the copy we encoded
// above. This eliminates the need for net or read permissions.
const generatedScript = await Deno.readTextFile("../target/wasm32-bindgen-deno-js/mod.js");
const bindingsJs = `// This file is automatically @generated by _build.ts
// It is not intended for manual editing.
// deno-lint-ignore-file
import wasmBytes from "./bindings.wasm.js";
${
  generatedScript.replace(
    /^const wasm_url =.*?;\nlet wasmCode =.*?;\n.*?const wasmInstance =.*?;\n/sm,
    `const wasmModule = new WebAssembly.Module(wasmBytes);\n`
      + `const wasmInstance = new WebAssembly.Instance(wasmModule, imports);`,
  )
}
// for testing/debugging
export const _wasm = wasm;
export const _wasmModule = wasmModule;
export const _wasmInstance = wasmInstance;
export const _wasmBytes = wasmBytes;
`;

await Promise.all([
  Deno.writeTextFile("../crypto/bindings.wasm.js", wasmJs),
  Deno.writeTextFile("../crypto/bindings.js", bindingsJs),
  Deno.copyFile("../target/wasm32-bindgen-deno-js/mod.d.ts", "../crypto/bindings.d.ts"),
]);
