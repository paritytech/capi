import { chain as kusama } from "kusama/mod.ts"
import { chain as polkadot } from "polkadot/mod.ts"
import { chain as rococo } from "rococo/mod.ts"
import { chain as westend } from "westend/mod.ts"
import { parse } from "../deps/std/flags.ts"
import dprintConfig from "../dprint.json" assert { type: "json" }

const { dprint, metadata } = parse(Deno.args, { boolean: ["dprint", "metadata"] })

if (dprint) {
  const response = await fetch(
    dprintConfig.plugins.find((v) => v.startsWith("https://plugins.dprint.dev/typescript-"))!,
  )
  const file = await Deno.open("deps/dprint_plugin_ts.wasm", {
    create: true,
    write: true,
  })
  await response.body?.pipeTo(file.writable)
}

if (metadata) {
  const knownChains = { kusama, polkadot, westend, rococo }
  const names = Object.keys(knownChains)
  const outDir = new URL("../frame_metadata/_downloaded", import.meta.url)
  try {
    Deno.removeSync(outDir, { recursive: true })
  } catch (_e) {}
  Deno.mkdirSync(outDir)

  const modFilePath = new URL("_downloaded/mod.ts", outDir)
  const modFileContents = `// This file was generated by \`_tasks/download_frame_metadata.ts\`
  import { hex } from "../../util/mod.ts"
  import { $metadata } from "../mod.ts"

  export const [
    ${names.join(",\n  ")},
  ] = await Promise.all([
    ${names.map((name) => `download("${name}")`).join(",\n  ")},
  ])

  async function download(name: string) {
    return $metadata.decode(
      hex.decodeBuf((await Deno.readFile(new URL(\`./$\{name}.scale\`, import.meta.url))).slice(2)),
    )
  }
  `

  Deno.writeTextFileSync(modFilePath, modFileContents, { create: true })

  await Promise.all(
    Object.entries(knownChains).map(async ([name, chain]) => {
      const result = await chain.connection.call("state_getMetadata").run()
      const outPath = new URL(`_downloaded/${name}.scale`, outDir)
      console.log(`Downloading ${name} metadata to "${outPath}".`)
      await Deno.writeTextFile(outPath, result)
    }),
  )
}
