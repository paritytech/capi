import { chain as kusama } from "kusama/mod.ts"
import { chain as polkadot } from "polkadot/mod.ts"
import { chain as rococo } from "rococo/mod.ts"
import { chain as westend } from "westend/mod.ts"
import { emptyDir } from "../deps/std/fs.ts"
import dprintConfig from "../dprint.json" assert { type: "json" }

const response = await fetch(
  dprintConfig.plugins.find((v) => v.startsWith("https://plugins.dprint.dev/typescript-"))!,
)
Deno.writeFile("deps/dprint_ts.wasm", response.body!)

const knownChains = { kusama, polkadot, westend, rococo }
const names = Object.keys(knownChains)
const outDir = new URL("../frame_metadata/_downloaded", import.meta.url)
await emptyDir(outDir)

const modFilePath = new URL("_downloaded/mod.ts", outDir)
const modFileContents = `// This file was generated by \`_tasks/download_frame_metadata.ts\`
import { hex } from "../../util/mod.ts"
import { $metadata } from "../mod.ts"

export const [
  ${names.join(",\n  ")},
] = await Promise.all([
  ${names.map((name) => `download("${name}")`).join(",\n  ")},
])

async function download(name: string) {
  return $metadata.decode(
    hex.decodeBuf((await Deno.readFile(new URL(\`./$\{name}.scale\`, import.meta.url))).slice(2)),
  )
}
`
Deno.writeTextFileSync(modFilePath, modFileContents, { create: true })

await Promise.all(
  Object.entries(knownChains).map(async ([name, chain]) => {
    const result = await chain.connection.call("state_getMetadata").run()
    const outPath = new URL(`_downloaded/${name}.scale`, outDir)
    console.log(`Downloading ${name} metadata to "${outPath}".`)
    await Deno.writeTextFile(outPath, result)
  }),
)
