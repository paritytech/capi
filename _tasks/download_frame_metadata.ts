import { chain as kusama } from "kusama/mod.ts"
import { chain as polkadot } from "polkadot/mod.ts"
import { chain as rococo } from "rococo/mod.ts"
import { chain as westend } from "westend/mod.ts"

const knownChains = { kusama, polkadot, westend, rococo }

const names = Object.keys(knownChains)
const outDir = new URL("../frame_metadata/_downloaded", import.meta.url)
try {
  Deno.removeSync(outDir, { recursive: true })
} catch (_e) {}
Deno.mkdirSync(outDir)

const modFilePath = new URL("_downloaded/mod.ts", outDir)
const modFileContents = `// This file was generated by \`_tasks/download_frame_metadata.ts\`
import * as U from "../../util/mod.ts"
import { $metadata } from "../mod.ts"

export const [
  ${names.join(",\n  ")},
] = await Promise.all([
  ${names.map((name) => `download("${name}")`).join(",\n  ")},
])

async function download(name: string) {
  return $metadata.decode(
    U.hex.decodeBuf((await Deno.readFile(new URL(\`./$\{name}.scale\`, import.meta.url))).slice(2)),
  )
}
`

Deno.writeTextFileSync(modFilePath, modFileContents, { create: true })

await Promise.all(
  Object.entries(knownChains).map(async ([name, chain]) => {
    const result = await chain.connection.call("state_getMetadata").run()
    const outPath = new URL(`_downloaded/${name}.scale`, outDir)
    console.log(`Downloading ${name} metadata to "${outPath}".`)
    await Deno.writeTextFile(outPath, result)
  }),
)
