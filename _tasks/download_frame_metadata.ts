import * as Z from "../deps/zones.ts"
import * as C from "../mod.ts"
import * as U from "../util/mod.ts"

const names = Object.keys(C.knownClients)
const outDir = new URL("../frame_metadata/_downloaded", import.meta.url)
try {
  Deno.removeSync(outDir, { recursive: true })
} catch (_e) {}
Deno.mkdirSync(outDir)

const modFilePath = new URL("_downloaded/mod.ts", outDir)
const modFileContents = `// This file was generated by \`_tasks/download_frame_metadata.ts\`
import * as U from "../../util/mod.ts"
import { $metadata } from "../mod.ts"

export const [
  ${names.join(",\n  ")},
] = await Promise.all([
  ${names.map((name) => `download("${name}")`).join(",\n  ")},
])

async function download(name: string) {
  return $metadata.decode(
    U.hex.decodeBuf((await Deno.readFile(new URL(\`./$\{name}.scale\`, import.meta.url))).slice(2)),
  )
}
`
Deno.writeTextFileSync(modFilePath, modFileContents, { create: true })

U.throwIfError(await Z.ls(...Object.entries(C.knownClients).map(download)).run())

function download<Name extends Z.$<string>, Client extends Z.$<C.rpc.Client>>(
  entry: [name: Name, client: Client],
) {
  return Z.ls(...entry).next(async ([name, client]) => {
    try {
      const metadataHex = U.throwIfError(await C.state.getMetadata(client)().run())
      const outPath = new URL(`_downloaded/${name}.scale`, outDir)
      console.log(`Downloading ${name} metadata to "${outPath}".`)
      await Deno.writeTextFile(outPath, metadataHex)
      return
    } catch (cause) {
      return new MetadataDownloadError(name, { cause })
    }
  })
}

class MetadataDownloadError extends Error {
  override readonly name = "MetadataDownloadError"

  constructor(readonly chainName: string, options: ErrorOptions) {
    super(undefined, options)
  }
}
