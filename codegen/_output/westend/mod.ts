import { $, BitSequence, ChainError, Era } from "../../../mod.ts"
import * as _codec from "./codecs.ts"
export { _metadata }
namespace _metadata {
  export const extrinsic = {
    version: 4,
    extras: [_codec.$731, _codec.$733, _codec.$735],
    additional: [_codec.$4, _codec.$4, _codec.$11, _codec.$11],
    call: _codec.$181,
    address: _codec.$197,
    signature: _codec.$421,
  }
  export const types = _codec._all
}
export namespace Auctions {
  /** Number of auctions started so far. */
  export const AuctionCounter = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Information relating to the current auction, if there is one.
   *
   *  The first item in the tuple is the lease period index that the first of the four
   *  contiguous lease periods on auction is for. The second is the block number when the
   *  auction will "begin to end", i.e. the first block of the Ending Period of the auction.
   */
  export const AuctionInfo = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$30,
  }
  /**
   *  Amounts currently reserved in the accounts of the bidders currently winning
   *  (sub-)ranges.
   */
  export const ReservedAmounts = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$705),
    value: _codec.$6,
  }
  /**
   *  The winning bids for each of the 10 ranges at each sample in the final Ending Period of
   *  the current auction. The map's key is the 0-based index into the Sample Size. The
   *  first sample of the ending period is 0; the last is `Sample Size - 1`.
   */
  export const Winning = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$706,
  }
  /**
   * Make a new bid from an account (including a parachain account) for deploying a new
   * parachain.
   *
   * Multiple simultaneous bids from the same bidder are allowed only as long as all active
   * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
   *
   * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
   * funded by) the same account.
   * - `auction_index` is the index of the auction to bid on. Should just be the present
   * value of `AuctionCounter`.
   * - `first_slot` is the first lease period index of the range to bid on. This is the
   * absolute lease period index value, not an auction-specific offset.
   * - `last_slot` is the last lease period index of the range to bid on. This is the
   * absolute lease period index value, not an auction-specific offset.
   * - `amount` is the amount to bid to be held as deposit for the parachain should the
   * bid win. This amount is held throughout the range.
   */
  export function bid(
    value: Omit<polkadot_runtime_common.auctions.pallet.Call.bid, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Auctions", value: { ...value, type: "bid" } }
  }
  /**
   * Cancel an in-progress auction.
   *
   * Can only be called by Root origin.
   */
  export function cancel_auction(): polkadot_runtime.RuntimeCall {
    return { type: "Auctions", value: { type: "cancel_auction" } }
  }
  /**
   * Create a new auction.
   *
   * This can only happen when there isn't already an auction in progress and may only be
   * called by the root origin. Accepts the `duration` of this auction and the
   * `lease_period_index` of the initial lease period of the four that are to be auctioned.
   */
  export function new_auction(
    value: Omit<polkadot_runtime_common.auctions.pallet.Call.new_auction, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Auctions", value: { ...value, type: "new_auction" } }
  }
}
export namespace Authorship {
  /** Author of current block. */
  export const Author = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$0,
  }
  /** Whether uncles were already set in this block. */
  export const DidSetUncles = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$43,
  }
  /** Uncles */
  export const Uncles = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$481,
  }
  /** Provide a set of uncles. */
  export function set_uncles(
    value: Omit<pallet_authorship.pallet.Call.set_uncles, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Authorship", value: { ...value, type: "set_uncles" } }
  }
}
export namespace Babe {
  /**
   *  This field should always be populated during block processing unless
   *  secondary plain slots are enabled (which don't contain a VRF output).
   *
   *  It is set in `on_finalize`, before it will contain the value from the last block.
   */
  export const AuthorVrfRandomness = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$31,
  }
  /** Current epoch authorities. */
  export const Authorities = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$456,
  }
  /** Current slot number. */
  export const CurrentSlot = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$190,
  }
  /**
   *  The configuration for the current epoch. Should never be `None` as it is initialized in
   *  genesis.
   */
  export const EpochConfig = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$466,
  }
  /** Current epoch index. */
  export const EpochIndex = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$10,
  }
  /**
   *  The block numbers when the last and current epoch have started, respectively `N-1` and
   *  `N`.
   *  NOTE: We track this is in order to annotate the block number when a given pool of
   *  entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
   *  slots, which may be skipped, the block numbers may not line up with the slot numbers.
   */
  export const EpochStart = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$30,
  }
  /**
   *  The slot at which the first epoch actually started. This is 0
   *  until the first block of the chain.
   */
  export const GenesisSlot = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$190,
  }
  /**
   *  Temporary value (cleared at block finalization) which is `Some`
   *  if per-block initialization has already been called for current block.
   */
  export const Initialized = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$461,
  }
  /**
   *  How late the current block is compared to its parent.
   *
   *  This entry is populated as part of block execution and is cleaned up
   *  on block finalization. Querying this storage entry outside of block
   *  execution context should always yield zero.
   */
  export const Lateness = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Next epoch authorities. */
  export const NextAuthorities = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$456,
  }
  /**
   *  The configuration for the next epoch, `None` if the config will not change
   *  (you can fallback to `EpochConfig` instead in that case).
   */
  export const NextEpochConfig = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$466,
  }
  /** Next epoch randomness. */
  export const NextRandomness = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$1,
  }
  /** Pending epoch configuration change that will be applied when the next epoch is enacted. */
  export const PendingEpochConfigChange = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$192,
  }
  /**
   *  The epoch randomness for the *current* epoch.
   *
   *  # Security
   *
   *  This MUST NOT be used for gambling, as it can be influenced by a
   *  malicious validator in the short term. It MAY be used in many
   *  cryptographic protocols, however, so long as one remembers that this
   *  (like everything else on-chain) it is public. For example, it can be
   *  used where a number is needed that cannot have been chosen by an
   *  adversary, for purposes such as public-coin zero-knowledge proofs.
   */
  export const Randomness = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$1,
  }
  /**
   *  Randomness under construction.
   *
   *  We make a trade-off between storage accesses and list length.
   *  We store the under-construction randomness in segments of up to
   *  `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
   *
   *  Once a segment reaches this length, we begin the next one.
   *  We reset all segments and return to `0` at the beginning of every
   *  epoch.
   */
  export const SegmentIndex = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay. */
  export const UnderConstruction = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$459,
  }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   */
  export function plan_config_change(
    value: Omit<pallet_babe.pallet.Call.plan_config_change, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Babe", value: { ...value, type: "plan_config_change" } }
  }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   */
  export function report_equivocation(
    value: Omit<pallet_babe.pallet.Call.report_equivocation, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Babe", value: { ...value, type: "report_equivocation" } }
  }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   */
  export function report_equivocation_unsigned(
    value: Omit<pallet_babe.pallet.Call.report_equivocation_unsigned, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Babe", value: { ...value, type: "report_equivocation_unsigned" } }
  }
}
export namespace Balances {
  /**
   *  The Balances pallet example of storing the balance of an account.
   *
   *  # Example
   *
   *  ```nocompile
   *   impl pallet_balances::Config for Runtime {
   *     type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
   *   }
   *  ```
   *
   *  You can also store the balance of an account in the `System` pallet.
   *
   *  # Example
   *
   *  ```nocompile
   *   impl pallet_balances::Config for Runtime {
   *    type AccountStore = System
   *   }
   *  ```
   *
   *  But this comes with tradeoffs, storing account balances in the system pallet stores
   *  `frame_system` data alongside the account data contrary to storing account balances in the
   *  `Balances` pallet, which uses a `StorageMap` to store balances data only.
   *  NOTE: This is only used in the case that this pallet is used to store balances.
   */
  export const Account = {
    type: "Map",
    modifier: "Default",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$5,
  }
  /**
   *  Any liquidity locks on some account balances.
   *  NOTE: Should only be accessed when setting, changing and freeing a lock.
   */
  export const Locks = {
    type: "Map",
    modifier: "Default",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$470,
  }
  /** Named reserves on some account balances. */
  export const Reserves = {
    type: "Map",
    modifier: "Default",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$474,
  }
  /**
   *  Storage version of the pallet.
   *
   *  This is set to v2.0.0 for new networks.
   */
  export const StorageVersion = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$477,
  }
  /** The total units issued in the system. */
  export const TotalIssuance = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$6,
  }
  /**
   * Exactly as `transfer`, except the origin must be root and the source account may be
   * specified.
   * # <weight>
   * - Same as transfer, but additional read and write because the source account is not
   *   assumed to be in the overlay.
   * # </weight>
   */
  export function force_transfer(
    value: Omit<pallet_balances.pallet.Call.force_transfer, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Balances", value: { ...value, type: "force_transfer" } }
  }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   */
  export function force_unreserve(
    value: Omit<pallet_balances.pallet.Call.force_unreserve, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Balances", value: { ...value, type: "force_unreserve" } }
  }
  /**
   * Set the balances of a given account.
   *
   * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
   * also alter the total issuance of the system (`TotalIssuance`) appropriately.
   * If the new free or reserved balance is below the existential deposit,
   * it will reset the account nonce (`frame_system::AccountNonce`).
   *
   * The dispatch origin for this call is `root`.
   */
  export function set_balance(
    value: Omit<pallet_balances.pallet.Call.set_balance, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Balances", value: { ...value, type: "set_balance" } }
  }
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   *
   * # <weight>
   * - Dependent on arguments but not critical, given proper implementations for input config
   *   types. See related functions below.
   * - It contains a limited number of reads and writes internally and no complex
   *   computation.
   *
   * Related functions:
   *
   *   - `ensure_can_withdraw` is always called internally but has a bounded complexity.
   *   - Transferring balances to accounts that did not exist before will cause
   *     `T::OnNewAccount::on_new_account` to be called.
   *   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
   *   - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
   *     that the transfer will not kill the origin account.
   * ---------------------------------
   * - Origin account is already in memory, so no DB operations for them.
   * # </weight>
   */
  export function transfer(
    value: Omit<pallet_balances.pallet.Call.transfer, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Balances", value: { ...value, type: "transfer" } }
  }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   *   of the funds the account has, causing the sender account to be killed (false), or
   *   transfer everything except at least the existential deposit, which will guarantee to
   *   keep the sender account alive (true). # <weight>
   * - O(1). Just like transfer, but reading the user's transferable balance first.
   *   #</weight>
   */
  export function transfer_all(
    value: Omit<pallet_balances.pallet.Call.transfer_all, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Balances", value: { ...value, type: "transfer_all" } }
  }
  /**
   * Same as the [`transfer`] call, but with a check that the transfer will not kill the
   * origin account.
   *
   * 99% of the time you want [`transfer`] instead.
   *
   * [`transfer`]: struct.Pallet.html#method.transfer
   */
  export function transfer_keep_alive(
    value: Omit<pallet_balances.pallet.Call.transfer_keep_alive, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Balances", value: { ...value, type: "transfer_keep_alive" } }
  }
}
export namespace Bounties {
  /** Bounties that have been made. */
  export const Bounties = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$591,
  }
  /** Bounty indices that have been approved but not yet funded. */
  export const BountyApprovals = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$557,
  }
  /** Number of bounty proposals that have been made. */
  export const BountyCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** The description of each bounty. */
  export const BountyDescriptions = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$593,
  }
  /**
   * Accept the curator role for a bounty.
   * A deposit will be reserved from curator and refund upon successful payout.
   *
   * May only be called from the curator.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function accept_curator(
    value: Omit<pallet_bounties.pallet.Call.accept_curator, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "accept_curator" } }
  }
  /**
   * Approve a bounty proposal. At a later time, the bounty will be funded and become active
   * and the original deposit will be returned.
   *
   * May only be called from `T::ApproveOrigin`.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function approve_bounty(
    value: Omit<pallet_bounties.pallet.Call.approve_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "approve_bounty" } }
  }
  /**
   * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
   * after a delay.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to award.
   * - `beneficiary`: The beneficiary account whom will receive the payout.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function award_bounty(
    value: Omit<pallet_bounties.pallet.Call.award_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "award_bounty" } }
  }
  /**
   * Claim the payout from an awarded bounty after payout delay.
   *
   * The dispatch origin for this call must be the beneficiary of this bounty.
   *
   * - `bounty_id`: Bounty ID to claim.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function claim_bounty(
    value: Omit<pallet_bounties.pallet.Call.claim_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "claim_bounty" } }
  }
  /**
   * Cancel a proposed or active bounty. All the funds will be sent to treasury and
   * the curator deposit will be unreserved if possible.
   *
   * Only `T::RejectOrigin` is able to cancel a bounty.
   *
   * - `bounty_id`: Bounty ID to cancel.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function close_bounty(
    value: Omit<pallet_bounties.pallet.Call.close_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "close_bounty" } }
  }
  /**
   * Extend the expiry time of an active bounty.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to extend.
   * - `remark`: additional information.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function extend_bounty_expiry(
    value: Omit<pallet_bounties.pallet.Call.extend_bounty_expiry, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "extend_bounty_expiry" } }
  }
  /**
   * Propose a new bounty.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
   * or slashed when rejected.
   *
   * - `curator`: The curator account whom will manage this bounty.
   * - `fee`: The curator fee.
   * - `value`: The total payment amount of this bounty, curator fee included.
   * - `description`: The description of this bounty.
   */
  export function propose_bounty(
    value: Omit<pallet_bounties.pallet.Call.propose_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "propose_bounty" } }
  }
  /**
   * Assign a curator to a funded bounty.
   *
   * May only be called from `T::ApproveOrigin`.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function propose_curator(
    value: Omit<pallet_bounties.pallet.Call.propose_curator, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "propose_curator" } }
  }
  /**
   * Unassign curator from a bounty.
   *
   * This function can only be called by the `RejectOrigin` a signed origin.
   *
   * If this function is called by the `RejectOrigin`, we assume that the curator is
   * malicious or inactive. As a result, we will slash the curator when possible.
   *
   * If the origin is the curator, we take this as a sign they are unable to do their job and
   * they willingly give up. We could slash them, but for now we allow them to recover their
   * deposit and exit without issue. (We may want to change this if it is abused.)
   *
   * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
   * anyone in the community to call out that a curator is not doing their due diligence, and
   * we should pick a new curator. In this case the curator should also be slashed.
   *
   * # <weight>
   * - O(1).
   * # </weight>
   */
  export function unassign_curator(
    value: Omit<pallet_bounties.pallet.Call.unassign_curator, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Bounties", value: { ...value, type: "unassign_curator" } }
  }
}
export namespace ChildBounties {
  /** Child bounties that have been added. */
  export const ChildBounties = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$30,
    value: _codec.$595,
  }
  /** Number of total child bounties. */
  export const ChildBountyCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** The description of each child-bounty. */
  export const ChildBountyDescriptions = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$593,
  }
  /** The cumulative child-bounty curator fee for each parent bounty. */
  export const ChildrenCuratorFees = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$6,
  }
  /**
   *  Number of child bounties per parent bounty.
   *  Map of parent bounty index to number of child bounties.
   */
  export const ParentChildBounties = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$4,
  }
  /**
   * Accept the curator role for the child-bounty.
   *
   * The dispatch origin for this call must be the curator of this
   * child-bounty.
   *
   * A deposit will be reserved from the curator and refund upon
   * successful payout or cancellation.
   *
   * Fee for curator is deducted from curator fee of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "CuratorProposed" state, for processing the
   * call. And state of child-bounty is moved to "Active" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   */
  export function accept_curator(
    value: Omit<pallet_child_bounties.pallet.Call.accept_curator, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ChildBounties", value: { ...value, type: "accept_curator" } }
  }
  /**
   * Add a new child-bounty.
   *
   * The dispatch origin for this call must be the curator of parent
   * bounty and the parent bounty must be in "active" state.
   *
   * Child-bounty gets added successfully & fund gets transferred from
   * parent bounty to child-bounty account, if parent bounty has enough
   * funds, else the call fails.
   *
   * Upper bound to maximum number of active  child bounties that can be
   * added are managed via runtime trait config
   * [`Config::MaxActiveChildBountyCount`].
   *
   * If the call is success, the status of child-bounty is updated to
   * "Added".
   *
   * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
   * - `value`: Value for executing the proposal.
   * - `description`: Text description for the child-bounty.
   */
  export function add_child_bounty(
    value: Omit<pallet_child_bounties.pallet.Call.add_child_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ChildBounties", value: { ...value, type: "add_child_bounty" } }
  }
  /**
   * Award child-bounty to a beneficiary.
   *
   * The beneficiary will be able to claim the funds after a delay.
   *
   * The dispatch origin for this call must be the parent curator or
   * curator of this child-bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in active state, for processing the call. And
   * state of child-bounty is moved to "PendingPayout" on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `beneficiary`: Beneficiary account.
   */
  export function award_child_bounty(
    value: Omit<pallet_child_bounties.pallet.Call.award_child_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ChildBounties", value: { ...value, type: "award_child_bounty" } }
  }
  /**
   * Claim the payout from an awarded child-bounty after payout delay.
   *
   * The dispatch origin for this call may be any signed origin.
   *
   * Call works independent of parent bounty state, No need for parent
   * bounty to be in active state.
   *
   * The Beneficiary is paid out with agreed bounty value. Curator fee is
   * paid & curator deposit is unreserved.
   *
   * Child-bounty must be in "PendingPayout" state, for processing the
   * call. And instance of child-bounty is removed from the state on
   * successful call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   */
  export function claim_child_bounty(
    value: Omit<pallet_child_bounties.pallet.Call.claim_child_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ChildBounties", value: { ...value, type: "claim_child_bounty" } }
  }
  /**
   * Cancel a proposed or active child-bounty. Child-bounty account funds
   * are transferred to parent bounty account. The child-bounty curator
   * deposit may be unreserved if possible.
   *
   * The dispatch origin for this call must be either parent curator or
   * `T::RejectOrigin`.
   *
   * If the state of child-bounty is `Active`, curator deposit is
   * unreserved.
   *
   * If the state of child-bounty is `PendingPayout`, call fails &
   * returns `PendingPayout` error.
   *
   * For the origin other than T::RejectOrigin, parent bounty must be in
   * active state, for this child-bounty call to work. For origin
   * T::RejectOrigin execution is forced.
   *
   * Instance of child-bounty is removed from the state on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   */
  export function close_child_bounty(
    value: Omit<pallet_child_bounties.pallet.Call.close_child_bounty, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ChildBounties", value: { ...value, type: "close_child_bounty" } }
  }
  /**
   * Propose curator for funded child-bounty.
   *
   * The dispatch origin for this call must be curator of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "Added" state, for processing the call. And
   * state of child-bounty is moved to "CuratorProposed" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `curator`: Address of child-bounty curator.
   * - `fee`: payment fee to child-bounty curator for execution.
   */
  export function propose_curator(
    value: Omit<pallet_child_bounties.pallet.Call.propose_curator, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ChildBounties", value: { ...value, type: "propose_curator" } }
  }
  /**
   * Unassign curator from a child-bounty.
   *
   * The dispatch origin for this call can be either `RejectOrigin`, or
   * the curator of the parent bounty, or any signed origin.
   *
   * For the origin other than T::RejectOrigin and the child-bounty
   * curator, parent bounty must be in active state, for this call to
   * work. We allow child-bounty curator and T::RejectOrigin to execute
   * this call irrespective of the parent bounty state.
   *
   * If this function is called by the `RejectOrigin` or the
   * parent bounty curator, we assume that the child-bounty curator is
   * malicious or inactive. As a result, child-bounty curator deposit is
   * slashed.
   *
   * If the origin is the child-bounty curator, we take this as a sign
   * that they are unable to do their job, and are willingly giving up.
   * We could slash the deposit, but for now we allow them to unreserve
   * their deposit and exit without issue. (We may want to change this if
   * it is abused.)
   *
   * Finally, the origin can be anyone iff the child-bounty curator is
   * "inactive". Expiry update due of parent bounty is used to estimate
   * inactive state of child-bounty curator.
   *
   * This allows anyone in the community to call out that a child-bounty
   * curator is not doing their due diligence, and we should pick a new
   * one. In this case the child-bounty curator deposit is slashed.
   *
   * State of child-bounty is moved to Added state on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   */
  export function unassign_curator(
    value: Omit<pallet_child_bounties.pallet.Call.unassign_curator, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ChildBounties", value: { ...value, type: "unassign_curator" } }
  }
}
export namespace Claims {
  export const Claims = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$73),
    value: _codec.$6,
  }
  /** Pre-claimed Ethereum accounts, by the Account ID that they are claimed to. */
  export const Preclaims = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$0),
    value: _codec.$73,
  }
  /** The statement kind that must be signed, if any. */
  export const Signing = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$73),
    value: _codec.$251,
  }
  export const Total = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$6,
  }
  /**
   *  Vesting schedule for a claim.
   *  First balance is the total amount that should be held for vesting.
   *  Second balance is how much should be unlocked per block.
   *  The block number is when the vesting should start.
   */
  export const Vesting = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$73),
    value: _codec.$249,
  }
  /**
   * Attest to a statement, needed to finalize the claims process.
   *
   * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a `SignedExtension`.
   *
   * Unsigned Validation:
   * A call to attest is deemed valid if the sender has a `Preclaim` registered
   * and provides a `statement` which is expected for the account.
   *
   * Parameters:
   * - `statement`: The identity of the statement which is being attested to in the signature.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to do pre-validation on `attest` call.
   *
   * Total Complexity: O(1)
   * </weight>
   */
  export function attest(
    value: Omit<polkadot_runtime_common.claims.pallet.Call.attest, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Claims", value: { ...value, type: "attest" } }
  }
  /**
   * Make a claim to collect your DOTs.
   *
   * The dispatch origin for this call must be _None_.
   *
   * Unsigned Validation:
   * A call to claim is deemed valid if the signature provided matches
   * the expected signed message of:
   *
   * > Ethereum Signed Message:
   * > (configured prefix string)(address)
   *
   * and `address` matches the `dest` account.
   *
   * Parameters:
   * - `dest`: The destination account to payout the claim.
   * - `ethereum_signature`: The signature of an ethereum signed message
   *    matching the format described above.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to validate unsigned `claim` call.
   *
   * Total Complexity: O(1)
   * </weight>
   */
  export function claim(
    value: Omit<polkadot_runtime_common.claims.pallet.Call.claim, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Claims", value: { ...value, type: "claim" } }
  }
  /**
   * Make a claim to collect your DOTs by signing a statement.
   *
   * The dispatch origin for this call must be _None_.
   *
   * Unsigned Validation:
   * A call to `claim_attest` is deemed valid if the signature provided matches
   * the expected signed message of:
   *
   * > Ethereum Signed Message:
   * > (configured prefix string)(address)(statement)
   *
   * and `address` matches the `dest` account; the `statement` must match that which is
   * expected according to your purchase arrangement.
   *
   * Parameters:
   * - `dest`: The destination account to payout the claim.
   * - `ethereum_signature`: The signature of an ethereum signed message
   *    matching the format described above.
   * - `statement`: The identity of the statement which is being attested to in the signature.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to validate unsigned `claim_attest` call.
   *
   * Total Complexity: O(1)
   * </weight>
   */
  export function claim_attest(
    value: Omit<polkadot_runtime_common.claims.pallet.Call.claim_attest, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Claims", value: { ...value, type: "claim_attest" } }
  }
  /**
   * Mint a new claim to collect DOTs.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * Parameters:
   * - `who`: The Ethereum address allowed to collect this claim.
   * - `value`: The number of DOTs that will be claimed.
   * - `vesting_schedule`: An optional vesting schedule for these DOTs.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * We assume worst case that both vesting and statement is being inserted.
   *
   * Total Complexity: O(1)
   * </weight>
   */
  export function mint_claim(
    value: Omit<polkadot_runtime_common.claims.pallet.Call.mint_claim, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Claims", value: { ...value, type: "mint_claim" } }
  }
  export function move_claim(
    value: Omit<polkadot_runtime_common.claims.pallet.Call.move_claim, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Claims", value: { ...value, type: "move_claim" } }
  }
}
export type Compact<T> = T
export namespace Configuration {
  /** The active configuration for the current session. */
  export const ActiveConfig = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$638,
  }
  /**
   *  If this is set, then the configuration setters will bypass the consistency checks. This
   *  is meant to be used only as the last resort.
   */
  export const BypassConsistencyCheck = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$43,
  }
  /**
   *  Pending configuration changes.
   *
   *  This is a list of configuration changes, each with a session index at which it should
   *  be applied.
   *
   *  The list is sorted ascending by session index. Also, this list can only contain at most
   *  2 items: for the next session and for the `scheduled_session`.
   */
  export const PendingConfigs = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$639,
  }
  /**
   * Setting this to true will disable consistency checks for the configuration setters.
   * Use with caution.
   */
  export function set_bypass_consistency_check(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_bypass_consistency_check,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_bypass_consistency_check" } }
  }
  /** Set the availability period for parachains. */
  export function set_chain_availability_period(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_chain_availability_period,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_chain_availability_period" } }
  }
  /** Set the acceptance period for an included candidate. */
  export function set_code_retention_period(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_code_retention_period,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_code_retention_period" } }
  }
  /** Set the dispute conclusion by time out period. */
  export function set_dispute_conclusion_by_time_out_period(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_conclusion_by_time_out_period,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_dispute_conclusion_by_time_out_period" },
    }
  }
  /** Set the maximum number of dispute spam slots. */
  export function set_dispute_max_spam_slots(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_max_spam_slots,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_dispute_max_spam_slots" } }
  }
  /** Set the dispute period, in number of sessions to keep for disputes. */
  export function set_dispute_period(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_period, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_dispute_period" } }
  }
  /** Set the dispute post conclusion acceptance period. */
  export function set_dispute_post_conclusion_acceptance_period(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_post_conclusion_acceptance_period,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_dispute_post_conclusion_acceptance_period" },
    }
  }
  /** Set the parachain validator-group rotation frequency */
  export function set_group_rotation_frequency(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_group_rotation_frequency,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_group_rotation_frequency" } }
  }
  /** Sets the maximum number of messages allowed in an HRMP channel at once. */
  export function set_hrmp_channel_max_capacity(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_capacity,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_hrmp_channel_max_capacity" } }
  }
  /** Sets the maximum size of a message that could ever be put into an HRMP channel. */
  export function set_hrmp_channel_max_message_size(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_message_size,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_hrmp_channel_max_message_size" },
    }
  }
  /** Sets the maximum total size of messages in bytes allowed in an HRMP channel at once. */
  export function set_hrmp_channel_max_total_size(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_total_size,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_hrmp_channel_max_total_size" } }
  }
  /** Sets the maximum number of outbound HRMP messages can be sent by a candidate. */
  export function set_hrmp_max_message_num_per_candidate(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_message_num_per_candidate,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_hrmp_max_message_num_per_candidate" },
    }
  }
  /** Sets the maximum number of inbound HRMP channels a parachain is allowed to accept. */
  export function set_hrmp_max_parachain_inbound_channels(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_inbound_channels,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_hrmp_max_parachain_inbound_channels" },
    }
  }
  /** Sets the maximum number of outbound HRMP channels a parachain is allowed to open. */
  export function set_hrmp_max_parachain_outbound_channels(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_outbound_channels,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_hrmp_max_parachain_outbound_channels" },
    }
  }
  /** Sets the maximum number of inbound HRMP channels a parathread is allowed to accept. */
  export function set_hrmp_max_parathread_inbound_channels(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_inbound_channels,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_hrmp_max_parathread_inbound_channels" },
    }
  }
  /** Sets the maximum number of outbound HRMP channels a parathread is allowed to open. */
  export function set_hrmp_max_parathread_outbound_channels(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_outbound_channels,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_hrmp_max_parathread_outbound_channels" },
    }
  }
  /** Sets the number of sessions after which an HRMP open channel request expires. */
  export function set_hrmp_open_request_ttl(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_open_request_ttl,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_hrmp_open_request_ttl" } }
  }
  /**
   * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
   * channel.
   */
  export function set_hrmp_recipient_deposit(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_recipient_deposit,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_hrmp_recipient_deposit" } }
  }
  /** Sets the amount of funds that the sender should provide for opening an HRMP channel. */
  export function set_hrmp_sender_deposit(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_sender_deposit,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_hrmp_sender_deposit" } }
  }
  /** Set the max validation code size for incoming upgrades. */
  export function set_max_code_size(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_max_code_size, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_code_size" } }
  }
  /** Set the critical downward message size. */
  export function set_max_downward_message_size(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_max_downward_message_size,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_downward_message_size" } }
  }
  /** Set the max head data size for paras. */
  export function set_max_head_data_size(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_max_head_data_size,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_head_data_size" } }
  }
  /** Set the max POV block size for incoming upgrades. */
  export function set_max_pov_size(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_max_pov_size, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_pov_size" } }
  }
  /** Sets the maximum number of messages that a candidate can contain. */
  export function set_max_upward_message_num_per_candidate(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_num_per_candidate,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_max_upward_message_num_per_candidate" },
    }
  }
  /** Sets the maximum size of an upward message that can be sent by a candidate. */
  export function set_max_upward_message_size(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_size,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_upward_message_size" } }
  }
  /** Sets the maximum items that can present in a upward dispatch queue at once. */
  export function set_max_upward_queue_count(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_count,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_upward_queue_count" } }
  }
  /** Sets the maximum total size of items that can present in a upward dispatch queue at once. */
  export function set_max_upward_queue_size(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_size,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_upward_queue_size" } }
  }
  /** Set the maximum number of validators to use in parachain consensus. */
  export function set_max_validators(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_validators" } }
  }
  /** Set the maximum number of validators to assign to any core. */
  export function set_max_validators_per_core(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators_per_core,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_max_validators_per_core" } }
  }
  /**
   * Sets the minimum delay between announcing the upgrade block for a parachain until the
   * upgrade taking place.
   *
   * See the field documentation for information and constraints for the new value.
   */
  export function set_minimum_validation_upgrade_delay(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_minimum_validation_upgrade_delay,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "Configuration",
      value: { ...value, type: "set_minimum_validation_upgrade_delay" },
    }
  }
  /** Set the total number of delay tranches. */
  export function set_n_delay_tranches(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_n_delay_tranches, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_n_delay_tranches" } }
  }
  /** Set the number of validators needed to approve a block. */
  export function set_needed_approvals(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_needed_approvals, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_needed_approvals" } }
  }
  /**
   * Set the no show slots, in number of number of consensus slots.
   * Must be at least 1.
   */
  export function set_no_show_slots(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_no_show_slots, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_no_show_slots" } }
  }
  /** Set the number of parathread execution cores. */
  export function set_parathread_cores(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_cores, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_parathread_cores" } }
  }
  /** Set the number of retries for a particular parathread. */
  export function set_parathread_retries(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_retries,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_parathread_retries" } }
  }
  /** Enable or disable PVF pre-checking. Consult the field documentation prior executing. */
  export function set_pvf_checking_enabled(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_checking_enabled,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_pvf_checking_enabled" } }
  }
  /** Set the number of session changes after which a PVF pre-checking voting is rejected. */
  export function set_pvf_voting_ttl(
    value: Omit<polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_voting_ttl, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_pvf_voting_ttl" } }
  }
  /** Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion. */
  export function set_relay_vrf_modulo_samples(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_relay_vrf_modulo_samples,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_relay_vrf_modulo_samples" } }
  }
  /** Set the scheduling lookahead, in expected number of blocks at peak throughput. */
  export function set_scheduling_lookahead(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_scheduling_lookahead,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_scheduling_lookahead" } }
  }
  /** Set the availability period for parathreads. */
  export function set_thread_availability_period(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_thread_availability_period,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_thread_availability_period" } }
  }
  /** Sets the maximum amount of weight any individual upward message may consume. */
  export function set_ump_max_individual_weight(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_ump_max_individual_weight,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_ump_max_individual_weight" } }
  }
  /** Sets the soft limit for the phase of dispatching dispatchable upward messages. */
  export function set_ump_service_total_weight(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_ump_service_total_weight,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_ump_service_total_weight" } }
  }
  /** Set the validation upgrade cooldown. */
  export function set_validation_upgrade_cooldown(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_cooldown,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_validation_upgrade_cooldown" } }
  }
  /** Set the validation upgrade delay. */
  export function set_validation_upgrade_delay(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_delay,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_validation_upgrade_delay" } }
  }
  /** Set the zeroth delay tranche width. */
  export function set_zeroth_delay_tranche_width(
    value: Omit<
      polkadot_runtime_parachains.configuration.pallet.Call.set_zeroth_delay_tranche_width,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Configuration", value: { ...value, type: "set_zeroth_delay_tranche_width" } }
  }
}
export namespace Council {
  /** The current members of the collective. This is stored sorted (just by value). */
  export const Members = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$206,
  }
  /** The prime member that helps determine the default vote behavior in case of absentations. */
  export const Prime = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$0,
  }
  /** Proposals so far. */
  export const ProposalCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Actual proposal for a given hash, if it's current. */
  export const ProposalOf = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$181,
  }
  /** The hashes of the active proposals. */
  export const Proposals = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$545,
  }
  /** Votes on a given proposal, if it is ongoing. */
  export const Voting = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$546,
  }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * # <weight>
   * ## Weight
   * - `O(B + M + P1 + P2)` where:
   *   - `B` is `proposal` size in bytes (length-fee-bounded)
   *   - `M` is members-count (code- and governance-bounded)
   *   - `P1` is the complexity of `proposal` preimage.
   *   - `P2` is proposal-count (code-bounded)
   * - DB:
   *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
   *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
   *    `O(P2)`)
   *  - any mutations done while executing `proposal` (`P1`)
   * - up to 3 events
   * # </weight>
   */
  export function close(
    value: Omit<pallet_collective.pallet.Call.close, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Council", value: { ...value, type: "close" } }
  }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * # <weight>
   * ## Weight
   * - `O(B + M + P1 + P2)` where:
   *   - `B` is `proposal` size in bytes (length-fee-bounded)
   *   - `M` is members-count (code- and governance-bounded)
   *   - `P1` is the complexity of `proposal` preimage.
   *   - `P2` is proposal-count (code-bounded)
   * - DB:
   *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
   *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
   *    `O(P2)`)
   *  - any mutations done while executing `proposal` (`P1`)
   * - up to 3 events
   * # </weight>
   */
  export function close_old_weight(
    value: Omit<pallet_collective.pallet.Call.close_old_weight, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Council", value: { ...value, type: "close_old_weight" } }
  }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * # <weight>
   * Complexity: O(P) where P is the number of max proposals
   * DB Weight:
   * * Reads: Proposals
   * * Writes: Voting, Proposals, ProposalOf
   * # </weight>
   */
  export function disapprove_proposal(
    value: Omit<pallet_collective.pallet.Call.disapprove_proposal, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Council", value: { ...value, type: "disapprove_proposal" } }
  }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * # <weight>
   * ## Weight
   * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
   *   `proposal`
   * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
   * - 1 event
   * # </weight>
   */
  export function execute(
    value: Omit<pallet_collective.pallet.Call.execute, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Council", value: { ...value, type: "execute" } }
  }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * # <weight>
   * ## Weight
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   *   - `B` is `proposal` size in bytes (length-fee-bounded)
   *   - `M` is members-count (code- and governance-bounded)
   *   - branching is influenced by `threshold` where:
   *     - `P1` is proposal execution complexity (`threshold < 2`)
   *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   * - DB:
   *   - 1 storage read `is_member` (codec `O(M)`)
   *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
   *   - DB accesses influenced by `threshold`:
   *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
   *     - OR proposal insertion (`threshold <= 2`)
   *       - 1 storage mutation `Proposals` (codec `O(P2)`)
   *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
   *       - 1 storage write `ProposalOf` (codec `O(B)`)
   *       - 1 storage write `Voting` (codec `O(M)`)
   *   - 1 event
   * # </weight>
   */
  export function propose(
    value: Omit<pallet_collective.pallet.Call.propose, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Council", value: { ...value, type: "propose" } }
  }
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   *   weight estimation.
   *
   * Requires root origin.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   *       the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * # <weight>
   * ## Weight
   * - `O(MP + N)` where:
   *   - `M` old-members-count (code- and governance-bounded)
   *   - `N` new-members-count (code- and governance-bounded)
   *   - `P` proposals-count (code-bounded)
   * - DB:
   *   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the
   *     members
   *   - 1 storage read (codec `O(P)`) for reading the proposals
   *   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
   *   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
   * # </weight>
   */
  export function set_members(
    value: Omit<pallet_collective.pallet.Call.set_members, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Council", value: { ...value, type: "set_members" } }
  }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * # <weight>
   * ## Weight
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   * - DB:
   *   - 1 storage read `Members` (codec `O(M)`)
   *   - 1 storage mutation `Voting` (codec `O(M)`)
   * - 1 event
   * # </weight>
   */
  export function vote(
    value: Omit<pallet_collective.pallet.Call.vote, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Council", value: { ...value, type: "vote" } }
  }
}
export namespace Crowdloan {
  /** The number of auctions that have entered into their ending period so far. */
  export const EndingsCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Info on all of the funds. */
  export const Funds = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$710,
  }
  /**
   *  The funds that have had additional contributions during the last block. This is used
   *  in order to determine which funds should submit new or updated bids.
   */
  export const NewRaise = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$662,
  }
  /** Tracker for the next available fund index */
  export const NextFundIndex = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   * Add an optional memo to an existing crowdloan contribution.
   *
   * Origin must be Signed, and the user must have contributed to the crowdloan.
   */
  export function add_memo(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.add_memo, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "add_memo" } }
  }
  /**
   * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
   * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
   */
  export function contribute(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.contribute, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "contribute" } }
  }
  /**
   * Contribute your entire balance to a crowd sale. This will transfer the entire balance of a user over to fund a parachain
   * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
   */
  export function contribute_all(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.contribute_all, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "contribute_all" } }
  }
  /**
   * Create a new crowdloaning campaign for a parachain slot with the given lease period range.
   *
   * This applies a lock to your parachain configuration, ensuring that it cannot be changed
   * by the parachain manager.
   */
  export function create(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.create, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "create" } }
  }
  /** Remove a fund after the retirement period has ended and all funds have been returned. */
  export function dissolve(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.dissolve, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "dissolve" } }
  }
  /**
   * Edit the configuration for an in-progress crowdloan.
   *
   * Can only be called by Root origin.
   */
  export function edit(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.edit, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "edit" } }
  }
  /**
   * Poke the fund into `NewRaise`
   *
   * Origin must be Signed, and the fund has non-zero raise.
   */
  export function poke(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.poke, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "poke" } }
  }
  /**
   * Automatically refund contributors of an ended crowdloan.
   * Due to weight restrictions, this function may need to be called multiple
   * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
   *
   * Origin must be signed, but can come from anyone.
   */
  export function refund(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.refund, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "refund" } }
  }
  /**
   * Withdraw full balance of a specific contributor.
   *
   * Origin must be signed, but can come from anyone.
   *
   * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement, then the retirement
   * flag must be set. For a fund to be ready for retirement, then:
   * - it must not already be in retirement;
   * - the amount of raised funds must be bigger than the _free_ balance of the account;
   * - and either:
   *   - the block number must be at least `end`; or
   *   - the current lease period must be greater than the fund's `last_period`.
   *
   * In this case, the fund's retirement flag is set and its `end` is reset to the current block
   * number.
   *
   * - `who`: The account whose contribution should be withdrawn.
   * - `index`: The parachain to whose crowdloan the contribution was made.
   */
  export function withdraw(
    value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.withdraw, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Crowdloan", value: { ...value, type: "withdraw" } }
  }
}
export namespace Democracy {
  /**
   *  A record of who vetoed what. Maps proposal hash to a possible existent block number
   *  (until when it may not be resubmitted) and who vetoed it.
   */
  export const Blacklist = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$543,
  }
  /** Record of all proposals that have been subject to emergency cancellation. */
  export const Cancellations = {
    type: "Map",
    modifier: "Default",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$43,
  }
  /**
   *  Those who have locked a deposit.
   *
   *  TWOX-NOTE: Safe, as increasing integer keys are safe.
   */
  export const DepositOf = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$531,
  }
  /**
   *  True if the last referendum tabled was submitted externally. False if it was a public
   *  proposal.
   */
  export const LastTabledWasExternal = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$43,
  }
  /**
   *  The lowest referendum index representing an unbaked referendum. Equal to
   *  `ReferendumCount` if there isn't a unbaked referendum.
   */
  export const LowestUnbaked = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  The referendum to be tabled whenever it would be valid to table an external proposal.
   *  This happens when a referendum needs to be tabled and one of two conditions are met:
   *  - `LastTabledWasExternal` is `false`; or
   *  - `PublicProps` is empty.
   */
  export const NextExternal = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$542,
  }
  /** The number of (public) proposals that have been made so far. */
  export const PublicPropCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** The public proposals. Unsorted. The second item is the proposal. */
  export const PublicProps = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$528,
  }
  /** The next free referendum index, aka the number of referenda started so far. */
  export const ReferendumCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Information concerning any given referendum.
   *
   *  TWOX-NOTE: SAFE as indexes are not under an attacker’s control.
   */
  export const ReferendumInfoOf = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$533,
  }
  /**
   *  All votes for a particular voter. We store the balance for the number of votes that we
   *  have recorded. The second item is the total amount of delegations, that will be added.
   *
   *  TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
   */
  export const VotingOf = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$536,
  }
  /**
   * Permanently place a proposal into the blacklist. This prevents it from ever being
   * proposed again.
   *
   * If called on a queued public or external proposal, then this will result in it being
   * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
   * then it will be cancelled.
   *
   * The dispatch origin of this call must be `BlacklistOrigin`.
   *
   * - `proposal_hash`: The proposal hash to blacklist permanently.
   * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
   * cancelled.
   *
   * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
   *   reasonable value).
   */
  export function blacklist(
    value: Omit<pallet_democracy.pallet.Call.blacklist, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "blacklist" } }
  }
  /**
   * Remove a proposal.
   *
   * The dispatch origin of this call must be `CancelProposalOrigin`.
   *
   * - `prop_index`: The index of the proposal to cancel.
   *
   * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
   */
  export function cancel_proposal(
    value: Omit<pallet_democracy.pallet.Call.cancel_proposal, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "cancel_proposal" } }
  }
  /**
   * Remove a referendum.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * - `ref_index`: The index of the referendum to cancel.
   *
   * # Weight: `O(1)`.
   */
  export function cancel_referendum(
    value: Omit<pallet_democracy.pallet.Call.cancel_referendum, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "cancel_referendum" } }
  }
  /**
   * Clears all public proposals.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * Weight: `O(1)`.
   */
  export function clear_public_proposals(): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { type: "clear_public_proposals" } }
  }
  /**
   * Delegate the voting power (with some given conviction) of the sending account.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   *   - be delegating already; or
   *   - have no voting activity (if there is, then it will need to be removed/consolidated
   *     through `reap_vote` or `unvote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   *   account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   *   be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   *   voted on. Weight is charged as if maximum votes.
   */
  export function delegate(
    value: Omit<pallet_democracy.pallet.Call.delegate, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "delegate" } }
  }
  /**
   * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
   * referendum.
   *
   * The dispatch origin of this call must be `CancellationOrigin`.
   *
   * -`ref_index`: The index of the referendum to cancel.
   *
   * Weight: `O(1)`.
   */
  export function emergency_cancel(
    value: Omit<pallet_democracy.pallet.Call.emergency_cancel, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "emergency_cancel" } }
  }
  /**
   * Schedule a referendum to be tabled once it is legal to schedule an external
   * referendum.
   *
   * The dispatch origin of this call must be `ExternalOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   */
  export function external_propose(
    value: Omit<pallet_democracy.pallet.Call.external_propose, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "external_propose" } }
  }
  /**
   * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
   * schedule an external referendum.
   *
   * The dispatch of this call must be `ExternalDefaultOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   */
  export function external_propose_default(
    value: Omit<pallet_democracy.pallet.Call.external_propose_default, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "external_propose_default" } }
  }
  /**
   * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
   * an external referendum.
   *
   * The dispatch of this call must be `ExternalMajorityOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   */
  export function external_propose_majority(
    value: Omit<pallet_democracy.pallet.Call.external_propose_majority, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "external_propose_majority" } }
  }
  /**
   * Schedule the currently externally-proposed majority-carries referendum to be tabled
   * immediately. If there is no externally-proposed referendum currently, or if there is one
   * but it is not a majority-carries referendum then it fails.
   *
   * The dispatch of this call must be `FastTrackOrigin`.
   *
   * - `proposal_hash`: The hash of the current external proposal.
   * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
   * 	Must be always greater than zero.
   * 	For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
   * - `delay`: The number of block after voting has ended in approval and this should be
   *   enacted. This doesn't have a minimum amount.
   *
   * Emits `Started`.
   *
   * Weight: `O(1)`
   */
  export function fast_track(
    value: Omit<pallet_democracy.pallet.Call.fast_track, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "fast_track" } }
  }
  /**
   * Propose a sensitive action to be taken.
   *
   * The dispatch origin of this call must be _Signed_ and the sender must
   * have funds to cover the deposit.
   *
   * - `proposal_hash`: The hash of the proposal preimage.
   * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
   *
   * Emits `Proposed`.
   */
  export function propose(
    value: Omit<pallet_democracy.pallet.Call.propose, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "propose" } }
  }
  /**
   * Remove a vote for a referendum.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the referendum was cancelled, because the voter lost the referendum or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   *   referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   *   Weight is calculated for the maximum number of vote.
   */
  export function remove_other_vote(
    value: Omit<pallet_democracy.pallet.Call.remove_other_vote, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "remove_other_vote" } }
  }
  /**
   * Remove a vote for a referendum.
   *
   * If:
   * - the referendum was cancelled, or
   * - the referendum is ongoing, or
   * - the referendum has ended such that
   *   - the vote of the account was in opposition to the result; or
   *   - there was no conviction to the account's vote; or
   *   - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the referendum has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for referendum `index`.
   *
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   *   Weight is calculated for the maximum number of vote.
   */
  export function remove_vote(
    value: Omit<pallet_democracy.pallet.Call.remove_vote, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "remove_vote" } }
  }
  /**
   * Signals agreement with a particular proposal.
   *
   * The dispatch origin of this call must be _Signed_ and the sender
   * must have funds to cover the deposit, equal to the original deposit.
   *
   * - `proposal`: The index of the proposal to second.
   */
  export function second(
    value: Omit<pallet_democracy.pallet.Call.second, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "second" } }
  }
  /**
   * Undelegate the voting power of the sending account.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   *   voted on. Weight is charged as if maximum votes.
   */
  export function undelegate(): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { type: "undelegate" } }
  }
  /**
   * Unlock tokens that have an expired lock.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   */
  export function unlock(
    value: Omit<pallet_democracy.pallet.Call.unlock, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "unlock" } }
  }
  /**
   * Veto and blacklist the external proposal hash.
   *
   * The dispatch origin of this call must be `VetoOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
   *
   * Emits `Vetoed`.
   *
   * Weight: `O(V + log(V))` where V is number of `existing vetoers`
   */
  export function veto_external(
    value: Omit<pallet_democracy.pallet.Call.veto_external, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "veto_external" } }
  }
  /**
   * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `ref_index`: The index of the referendum to vote for.
   * - `vote`: The vote configuration.
   */
  export function vote(
    value: Omit<pallet_democracy.pallet.Call.vote, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Democracy", value: { ...value, type: "vote" } }
  }
}
export namespace Dmp {
  /**
   *  A mapping that stores the downward message queue MQC head for each para.
   *
   *  Each link in this chain has a form:
   *  `(prev_head, B, H(M))`, where
   *  - `prev_head`: is the previous head hash or zero if none.
   *  - `B`: is the relay-chain block number in which a message was appended.
   *  - `H(M)`: is the hash of the message being appended.
   */
  export const DownwardMessageQueueHeads = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$11,
  }
  /** The downward messages addressed for a certain para. */
  export const DownwardMessageQueues = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$682,
  }
}
export namespace ElectionProviderMultiPhase {
  /** Current phase. */
  export const CurrentPhase = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$600,
  }
  /**
   *  Desired number of targets to elect for this round.
   *
   *  Only exists when [`Snapshot`] is present.
   */
  export const DesiredTargets = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  The minimum score that each 'untrusted' solution must attain in order to be considered
   *  feasible.
   *
   *  Can be set via `set_minimum_untrusted_score`.
   */
  export const MinimumUntrustedScore = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$88,
  }
  /** Current best solution, signed or unsigned, queued to be returned upon `elect`. */
  export const QueuedSolution = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$602,
  }
  /**
   *  Internal counter for the number of rounds.
   *
   *  This is useful for de-duplication of transactions submitted to the pool, and general
   *  diagnostics of the pallet.
   *
   *  This is merely incremented once per every time that an upstream `elect` is called.
   */
  export const Round = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  A sorted, bounded set of `(score, index)`, where each `index` points to a value in
   *  `SignedSubmissions`.
   *
   *  We never need to process more than a single signed submission at a time. Signed submissions
   *  can be quite large, so we're willing to pay the cost of multiple database accesses to access
   *  them one at a time instead of reading and decoding all of them at once.
   */
  export const SignedSubmissionIndices = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$606,
  }
  /**
   *  The next index to be assigned to an incoming signed submission.
   *
   *  Every accepted submission is assigned a unique index; that index is bound to that particular
   *  submission for the duration of the election. On election finalization, the next index is
   *  reset to 0.
   *
   *  We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
   *  capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
   *  because iteration is slow. Instead, we store the value here.
   */
  export const SignedSubmissionNextIndex = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Unchecked, signed solutions.
   *
   *  Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
   *  allowing us to keep only a single one in memory at a time.
   *
   *  Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
   *  affect; we shouldn't need a cryptographically secure hasher.
   */
  export const SignedSubmissionsMap = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$610,
  }
  /**
   *  Snapshot data of the round.
   *
   *  This is created at the beginning of the signed phase and cleared upon calling `elect`.
   */
  export const Snapshot = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$603,
  }
  /**
   *  The metadata of the [`RoundSnapshot`]
   *
   *  Only exists when [`Snapshot`] is present.
   */
  export const SnapshotMetadata = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$363,
  }
  /**
   * Trigger the governance fallback.
   *
   * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
   * calling [`Call::set_emergency_election_result`].
   */
  export function governance_fallback(
    value: Omit<pallet_election_provider_multi_phase.pallet.Call.governance_fallback, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ElectionProviderMultiPhase", value: { ...value, type: "governance_fallback" } }
  }
  /**
   * Set a solution in the queue, to be handed out to the client of this pallet in the next
   * call to `ElectionProvider::elect`.
   *
   * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
   *
   * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
   * feasibility check itself can in principle cause the election process to fail (due to
   * memory/weight constrains).
   */
  export function set_emergency_election_result(
    value: Omit<
      pallet_election_provider_multi_phase.pallet.Call.set_emergency_election_result,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "ElectionProviderMultiPhase",
      value: { ...value, type: "set_emergency_election_result" },
    }
  }
  /**
   * Set a new value for `MinimumUntrustedScore`.
   *
   * Dispatch origin must be aligned with `T::ForceOrigin`.
   *
   * This check can be turned off by setting the value to `None`.
   */
  export function set_minimum_untrusted_score(
    value: Omit<
      pallet_election_provider_multi_phase.pallet.Call.set_minimum_untrusted_score,
      "type"
    >,
  ): polkadot_runtime.RuntimeCall {
    return {
      type: "ElectionProviderMultiPhase",
      value: { ...value, type: "set_minimum_untrusted_score" },
    }
  }
  /**
   * Submit a solution for the signed phase.
   *
   * The dispatch origin fo this call must be __signed__.
   *
   * The solution is potentially queued, based on the claimed score and processed at the end
   * of the signed phase.
   *
   * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
   * might be rewarded, slashed, or get all or a part of the deposit back.
   */
  export function submit(
    value: Omit<pallet_election_provider_multi_phase.pallet.Call.submit, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ElectionProviderMultiPhase", value: { ...value, type: "submit" } }
  }
  /**
   * Submit a solution for the unsigned phase.
   *
   * The dispatch origin fo this call must be __none__.
   *
   * This submission is checked on the fly. Moreover, this unsigned solution is only
   * validated when submitted to the pool from the **local** node. Effectively, this means
   * that only active validators can submit this transaction when authoring a block (similar
   * to an inherent).
   *
   * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
   * panic if the solution submitted by the validator is invalid in any way, effectively
   * putting their authoring reward at risk.
   *
   * No deposit or reward is associated with this submission.
   */
  export function submit_unsigned(
    value: Omit<pallet_election_provider_multi_phase.pallet.Call.submit_unsigned, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ElectionProviderMultiPhase", value: { ...value, type: "submit_unsigned" } }
  }
}
export namespace FastUnstake {
  /** Counter for the related counted storage map */
  export const CounterForQueue = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Number of eras to check per block.
   *
   *  If set to 0, this pallet does absolutely nothing.
   *
   *  Based on the amount of weight available at `on_idle`, up to this many eras of a single
   *  nominator might be checked.
   */
  export const ErasToCheckPerBlock = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** The current "head of the queue" being unstaked. */
  export const Head = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$634,
  }
  /**
   *  The map of all accounts wishing to be unstaked.
   *
   *  Keeps track of `AccountId` wishing to unstake and it's corresponding deposit.
   */
  export const Queue = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$6,
  }
  /**
   * Control the operation of this pallet.
   *
   * Dispatch origin must be signed by the [`Config::ControlOrigin`].
   */
  export function control(
    value: Omit<pallet_fast_unstake.pallet.Call.control, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "FastUnstake", value: { ...value, type: "control" } }
  }
  /**
   * Deregister oneself from the fast-unstake.
   *
   * This is useful if one is registered, they are still waiting, and they change their mind.
   *
   * Note that the associated stash is still fully unbonded and chilled as a consequence of
   * calling `register_fast_unstake`. This should probably be followed by a call to
   * `Staking::rebond`.
   */
  export function deregister(): polkadot_runtime.RuntimeCall {
    return { type: "FastUnstake", value: { type: "deregister" } }
  }
  /**
   * Register oneself for fast-unstake.
   *
   * The dispatch origin of this call must be signed by the controller account, similar to
   * `staking::unbond`.
   *
   * The stash associated with the origin must have no ongoing unlocking chunks. If
   * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
   * to be checked in further blocks.
   *
   * If by the time this is called, the stash is actually eligible for fast-unstake, then
   * they are guaranteed to remain eligible, because the call will chill them as well.
   *
   * If the check works, the entire staking data is removed, i.e. the stash is fully
   * unstaked.
   *
   * If the check fails, the stash remains chilled and waiting for being unbonded as in with
   * the normal staking system, but they lose part of their unbonding chunks due to consuming
   * the chain's resources.
   */
  export function register_fast_unstake(): polkadot_runtime.RuntimeCall {
    return { type: "FastUnstake", value: { type: "register_fast_unstake" } }
  }
}
export namespace Grandpa {
  /**
   *  The number of changes (both in terms of keys and underlying economic responsibilities)
   *  in the "set" of Grandpa validators from genesis.
   */
  export const CurrentSetId = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$10,
  }
  /** next block number where we can force a change. */
  export const NextForced = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Pending change: (signaled at, scheduled change). */
  export const PendingChange = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$517,
  }
  /**
   *  A mapping from grandpa set ID to the index of the *most recent* session for which its
   *  members were responsible.
   *
   *  TWOX-NOTE: `SetId` is not under user control.
   */
  export const SetIdSession = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$10),
    value: _codec.$4,
  }
  /** `true` if we are currently stalled. */
  export const Stalled = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$30,
  }
  /** State of the current authority set. */
  export const State = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$516,
  }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   */
  export function note_stalled(
    value: Omit<pallet_grandpa.pallet.Call.note_stalled, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Grandpa", value: { ...value, type: "note_stalled" } }
  }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   */
  export function report_equivocation(
    value: Omit<pallet_grandpa.pallet.Call.report_equivocation, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Grandpa", value: { ...value, type: "report_equivocation" } }
  }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   */
  export function report_equivocation_unsigned(
    value: Omit<pallet_grandpa.pallet.Call.report_equivocation_unsigned, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Grandpa", value: { ...value, type: "report_equivocation_unsigned" } }
  }
}
export namespace Hrmp {
  /**
   *  This mapping tracks how many open channel requests were accepted by a given recipient para.
   *  Invariant: `HrmpOpenChannelRequests` should contain the same number of items `(_, X)` with
   *  `confirmed` set to true, as the number of `HrmpAcceptedChannelRequestCount` for `X`.
   */
  export const HrmpAcceptedChannelRequestCount = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$4,
  }
  /**
   *  Storage for the messages for each channel.
   *  Invariant: cannot be non-empty if the corresponding channel in `HrmpChannels` is `None`.
   */
  export const HrmpChannelContents = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$112),
    value: _codec.$690,
  }
  /**
   *  Maintains a mapping that can be used to answer the question: What paras sent a message at
   *  the given block number for a given receiver. Invariants:
   *  - The inner `Vec<ParaId>` is never empty.
   *  - The inner `Vec<ParaId>` cannot store two same `ParaId`.
   *  - The outer vector is sorted ascending by block number and cannot store two items with the
   *    same block number.
   */
  export const HrmpChannelDigests = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$692,
  }
  /**
   *  HRMP channel data associated with each para.
   *  Invariant:
   *  - each participant in the channel should satisfy `Paras::is_valid_para(P)` within a session.
   */
  export const HrmpChannels = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$112),
    value: _codec.$688,
  }
  /**
   *  A set of pending HRMP close channel requests that are going to be closed during the session
   *  change. Used for checking if a given channel is registered for closure.
   *
   *  The set is accompanied by a list for iteration.
   *
   *  Invariant:
   *  - There are no channels that exists in list but not in the set and vice versa.
   */
  export const HrmpCloseChannelRequests = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$112),
    value: _codec.$33,
  }
  export const HrmpCloseChannelRequestsList = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$687,
  }
  export const HrmpEgressChannelsIndex = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$662,
  }
  /**
   *  Ingress/egress indexes allow to find all the senders and receivers given the opposite side.
   *  I.e.
   *
   *  (a) ingress index allows to find all the senders for a given recipient.
   *  (b) egress index allows to find all the recipients for a given sender.
   *
   *  Invariants:
   *  - for each ingress index entry for `P` each item `I` in the index should present in
   *    `HrmpChannels` as `(I, P)`.
   *  - for each egress index entry for `P` each item `E` in the index should present in
   *    `HrmpChannels` as `(P, E)`.
   *  - there should be no other dangling channels in `HrmpChannels`.
   *  - the vectors are sorted.
   */
  export const HrmpIngressChannelsIndex = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$662,
  }
  /**
   *  This mapping tracks how many open channel requests are initiated by a given sender para.
   *  Invariant: `HrmpOpenChannelRequests` should contain the same number of items that has
   *  `(X, _)` as the number of `HrmpOpenChannelRequestCount` for `X`.
   */
  export const HrmpOpenChannelRequestCount = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$4,
  }
  /**
   *  The set of pending HRMP open channel requests.
   *
   *  The set is accompanied by a list for iteration.
   *
   *  Invariant:
   *  - There are no channels that exists in list but not in the set and vice versa.
   */
  export const HrmpOpenChannelRequests = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$112),
    value: _codec.$686,
  }
  export const HrmpOpenChannelRequestsList = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$687,
  }
  /**
   *  The HRMP watermark associated with each para.
   *  Invariant:
   *  - each para `P` used here as a key should satisfy `Paras::is_valid_para(P)` within a session.
   */
  export const HrmpWatermarks = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$4,
  }
  /**
   * This extrinsic triggers the cleanup of all the HRMP storage items that
   * a para may have. Normally this happens once per session, but this allows
   * you to trigger the cleanup immediately for a specific parachain.
   *
   * Origin must be Root.
   *
   * Number of inbound and outbound channels for `para` must be provided as witness data of weighing.
   */
  export function force_clean_hrmp(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.force_clean_hrmp, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "force_clean_hrmp" } }
  }
  /**
   * Open a channel from a `sender` to a `recipient` `ParaId` using the Root origin. Although
   * opened by Root, the `max_capacity` and `max_message_size` are still subject to the Relay
   * Chain's configured limits.
   *
   * Expected use is when one of the `ParaId`s involved in the channel is governed by the
   * Relay Chain, e.g. a common good parachain.
   */
  export function force_open_hrmp_channel(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.force_open_hrmp_channel, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "force_open_hrmp_channel" } }
  }
  /**
   * Force process HRMP close channel requests.
   *
   * If there are pending HRMP close channel requests, you can use this
   * function process all of those requests immediately.
   *
   * Total number of closing channels must be provided as witness data of weighing.
   */
  export function force_process_hrmp_close(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_close, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "force_process_hrmp_close" } }
  }
  /**
   * Force process HRMP open channel requests.
   *
   * If there are pending HRMP open channel requests, you can use this
   * function process all of those requests immediately.
   *
   * Total number of opening channels must be provided as witness data of weighing.
   */
  export function force_process_hrmp_open(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_open, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "force_process_hrmp_open" } }
  }
  /**
   * Accept a pending open channel request from the given sender.
   *
   * The channel will be opened only on the next session boundary.
   */
  export function hrmp_accept_open_channel(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_accept_open_channel, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "hrmp_accept_open_channel" } }
  }
  /**
   * This cancels a pending open channel request. It can be canceled by either of the sender
   * or the recipient for that request. The origin must be either of those.
   *
   * The cancellation happens immediately. It is not possible to cancel the request if it is
   * already accepted.
   *
   * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
   * witness data.
   */
  export function hrmp_cancel_open_request(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_cancel_open_request, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "hrmp_cancel_open_request" } }
  }
  /**
   * Initiate unilateral closing of a channel. The origin must be either the sender or the
   * recipient in the channel being closed.
   *
   * The closure can only happen on a session change.
   */
  export function hrmp_close_channel(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_close_channel, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "hrmp_close_channel" } }
  }
  /**
   * Initiate opening a channel from a parachain to a given recipient with given channel
   * parameters.
   *
   * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
   * - `proposed_max_message_size` - specifies the maximum size of the messages.
   *
   * These numbers are a subject to the relay-chain configuration limits.
   *
   * The channel can be opened only after the recipient confirms it and only on a session
   * change.
   */
  export function hrmp_init_open_channel(
    value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_init_open_channel, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Hrmp", value: { ...value, type: "hrmp_init_open_channel" } }
  }
}
export namespace Identity {
  /**
   *  Information that is pertinent to identify the entity behind an account.
   *
   *  TWOX-NOTE: OK ― `AccountId` is a secure hash.
   */
  export const IdentityOf = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$568,
  }
  /**
   *  The set of registrars. Not expected to get very big as can only be added through a
   *  special origin (likely a council motion).
   *
   *  The index into this can be cast to `RegistrarIndex` to get a valid value.
   */
  export const Registrars = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$574,
  }
  /**
   *  Alternative "sub" identities of this account.
   *
   *  The first item is the deposit, the second is a vector of the accounts.
   *
   *  TWOX-NOTE: OK ― `AccountId` is a secure hash.
   */
  export const SubsOf = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$572,
  }
  /**
   *  The super-identity of an alternative "sub" identity together with its name, within that
   *  context. If the account is not some other account's sub-identity, then just `None`.
   */
  export const SuperOf = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$299,
  }
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   *
   * # <weight>
   * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
   * - One storage mutation (codec `O(R)`).
   * - One event.
   * # </weight>
   */
  export function add_registrar(
    value: Omit<pallet_identity.pallet.Call.add_registrar, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "add_registrar" } }
  }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   */
  export function add_sub(
    value: Omit<pallet_identity.pallet.Call.add_sub, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "add_sub" } }
  }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   *
   * # <weight>
   * - `O(R + X)`.
   * - One balance-reserve operation.
   * - One storage mutation `O(R + X)`.
   * - One event
   * # </weight>
   */
  export function cancel_request(
    value: Omit<pallet_identity.pallet.Call.cancel_request, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "cancel_request" } }
  }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   *
   * # <weight>
   * - `O(R + S + X)`
   *   - where `R` registrar-count (governance-bounded).
   *   - where `S` subs-count (hard- and deposit-bounded).
   *   - where `X` additional-field-count (deposit-bounded and code-bounded).
   * - One balance-unreserve operation.
   * - `2` storage reads and `S + 2` storage deletions.
   * - One event.
   * # </weight>
   */
  export function clear_identity(): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { type: "clear_identity" } }
  }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   *   with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   *
   * # <weight>
   * - `O(R + S + X)`.
   * - One balance-reserve operation.
   * - `S + 2` storage mutations.
   * - One event.
   * # </weight>
   */
  export function kill_identity(
    value: Omit<pallet_identity.pallet.Call.kill_identity, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "kill_identity" } }
  }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   *   with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
   *
   * Emits `JudgementGiven` if successful.
   *
   * # <weight>
   * - `O(R + X)`.
   * - One balance-transfer operation.
   * - Up to one account-lookup operation.
   * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
   * - One event.
   * # </weight>
   */
  export function provide_judgement(
    value: Omit<pallet_identity.pallet.Call.provide_judgement, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "provide_judgement" } }
  }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   */
  export function quit_sub(): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { type: "quit_sub" } }
  }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   */
  export function remove_sub(
    value: Omit<pallet_identity.pallet.Call.remove_sub, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "remove_sub" } }
  }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   */
  export function rename_sub(
    value: Omit<pallet_identity.pallet.Call.rename_sub, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "rename_sub" } }
  }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Self::registrars().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   *
   * # <weight>
   * - `O(R + X)`.
   * - One balance-reserve operation.
   * - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.
   * - One event.
   * # </weight>
   */
  export function request_judgement(
    value: Omit<pallet_identity.pallet.Call.request_judgement, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "request_judgement" } }
  }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   *
   * # <weight>
   * - `O(R)`.
   * - One storage mutation `O(R)`.
   * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
   * # </weight>
   */
  export function set_account_id(
    value: Omit<pallet_identity.pallet.Call.set_account_id, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "set_account_id" } }
  }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   *
   * # <weight>
   * - `O(R)`.
   * - One storage mutation `O(R)`.
   * - Benchmark: 7.315 + R * 0.329 µs (min squares analysis)
   * # </weight>
   */
  export function set_fee(
    value: Omit<pallet_identity.pallet.Call.set_fee, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "set_fee" } }
  }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   *
   * # <weight>
   * - `O(R)`.
   * - One storage mutation `O(R)`.
   * - Benchmark: 7.464 + R * 0.325 µs (min squares analysis)
   * # </weight>
   */
  export function set_fields(
    value: Omit<pallet_identity.pallet.Call.set_fields, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "set_fields" } }
  }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   *
   * # <weight>
   * - `O(X + X' + R)`
   *   - where `X` additional-field-count (deposit-bounded and code-bounded)
   *   - where `R` judgements-count (registrar-count-bounded)
   * - One balance reserve operation.
   * - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).
   * - One event.
   * # </weight>
   */
  export function set_identity(
    value: Omit<pallet_identity.pallet.Call.set_identity, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "set_identity" } }
  }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   *
   * # <weight>
   * - `O(P + S)`
   *   - where `P` old-subs-count (hard- and deposit-bounded).
   *   - where `S` subs-count (hard- and deposit-bounded).
   * - At most one balance operations.
   * - DB:
   *   - `P + S` storage mutations (codec complexity `O(1)`)
   *   - One storage read (codec complexity `O(P)`).
   *   - One storage write (codec complexity `O(S)`).
   *   - One storage-exists (`IdentityOf::contains_key`).
   * # </weight>
   */
  export function set_subs(
    value: Omit<pallet_identity.pallet.Call.set_subs, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Identity", value: { ...value, type: "set_subs" } }
  }
}
export namespace ImOnline {
  /**
   *  For each session index, we keep a mapping of `ValidatorId<T>` to the
   *  number of blocks authored by the given authority.
   */
  export const AuthoredBlocks = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$494,
    value: _codec.$4,
  }
  /**
   *  The block number after which it's ok to send heartbeats in the current
   *  session.
   *
   *  At the beginning of each session we set this to a value that should fall
   *  roughly in the middle of the session duration. The idea is to first wait for
   *  the validators to produce a block in the current session, so that the
   *  heartbeat later on will not be necessary.
   *
   *  This value will only be used as a fallback if we fail to get a proper session
   *  progress estimate from `NextSessionRotation`, as those estimates should be
   *  more accurate then the value we calculate for `HeartbeatAfter`.
   */
  export const HeartbeatAfter = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** The current set of keys that may issue a heartbeat. */
  export const Keys = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$520,
  }
  /**
   *  For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to
   *  `WrapperOpaque<BoundedOpaqueNetworkState>`.
   */
  export const ReceivedHeartbeats = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$30,
    value: _codec.$522,
  }
  /**
   * # <weight>
   * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is
   *   length of `heartbeat.network_state.external_address`
   *   - `O(K)`: decoding of length `K`
   *   - `O(E)`: decoding/encoding of length `E`
   * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
   *   `ReceivedHeartbeats`
   * - DbWrites: `ReceivedHeartbeats`
   * # </weight>
   */
  export function heartbeat(
    value: Omit<pallet_im_online.pallet.Call.heartbeat, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ImOnline", value: { ...value, type: "heartbeat" } }
  }
}
export namespace Indices {
  /** The lookup from index to account. */
  export const Accounts = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$468,
  }
  /**
   * Assign an previously unassigned index.
   *
   * Payment: `Deposit` is reserved from the sender account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be claimed. This must not be in use.
   *
   * Emits `IndexAssigned` if successful.
   *
   * # <weight>
   * - `O(1)`.
   * - One storage mutation (codec `O(1)`).
   * - One reserve operation.
   * - One event.
   * -------------------
   * - DB Weight: 1 Read/Write (Accounts)
   * # </weight>
   */
  export function claim(
    value: Omit<pallet_indices.pallet.Call.claim, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Indices", value: { ...value, type: "claim" } }
  }
  /**
   * Force an index to an account. This doesn't require a deposit. If the index is already
   * held, then any deposit is reimbursed to its current owner.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `index`: the index to be (re-)assigned.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
   *
   * Emits `IndexAssigned` if successful.
   *
   * # <weight>
   * - `O(1)`.
   * - One storage mutation (codec `O(1)`).
   * - Up to one reserve operation.
   * - One event.
   * -------------------
   * - DB Weight:
   *    - Reads: Indices Accounts, System Account (original owner)
   *    - Writes: Indices Accounts, System Account (original owner)
   * # </weight>
   */
  export function force_transfer(
    value: Omit<pallet_indices.pallet.Call.force_transfer, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Indices", value: { ...value, type: "force_transfer" } }
  }
  /**
   * Free up an index owned by the sender.
   *
   * Payment: Any previous deposit placed for the index is unreserved in the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must own the index.
   *
   * - `index`: the index to be freed. This must be owned by the sender.
   *
   * Emits `IndexFreed` if successful.
   *
   * # <weight>
   * - `O(1)`.
   * - One storage mutation (codec `O(1)`).
   * - One reserve operation.
   * - One event.
   * -------------------
   * - DB Weight: 1 Read/Write (Accounts)
   * # </weight>
   */
  export function free(
    value: Omit<pallet_indices.pallet.Call.free, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Indices", value: { ...value, type: "free" } }
  }
  /**
   * Freeze an index so it will always point to the sender account. This consumes the
   * deposit.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must have a
   * non-frozen account `index`.
   *
   * - `index`: the index to be frozen in place.
   *
   * Emits `IndexFrozen` if successful.
   *
   * # <weight>
   * - `O(1)`.
   * - One storage mutation (codec `O(1)`).
   * - Up to one slash operation.
   * - One event.
   * -------------------
   * - DB Weight: 1 Read/Write (Accounts)
   * # </weight>
   */
  export function freeze(
    value: Omit<pallet_indices.pallet.Call.freeze, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Indices", value: { ...value, type: "freeze" } }
  }
  /**
   * Assign an index already owned by the sender to another account. The balance reservation
   * is effectively transferred to the new account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be re-assigned. This must be owned by the sender.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   *
   * Emits `IndexAssigned` if successful.
   *
   * # <weight>
   * - `O(1)`.
   * - One storage mutation (codec `O(1)`).
   * - One transfer operation.
   * - One event.
   * -------------------
   * - DB Weight:
   *    - Reads: Indices Accounts, System Account (recipient)
   *    - Writes: Indices Accounts, System Account (recipient)
   * # </weight>
   */
  export function transfer(
    value: Omit<pallet_indices.pallet.Call.transfer, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Indices", value: { ...value, type: "transfer" } }
  }
}
export namespace Initializer {
  /**
   *  Buffered session changes along with the block number at which they should be applied.
   *
   *  Typically this will be empty or one element long. Apart from that this item never hits
   *  the storage.
   *
   *  However this is a `Vec` regardless to handle various edge cases that may occur at runtime
   *  upgrade boundaries or if governance intervenes.
   */
  export const BufferedSessionChanges = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$680,
  }
  /**
   *  Whether the parachains modules have been initialized within this block.
   *
   *  Semantically a `bool`, but this guarantees it should never hit the trie,
   *  as this is cleared in `on_finalize` and Frame optimizes `None` values to be empty values.
   *
   *  As a `bool`, `set(false)` and `remove()` both lead to the next `get()` being false, but one of
   *  them writes to the trie and one does not. This confusion makes `Option<()>` more suitable for
   *  the semantics of this variable.
   */
  export const HasInitialized = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$33,
  }
  /**
   * Issue a signal to the consensus engine to forcibly act as though all parachain
   * blocks in all relay chain blocks up to and including the given number in the current
   * chain are valid and should be finalized.
   */
  export function force_approve(
    value: Omit<polkadot_runtime_parachains.initializer.pallet.Call.force_approve, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Initializer", value: { ...value, type: "force_approve" } }
  }
}
export namespace Multisig {
  /** The set of open multisig operations. */
  export const Multisigs = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Blake2_128Concat"],
    key: _codec.$588,
    value: _codec.$589,
  }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * # <weight>
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   * ----------------------------------
   * - DB Weight:
   *     - Read: Multisig Storage, [Caller Account]
   *     - Write: Multisig Storage, [Caller Account]
   * # </weight>
   */
  export function approve_as_multi(
    value: Omit<pallet_multisig.pallet.Call.approve_as_multi, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Multisig", value: { ...value, type: "approve_as_multi" } }
  }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * # <weight>
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   * -------------------------------
   * - DB Weight:
   *     - Reads: Multisig Storage, [Caller Account]
   *     - Writes: Multisig Storage, [Caller Account]
   * - Plus Call Weight
   * # </weight>
   */
  export function as_multi(
    value: Omit<pallet_multisig.pallet.Call.as_multi, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Multisig", value: { ...value, type: "as_multi" } }
  }
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * # <weight>
   * O(Z + C) where Z is the length of the call and C its execution weight.
   * -------------------------------
   * - DB Weight: None
   * - Plus Call Weight
   * # </weight>
   */
  export function as_multi_threshold_1(
    value: Omit<pallet_multisig.pallet.Call.as_multi_threshold_1, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Multisig", value: { ...value, type: "as_multi_threshold_1" } }
  }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * # <weight>
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   * ----------------------------------
   * - DB Weight:
   *     - Read: Multisig Storage, [Caller Account], Refund Account
   *     - Write: Multisig Storage, [Caller Account], Refund Account
   * # </weight>
   */
  export function cancel_as_multi(
    value: Omit<pallet_multisig.pallet.Call.cancel_as_multi, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Multisig", value: { ...value, type: "cancel_as_multi" } }
  }
}
export namespace NominationPools {
  /** Storage for bonded pools. */
  export const BondedPools = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$622,
  }
  /** Counter for the related counted storage map */
  export const CounterForBondedPools = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Counter for the related counted storage map */
  export const CounterForMetadata = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Counter for the related counted storage map */
  export const CounterForPoolMembers = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Counter for the related counted storage map */
  export const CounterForReversePoolIdLookup = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Counter for the related counted storage map */
  export const CounterForRewardPools = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Counter for the related counted storage map */
  export const CounterForSubPoolsStorage = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Ever increasing number of all pools created so far. */
  export const LastPoolId = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Maximum number of members that can exist in the system. If `None`, then the count
   *  members are not bound on a system wide basis.
   */
  export const MaxPoolMembers = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Maximum number of members that may belong to pool. If `None`, then the count of
   *  members is not bound on a per pool basis.
   */
  export const MaxPoolMembersPerPool = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
   *  pools can exist.
   */
  export const MaxPools = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Metadata for the pool. */
  export const Metadata = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$631,
  }
  /**
   *  Minimum bond required to create a pool.
   *
   *  This is the amount that the depositor must put as their initial stake in the pool, as an
   *  indication of "skin in the game".
   *
   *  This is the value that will always exist in the staking ledger of the pool bonded account
   *  while all other accounts leave.
   */
  export const MinCreateBond = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$6,
  }
  /** Minimum amount to bond to join a pool. */
  export const MinJoinBond = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$6,
  }
  /** Active members. */
  export const PoolMembers = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$617,
  }
  /**
   *  A reverse lookup from the pool's account id to its id.
   *
   *  This is only used for slashing. In all other instances, the pool id is used, and the
   *  accounts are deterministically derived from it.
   */
  export const ReversePoolIdLookup = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$4,
  }
  /**
   *  Reward pools. This is where there rewards for each pool accumulate. When a members payout
   *  is claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account.
   */
  export const RewardPools = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$624,
  }
  /**
   *  Groups of unbonding pools. Each group of unbonding pools belongs to a bonded pool,
   *  hence the name sub-pools. Keyed by the bonded pools account.
   */
  export const SubPoolsStorage = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$625,
  }
  /**
   * Bond `extra` more funds from `origin` into the pool to which they already belong.
   *
   * Additional funds can come from either the free balance of the account, of from the
   * accumulated rewards, see [`BondExtra`].
   *
   * Bonding extra funds implies an automatic payout of all pending rewards as well.
   */
  export function bond_extra(
    value: Omit<pallet_nomination_pools.pallet.Call.bond_extra, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "bond_extra" } }
  }
  /**
   * Chill on behalf of the pool.
   *
   * The dispatch origin of this call must be signed by the pool nominator or the pool
   * root role, same as [`Pallet::nominate`].
   *
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   */
  export function chill(
    value: Omit<pallet_nomination_pools.pallet.Call.chill, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "chill" } }
  }
  /**
   * A bonded member can use this to claim their payout based on the rewards that the pool
   * has accumulated since their last claimed payout (OR since joining if this is there first
   * time claiming rewards). The payout will be transferred to the member's account.
   *
   * The member will earn rewards pro rata based on the members stake vs the sum of the
   * members in the pools stake. Rewards do not "expire".
   */
  export function claim_payout(): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { type: "claim_payout" } }
  }
  /**
   * Create a new delegation pool.
   *
   * # Arguments
   *
   * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
   *   deposit since the pools creator cannot fully unbond funds until the pool is being
   *   destroyed.
   * * `index` - A disambiguation index for creating the account. Likely only useful when
   *   creating multiple pools in the same extrinsic.
   * * `root` - The account to set as [`PoolRoles::root`].
   * * `nominator` - The account to set as the [`PoolRoles::nominator`].
   * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
   *
   * # Note
   *
   * In addition to `amount`, the caller will transfer the existential deposit; so the caller
   * needs at have at least `amount + existential_deposit` transferrable.
   */
  export function create(
    value: Omit<pallet_nomination_pools.pallet.Call.create, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "create" } }
  }
  /**
   * Stake funds with a pool. The amount to bond is transferred from the member to the
   * pools account and immediately increases the pools bond.
   *
   * # Note
   *
   * * An account can only be a member of a single pool.
   * * An account cannot join the same pool multiple times.
   * * This call will *not* dust the member account, so the member must have at least
   *   `existential deposit + amount` in their account.
   * * Only a pool with [`PoolState::Open`] can be joined
   */
  export function join(
    value: Omit<pallet_nomination_pools.pallet.Call.join, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "join" } }
  }
  /**
   * Nominate on behalf of the pool.
   *
   * The dispatch origin of this call must be signed by the pool nominator or the pool
   * root role.
   *
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   */
  export function nominate(
    value: Omit<pallet_nomination_pools.pallet.Call.nominate, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "nominate" } }
  }
  /**
   * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
   *
   * This is useful if their are too many unlocking chunks to call `unbond`, and some
   * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
   * would probably see an error like `NoMoreChunks` emitted from the staking system when
   * they attempt to unbond.
   */
  export function pool_withdraw_unbonded(
    value: Omit<pallet_nomination_pools.pallet.Call.pool_withdraw_unbonded, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "pool_withdraw_unbonded" } }
  }
  /**
   * Update configurations for the nomination pools. The origin for this call must be
   * Root.
   *
   * # Arguments
   *
   * * `min_join_bond` - Set [`MinJoinBond`].
   * * `min_create_bond` - Set [`MinCreateBond`].
   * * `max_pools` - Set [`MaxPools`].
   * * `max_members` - Set [`MaxPoolMembers`].
   * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
   */
  export function set_configs(
    value: Omit<pallet_nomination_pools.pallet.Call.set_configs, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "set_configs" } }
  }
  /**
   * Set a new metadata for the pool.
   *
   * The dispatch origin of this call must be signed by the state toggler, or the root role
   * of the pool.
   */
  export function set_metadata(
    value: Omit<pallet_nomination_pools.pallet.Call.set_metadata, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "set_metadata" } }
  }
  /**
   * Set a new state for the pool.
   *
   * If a pool is already in the `Destroying` state, then under no condition can its state
   * change again.
   *
   * The dispatch origin of this call must be either:
   *
   * 1. signed by the state toggler, or the root role of the pool,
   * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
   *    then the state of the pool can be permissionlessly changed to `Destroying`.
   */
  export function set_state(
    value: Omit<pallet_nomination_pools.pallet.Call.set_state, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "set_state" } }
  }
  /**
   * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
   * implicitly collects the rewards one last time, since not doing so would mean some
   * rewards would be forfeited.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch.
   *
   * * The pool is blocked and the caller is either the root or state-toggler. This is
   *   refereed to as a kick.
   * * The pool is destroying and the member is not the depositor.
   * * The pool is destroying, the member is the depositor and no other members are in the
   *   pool.
   *
   * ## Conditions for permissioned dispatch (i.e. the caller is also the
   * `member_account`):
   *
   * * The caller is not the depositor.
   * * The caller is the depositor, the pool is destroying and no other members are in the
   *   pool.
   *
   * # Note
   *
   * If there are too many unlocking chunks to unbond with the pool account,
   * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If
   * there are too many unlocking chunks, the result of this call will likely be the
   * `NoMoreChunks` error from the staking system.
   */
  export function unbond(
    value: Omit<pallet_nomination_pools.pallet.Call.unbond, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "unbond" } }
  }
  /**
   * Update the roles of the pool.
   *
   * The root is the only entity that can change any of the roles, including itself,
   * excluding the depositor, who can never change.
   *
   * It emits an event, notifying UIs of the role change. This event is quite relevant to
   * most pool members and they should be informed of changes to pool roles.
   */
  export function update_roles(
    value: Omit<pallet_nomination_pools.pallet.Call.update_roles, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "update_roles" } }
  }
  /**
   * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
   * error is returned.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch
   *
   * * The pool is in destroy mode and the target is not the depositor.
   * * The target is the depositor and they are the only member in the sub pools.
   * * The pool is blocked and the caller is either the root or state-toggler.
   *
   * # Conditions for permissioned dispatch
   *
   * * The caller is the target and they are not the depositor.
   *
   * # Note
   *
   * If the target is the depositor, the pool will be destroyed.
   */
  export function withdraw_unbonded(
    value: Omit<pallet_nomination_pools.pallet.Call.withdraw_unbonded, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "NominationPools", value: { ...value, type: "withdraw_unbonded" } }
  }
}
export namespace Offences {
  /** A vector of reports of the same kind that happened at the same time slot. */
  export const ConcurrentReportsIndex = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$510,
    value: _codec.$157,
  }
  /** The primary structure that holds all offence records keyed by report identifiers. */
  export const Reports = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$11),
    value: _codec.$509,
  }
  /**
   *  Enumerates all reports of a kind along with the time they happened.
   *
   *  All reports are sorted by the time of offence.
   *
   *  Note that the actual type of this mapping is `Vec<u8>`, this is because values of
   *  different types are not supported at the moment so we are doing the manual serialization.
   */
  export const ReportsByKindIndex = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$45),
    value: _codec.$12,
  }
}
export namespace ParaInclusion {
  /** The latest bitfield for each validator, referred to by their index in the validator set. */
  export const AvailabilityBitfields = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$385),
    value: _codec.$644,
  }
  /** Candidates pending availability by `ParaId`. */
  export const PendingAvailability = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$645,
  }
  /** The commitments of candidates pending availability, by `ParaId`. */
  export const PendingAvailabilityCommitments = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$390,
  }
}
export namespace ParaInherent {
  /**
   *  Whether the paras inherent was included within this block.
   *
   *  The `Option<()>` is effectively a `bool`, but it never hits storage in the `None` variant
   *  due to the guarantees of FRAME's storage APIs.
   *
   *  If this is `None` at the end of the block, we panic and render the block invalid.
   */
  export const Included = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$33,
  }
  /** Scraped on chain data for extracting resolved disputes as well as backing votes. */
  export const OnChainVotes = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$647,
  }
  /** Enter the paras inherent. This will process bitfields and backed candidates. */
  export function enter(
    value: Omit<polkadot_runtime_parachains.paras_inherent.pallet.Call.enter, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "ParaInherent", value: { ...value, type: "enter" } }
  }
}
export namespace ParaScheduler {
  /**
   *  One entry for each availability core. Entries are `None` if the core is not currently occupied. Can be
   *  temporarily `Some` if scheduled but not occupied.
   *  The i'th parachain belongs to the i'th core, with the remaining cores all being
   *  parathread-multiplexers.
   *
   *  Bounded by the maximum of either of these two values:
   *    * The number of parachains and parathread multiplexers
   *    * The number of validators divided by `configuration.max_validators_per_core`.
   */
  export const AvailabilityCores = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$659,
  }
  /**
   *  An index used to ensure that only one claim on a parathread exists in the queue or is
   *  currently being handled by an occupied core.
   *
   *  Bounded by the number of parathread cores and scheduling lookahead. Reasonably, 10 * 50 = 500.
   */
  export const ParathreadClaimIndex = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$662,
  }
  /**
   *  A queue of upcoming claims and which core they should be mapped onto.
   *
   *  The number of queued claims is bounded at the `scheduling_lookahead`
   *  multiplied by the number of parathread multiplexer cores. Reasonably, 10 * 50 = 500.
   */
  export const ParathreadQueue = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$654,
  }
  /**
   *  Currently scheduled cores - free but up to be occupied.
   *
   *  Bounded by the number of cores: one for each parachain and parathread multiplexer.
   *
   *  The value contained here will not be valid after the end of a block. Runtime APIs should be used to determine scheduled cores/
   *  for the upcoming block.
   */
  export const Scheduled = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$663,
  }
  /**
   *  The block number where the session start occurred. Used to track how many group rotations have occurred.
   *
   *  Note that in the context of parachains modules the session change is signaled during
   *  the block and enacted at the end of the block (at the finalization stage, to be exact).
   *  Thus for all intents and purposes the effect of the session change is observed at the
   *  block following the session change, block number of which we save in this storage value.
   */
  export const SessionStartBlock = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  All the validator groups. One for each core. Indices are into `ActiveValidators` - not the
   *  broader set of Polkadot validators, but instead just the subset used for parachains during
   *  this session.
   *
   *  Bound: The number of cores is the sum of the numbers of parachains and parathread multiplexers.
   *  Reasonably, 100-1000. The dominant factor is the number of validators: safe upper bound at 10k.
   */
  export const ValidatorGroups = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$653,
  }
}
export namespace ParaSessionInfo {
  /** The validator account keys of the validators actively participating in parachain consensus. */
  export const AccountKeys = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$4),
    value: _codec.$206,
  }
  /**
   *  Assignment keys for the current session.
   *  Note that this API is private due to it being prone to 'off-by-one' at session boundaries.
   *  When in doubt, use `Sessions` API instead.
   */
  export const AssignmentKeysUnsafe = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$695,
  }
  /** The earliest session for which previous session info is stored. */
  export const EarliestStoredSession = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Session information in a rolling window.
   *  Should have an entry in range `EarliestStoredSession..=CurrentSessionIndex`.
   *  Does not have any entries before the session index in the first session change notification.
   */
  export const Sessions = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$4),
    value: _codec.$696,
  }
}
export namespace Paras {
  /** The actions to perform during the start of a specific session index. */
  export const ActionsQueue = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$662,
  }
  /**
   *  Validation code stored by its hash.
   *
   *  This storage is consistent with [`FutureCodeHash`], [`CurrentCodeHash`] and
   *  [`PastCodeHash`].
   */
  export const CodeByHash = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$103),
    value: _codec.$394,
  }
  /** The number of reference on the validation code in [`CodeByHash`] storage. */
  export const CodeByHashRefs = {
    type: "Map",
    modifier: "Default",
    hashers: ["Identity"],
    key: $.tuple(_codec.$103),
    value: _codec.$4,
  }
  /**
   *  The validation code hash of every live para.
   *
   *  Corresponding code can be retrieved with [`CodeByHash`].
   */
  export const CurrentCodeHash = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$103,
  }
  /**
   *  The actual future code hash of a para.
   *
   *  Corresponding code can be retrieved with [`CodeByHash`].
   */
  export const FutureCodeHash = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$103,
  }
  /**
   *  The block number at which the planned code change is expected for a para.
   *  The change will be applied after the first parablock for this ID included which executes
   *  in the context of a relay chain block with a number >= `expected_at`.
   */
  export const FutureCodeUpgrades = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$4,
  }
  /** The head-data of every registered para. */
  export const Heads = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$104,
  }
  /** The current lifecycle of a all known Para IDs. */
  export const ParaLifecycles = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$670,
  }
  /**
   *  All parachains. Ordered ascending by `ParaId`. Parathreads are not included.
   *
   *  Consider using the [`ParachainsCache`] type of modifying.
   */
  export const Parachains = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$662,
  }
  /**
   *  Actual past code hash, indicated by the para id as well as the block number at which it
   *  became outdated.
   *
   *  Corresponding code can be retrieved with [`CodeByHash`].
   */
  export const PastCodeHash = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$671),
    value: _codec.$103,
  }
  /**
   *  Past code of parachains. The parachains themselves may not be registered anymore,
   *  but we also keep their code on-chain for the same amount of time as outdated code
   *  to keep it available for secondary checkers.
   */
  export const PastCodeMeta = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$672,
  }
  /**
   *  Which paras have past code that needs pruning and the relay-chain block at which the code was replaced.
   *  Note that this is the actual height of the included block, not the expected height at which the
   *  code upgrade would be applied, although they may be equal.
   *  This is to ensure the entire acceptance period is covered, not an offset acceptance period starting
   *  from the time at which the parachain perceives a code upgrade as having occurred.
   *  Multiple entries for a single para are permitted. Ordered ascending by block number.
   */
  export const PastCodePruning = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$675,
  }
  /** The list of all currently active PVF votes. Auxiliary to `PvfActiveVoteMap`. */
  export const PvfActiveVoteList = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$669,
  }
  /**
   *  All currently active PVF pre-checking votes.
   *
   *  Invariant:
   *  - There are no PVF pre-checking votes that exists in list but not in the set and vice versa.
   */
  export const PvfActiveVoteMap = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$103),
    value: _codec.$666,
  }
  /**
   *  Upcoming paras instantiation arguments.
   *
   *  NOTE that after PVF pre-checking is enabled the para genesis arg will have it's code set
   *  to empty. Instead, the code will be saved into the storage right away via `CodeByHash`.
   */
  export const UpcomingParasGenesis = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$678,
  }
  /**
   *  The list of upcoming code upgrades. Each item is a pair of which para performs a code
   *  upgrade and at which relay-chain block it is expected at.
   *
   *  Ordered ascending by block number.
   */
  export const UpcomingUpgrades = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$675,
  }
  /**
   *  The list of parachains that are awaiting for their upgrade restriction to cooldown.
   *
   *  Ordered ascending by block number.
   */
  export const UpgradeCooldowns = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$675,
  }
  /**
   *  This is used by the relay-chain to communicate to a parachain a go-ahead with in the upgrade procedure.
   *
   *  This value is absent when there are no upgrades scheduled or during the time the relay chain
   *  performs the checks. It is set at the first relay-chain block when the corresponding parachain
   *  can switch its upgrade function. As soon as the parachain's block is included, the value
   *  gets reset to `None`.
   *
   *  NOTE that this field is used by parachains via merkle storage proofs, therefore changing
   *  the format will require migration of parachains.
   */
  export const UpgradeGoAheadSignal = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$676,
  }
  /**
   *  This is used by the relay-chain to communicate that there are restrictions for performing
   *  an upgrade for this parachain.
   *
   *  This may be a because the parachain waits for the upgrade cooldown to expire. Another
   *  potential use case is when we want to perform some maintenance (such as storage migration)
   *  we could restrict upgrades to make the process simpler.
   *
   *  NOTE that this field is used by parachains via merkle storage proofs, therefore changing
   *  the format will require migration of parachains.
   */
  export const UpgradeRestrictionSignal = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$677,
  }
  /**
   * Adds the validation code to the storage.
   *
   * The code will not be added if it is already present. Additionally, if PVF pre-checking
   * is running for that code, it will be instantly accepted.
   *
   * Otherwise, the code will be added into the storage. Note that the code will be added
   * into storage with reference count 0. This is to account the fact that there are no users
   * for this code yet. The caller will have to make sure that this code eventually gets
   * used by some parachain or removed from the storage to avoid storage leaks. For the latter
   * prefer to use the `poke_unused_validation_code` dispatchable to raw storage manipulation.
   *
   * This function is mainly meant to be used for upgrading parachains that do not follow
   * the go-ahead signal while the PVF pre-checking feature is enabled.
   */
  export function add_trusted_validation_code(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.add_trusted_validation_code, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "add_trusted_validation_code" } }
  }
  /** Note a new block head for para within the context of the current block. */
  export function force_note_new_head(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_note_new_head, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "force_note_new_head" } }
  }
  /**
   * Put a parachain directly into the next session's action queue.
   * We can't queue it any sooner than this without going into the
   * initializer...
   */
  export function force_queue_action(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_queue_action, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "force_queue_action" } }
  }
  /** Schedule an upgrade as if it was scheduled in the given relay parent block. */
  export function force_schedule_code_upgrade(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_schedule_code_upgrade, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "force_schedule_code_upgrade" } }
  }
  /** Set the storage for the parachain validation code immediately. */
  export function force_set_current_code(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_set_current_code, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "force_set_current_code" } }
  }
  /** Set the storage for the current parachain head data immediately. */
  export function force_set_current_head(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_set_current_head, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "force_set_current_head" } }
  }
  /**
   * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
   * enacts the results if that was the last vote before achieving the supermajority.
   */
  export function include_pvf_check_statement(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.include_pvf_check_statement, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "include_pvf_check_statement" } }
  }
  /**
   * Remove the validation code from the storage iff the reference count is 0.
   *
   * This is better than removing the storage directly, because it will not remove the code
   * that was suddenly got used by some parachain while this dispatchable was pending
   * dispatching.
   */
  export function poke_unused_validation_code(
    value: Omit<polkadot_runtime_parachains.paras.pallet.Call.poke_unused_validation_code, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Paras", value: { ...value, type: "poke_unused_validation_code" } }
  }
}
export namespace ParasDisputes {
  /** All ongoing or concluded disputes for the last several sessions. */
  export const Disputes = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Blake2_128Concat"],
    key: _codec.$698,
    value: _codec.$699,
  }
  /**
   *  Whether the chain is frozen. Starts as `None`. When this is `Some`,
   *  the chain will not accept any new parachain blocks for backing or inclusion,
   *  and its value indicates the last valid block number in the chain.
   *  It can only be set back to `None` by governance intervention.
   */
  export const Frozen = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$236,
  }
  /**
   *  All included blocks on the chain, as well as the block number in this chain that
   *  should be reverted back to if the candidate is disputed and determined to be invalid.
   */
  export const Included = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Blake2_128Concat"],
    key: _codec.$698,
    value: _codec.$4,
  }
  /**
   *  The last pruned session, if any. All data stored by this module
   *  references sessions.
   */
  export const LastPrunedSession = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Maps session indices to a vector indicating the number of potentially-spam disputes
   *  each validator is participating in. Potentially-spam disputes are remote disputes which have
   *  fewer than `byzantine_threshold + 1` validators.
   *
   *  The i'th entry of the vector corresponds to the i'th validator in the session.
   */
  export const SpamSlots = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$94,
  }
  export function force_unfreeze(): polkadot_runtime.RuntimeCall {
    return { type: "ParasDisputes", value: "force_unfreeze" }
  }
}
export namespace ParasShared {
  /**
   *  All the validators actively participating in parachain consensus.
   *  Indices are into the broader validator set.
   */
  export const ActiveValidatorIndices = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$642,
  }
  /**
   *  The parachain attestation keys of the validators actively participating in parachain consensus.
   *  This should be the same length as `ActiveValidatorIndices`.
   */
  export const ActiveValidatorKeys = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$643,
  }
  /** The current session index. */
  export const CurrentSessionIndex = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
}
export namespace PhragmenElection {
  /**
   *  The present candidate list. A current member or runner-up can never enter this vector
   *  and is always implicitly assumed to be a candidate.
   *
   *  Second element is the deposit.
   *
   *  Invariant: Always sorted based on account id.
   */
  export const Candidates = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$68,
  }
  /** The total number of vote rounds that have happened, excluding the upcoming one. */
  export const ElectionRounds = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  The current elected members.
   *
   *  Invariant: Always sorted based on account id.
   */
  export const Members = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$550,
  }
  /**
   *  The current reserved runners-up.
   *
   *  Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the
   *  last (i.e. _best_) runner-up will be replaced.
   */
  export const RunnersUp = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$550,
  }
  /**
   *  Votes and locked stake of a particular voter.
   *
   *  TWOX-NOTE: SAFE as `AccountId` is a crypto hash.
   */
  export const Voting = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$552,
  }
  /**
   * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
   * deposit of the removed voters are returned.
   *
   * This is an root function to be used only for cleaning the state.
   *
   * The dispatch origin of this call must be root.
   *
   * # <weight>
   * The total number of voters and those that are defunct must be provided as witness data.
   * # </weight>
   */
  export function clean_defunct_voters(
    value: Omit<pallet_elections_phragmen.pallet.Call.clean_defunct_voters, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "PhragmenElection", value: { ...value, type: "clean_defunct_voters" } }
  }
  /**
   * Remove a particular member from the set. This is effective immediately and the bond of
   * the outgoing member is slashed.
   *
   * If a runner-up is available, then the best runner-up will be removed and replaces the
   * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
   * started, else, nothing happens.
   *
   * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
   * it is returned.
   *
   * The dispatch origin of this call must be root.
   *
   * Note that this does not affect the designated block number of the next election.
   *
   * # <weight>
   * If we have a replacement, we use a small weight. Else, since this is a root call and
   * will go into phragmen, we assume full block for now.
   * # </weight>
   */
  export function remove_member(
    value: Omit<pallet_elections_phragmen.pallet.Call.remove_member, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "PhragmenElection", value: { ...value, type: "remove_member" } }
  }
  /**
   * Remove `origin` as a voter.
   *
   * This removes the lock and returns the deposit.
   *
   * The dispatch origin of this call must be signed and be a voter.
   */
  export function remove_voter(): polkadot_runtime.RuntimeCall {
    return { type: "PhragmenElection", value: { type: "remove_voter" } }
  }
  /**
   * Renounce one's intention to be a candidate for the next election round. 3 potential
   * outcomes exist:
   *
   * - `origin` is a candidate and not elected in any set. In this case, the deposit is
   *   unreserved, returned and origin is removed as a candidate.
   * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
   *   origin is removed as a runner-up.
   * - `origin` is a current member. In this case, the deposit is unreserved and origin is
   *   removed as a member, consequently not being a candidate for the next round anymore.
   *   Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
   *   are immediately used. If the prime is renouncing, then no prime will exist until the
   *   next round.
   *
   * The dispatch origin of this call must be signed, and have one of the above roles.
   *
   * # <weight>
   * The type of renouncing must be provided as witness data.
   * # </weight>
   */
  export function renounce_candidacy(
    value: Omit<pallet_elections_phragmen.pallet.Call.renounce_candidacy, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "PhragmenElection", value: { ...value, type: "renounce_candidacy" } }
  }
  /**
   * Submit oneself for candidacy. A fixed amount of deposit is recorded.
   *
   * All candidates are wiped at the end of the term. They either become a member/runner-up,
   * or leave the system while their deposit is slashed.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
   * to get their deposit back. Losing the spot in an election will always lead to a slash.
   *
   * # <weight>
   * The number of current candidates must be provided as witness data.
   * # </weight>
   */
  export function submit_candidacy(
    value: Omit<pallet_elections_phragmen.pallet.Call.submit_candidacy, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "PhragmenElection", value: { ...value, type: "submit_candidacy" } }
  }
  /**
   * Vote for a set of candidates for the upcoming round of election. This can be called to
   * set the initial votes, or update already existing votes.
   *
   * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
   * reserved. The deposit is based on the number of votes and can be updated over time.
   *
   * The `votes` should:
   *   - not be empty.
   *   - be less than the number of possible candidates. Note that all current members and
   *     runners-up are also automatically candidates for the next round.
   *
   * If `value` is more than `who`'s free balance, then the maximum of the two is used.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * It is the responsibility of the caller to **NOT** place all of their balance into the
   * lock and keep some for further operations.
   *
   * # <weight>
   * We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
   * # </weight>
   */
  export function vote(
    value: Omit<pallet_elections_phragmen.pallet.Call.vote, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "PhragmenElection", value: { ...value, type: "vote" } }
  }
}
export namespace Preimage {
  export const PreimageFor = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$453),
    value: _codec.$454,
  }
  /** The request status of a given hash. */
  export const StatusFor = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$451,
  }
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   */
  export function note_preimage(
    value: Omit<pallet_preimage.pallet.Call.note_preimage, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Preimage", value: { ...value, type: "note_preimage" } }
  }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   */
  export function request_preimage(
    value: Omit<pallet_preimage.pallet.Call.request_preimage, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Preimage", value: { ...value, type: "request_preimage" } }
  }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   */
  export function unnote_preimage(
    value: Omit<pallet_preimage.pallet.Call.unnote_preimage, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Preimage", value: { ...value, type: "unnote_preimage" } }
  }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   */
  export function unrequest_preimage(
    value: Omit<pallet_preimage.pallet.Call.unrequest_preimage, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Preimage", value: { ...value, type: "unrequest_preimage" } }
  }
}
export namespace Proxy {
  /** The announcements made by the proxy (key). */
  export const Announcements = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$583,
  }
  /**
   *  The set of account proxies. Maps the account which has delegated to the accounts
   *  which are being delegated to, together with the amount held on deposit.
   */
  export const Proxies = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$579,
  }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   */
  export function add_proxy(
    value: Omit<pallet_proxy.pallet.Call.add_proxy, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "add_proxy" } }
  }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   */
  export function announce(
    value: Omit<pallet_proxy.pallet.Call.announce, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "announce" } }
  }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   */
  export function create_pure(
    value: Omit<pallet_proxy.pallet.Call.create_pure, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "create_pure" } }
  }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   */
  export function kill_pure(
    value: Omit<pallet_proxy.pallet.Call.kill_pure, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "kill_pure" } }
  }
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   */
  export function proxy(
    value: Omit<pallet_proxy.pallet.Call.proxy, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "proxy" } }
  }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   */
  export function proxy_announced(
    value: Omit<pallet_proxy.pallet.Call.proxy_announced, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "proxy_announced" } }
  }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   */
  export function reject_announcement(
    value: Omit<pallet_proxy.pallet.Call.reject_announcement, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "reject_announcement" } }
  }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   */
  export function remove_announcement(
    value: Omit<pallet_proxy.pallet.Call.remove_announcement, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "remove_announcement" } }
  }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   */
  export function remove_proxies(): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { type: "remove_proxies" } }
  }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   */
  export function remove_proxy(
    value: Omit<pallet_proxy.pallet.Call.remove_proxy, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Proxy", value: { ...value, type: "remove_proxy" } }
  }
}
export namespace Registrar {
  /** The next free `ParaId`. */
  export const NextFreeParaId = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$98,
  }
  /**
   *  Amount held on deposit for each para and the original depositor.
   *
   *  The given account ID is responsible for registering the code and initial head data, but may only do
   *  so if it isn't yet registered. (After that, it's up to governance to do so.)
   */
  export const Paras = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$701,
  }
  /** Pending swap operations. */
  export const PendingSwap = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$98,
  }
  /**
   * Add a manager lock from a para. This will prevent the manager of a
   * para to deregister or swap a para.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
   */
  export function add_lock(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.add_lock, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "add_lock" } }
  }
  /**
   * Deregister a Para Id, freeing all data and returning any deposit.
   *
   * The caller must be Root, the `para` owner, or the `para` itself. The para must be a parathread.
   */
  export function deregister(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.deregister, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "deregister" } }
  }
  /**
   * Force the registration of a Para Id on the relay chain.
   *
   * This function must be called by a Root origin.
   *
   * The deposit taken can be specified for this registration. Any `ParaId`
   * can be registered, including sub-1000 IDs which are System Parachains.
   */
  export function force_register(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.force_register, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "force_register" } }
  }
  /**
   * Register head data and validation code for a reserved Para Id.
   *
   * ## Arguments
   * - `origin`: Must be called by a `Signed` origin.
   * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
   * - `genesis_head`: The genesis head data of the parachain/thread.
   * - `validation_code`: The initial validation code of the parachain/thread.
   *
   * ## Deposits/Fees
   * The origin signed account must reserve a corresponding deposit for the registration. Anything already
   * reserved previously for this para ID is accounted for.
   *
   * ## Events
   * The `Registered` event is emitted in case of success.
   */
  export function register(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.register, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "register" } }
  }
  /**
   * Remove a manager lock from a para. This will allow the manager of a
   * previously locked para to deregister or swap a para without using governance.
   *
   * Can only be called by the Root origin or the parachain.
   */
  export function remove_lock(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.remove_lock, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "remove_lock" } }
  }
  /**
   * Reserve a Para Id on the relay chain.
   *
   * This function will reserve a new Para Id to be owned/managed by the origin account.
   * The origin account is able to register head data and validation code using `register` to create
   * a parathread. Using the Slots pallet, a parathread can then be upgraded to get a parachain slot.
   *
   * ## Arguments
   * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new para ID.
   *
   * ## Deposits/Fees
   * The origin must reserve a deposit of `ParaDeposit` for the registration.
   *
   * ## Events
   * The `Reserved` event is emitted in case of success, which provides the ID reserved for use.
   */
  export function reserve(): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { type: "reserve" } }
  }
  /**
   * Schedule a parachain upgrade.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
   */
  export function schedule_code_upgrade(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.schedule_code_upgrade, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "schedule_code_upgrade" } }
  }
  /**
   * Set the parachain's current head.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
   */
  export function set_current_head(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.set_current_head, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "set_current_head" } }
  }
  /**
   * Swap a parachain with another parachain or parathread.
   *
   * The origin must be Root, the `para` owner, or the `para` itself.
   *
   * The swap will happen only if there is already an opposite swap pending. If there is not,
   * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
   *
   * The `ParaId`s remain mapped to the same head data and code so external code can rely on
   * `ParaId` to be a long-term identifier of a notional "parachain". However, their
   * scheduling info (i.e. whether they're a parathread or parachain), auction information
   * and the auction deposit are switched.
   */
  export function swap(
    value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.swap, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Registrar", value: { ...value, type: "swap" } }
  }
}
export namespace Scheduler {
  /** Items to be executed, indexed by the block number that they should be executed on. */
  export const Agenda = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$177,
  }
  export const IncompleteSince = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Lookup from a name to the block number and index of the task.
   *
   *  For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
   *  identities.
   */
  export const Lookup = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$1),
    value: _codec.$30,
  }
  /** Cancel an anonymously scheduled task. */
  export function cancel(
    value: Omit<pallet_scheduler.pallet.Call.cancel, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Scheduler", value: { ...value, type: "cancel" } }
  }
  /** Cancel a named scheduled task. */
  export function cancel_named(
    value: Omit<pallet_scheduler.pallet.Call.cancel_named, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Scheduler", value: { ...value, type: "cancel_named" } }
  }
  /** Anonymously schedule a task. */
  export function schedule(
    value: Omit<pallet_scheduler.pallet.Call.schedule, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Scheduler", value: { ...value, type: "schedule" } }
  }
  /**
   * Anonymously schedule a task after a delay.
   *
   * # <weight>
   * Same as [`schedule`].
   * # </weight>
   */
  export function schedule_after(
    value: Omit<pallet_scheduler.pallet.Call.schedule_after, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Scheduler", value: { ...value, type: "schedule_after" } }
  }
  /** Schedule a named task. */
  export function schedule_named(
    value: Omit<pallet_scheduler.pallet.Call.schedule_named, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Scheduler", value: { ...value, type: "schedule_named" } }
  }
  /**
   * Schedule a named task after a delay.
   *
   * # <weight>
   * Same as [`schedule_named`](Self::schedule_named).
   * # </weight>
   */
  export function schedule_named_after(
    value: Omit<pallet_scheduler.pallet.Call.schedule_named_after, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Scheduler", value: { ...value, type: "schedule_named_after" } }
  }
}
export namespace Session {
  /** Current index of the session. */
  export const CurrentIndex = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Indices of disabled validators.
   *
   *  The vec is always kept sorted so that we can find whether a given validator is
   *  disabled using binary search. It gets cleared when `on_session_ending` returns
   *  a new set of identities.
   */
  export const DisabledValidators = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$94,
  }
  /** The owner of a key. The key is the `KeyTypeId` + the encoded key. */
  export const KeyOwner = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$513),
    value: _codec.$0,
  }
  /** The next session keys for a validator. */
  export const NextKeys = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$212,
  }
  /**
   *  True if the underlying economic identities or weighting behind the validators
   *  has changed in the queued validator set.
   */
  export const QueuedChanged = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$43,
  }
  /**
   *  The queued keys for the next session. When the next session begins, these keys
   *  will be used to determine the validator's session keys.
   */
  export const QueuedKeys = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$511,
  }
  /** The current set of validators. */
  export const Validators = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$206,
  }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * # <weight>
   * - Complexity: `O(1)` in number of key types. Actual cost depends on the number of length
   *   of `T::Keys::key_ids()` which is fixed.
   * - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`
   * - DbWrites: `NextKeys`, `origin account`
   * - DbWrites per key id: `KeyOwner`
   * # </weight>
   */
  export function purge_keys(): polkadot_runtime.RuntimeCall {
    return { type: "Session", value: { type: "purge_keys" } }
  }
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * # <weight>
   * - Complexity: `O(1)`. Actual cost depends on the number of length of
   *   `T::Keys::key_ids()` which is fixed.
   * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
   * - DbWrites: `origin account`, `NextKeys`
   * - DbReads per key id: `KeyOwner`
   * - DbWrites per key id: `KeyOwner`
   * # </weight>
   */
  export function set_keys(
    value: Omit<pallet_session.pallet.Call.set_keys, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Session", value: { ...value, type: "set_keys" } }
  }
}
export namespace Slots {
  /**
   *  Amounts held on deposit for each (possibly future) leased parachain.
   *
   *  The actual amount locked on its behalf by any account at any time is the maximum of the second values
   *  of the items in this list whose first value is the account.
   *
   *  The first item in the list is the amount locked for the current Lease Period. Following
   *  items are for the subsequent lease periods.
   *
   *  The default value (an empty list) implies that the parachain no longer exists (or never
   *  existed) as far as this pallet is concerned.
   *
   *  If a parachain doesn't exist *yet* but is scheduled to exist in the future, then it
   *  will be left-padded with one or more `None`s to denote the fact that nothing is held on
   *  deposit for the non-existent chain currently, but is held at some point in the future.
   *
   *  It is illegal for a `None` value to trail in the list.
   */
  export const Leases = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$703,
  }
  /**
   * Clear all leases for a Para Id, refunding any deposits back to the original owners.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   */
  export function clear_all_leases(
    value: Omit<polkadot_runtime_common.slots.pallet.Call.clear_all_leases, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Slots", value: { ...value, type: "clear_all_leases" } }
  }
  /**
   * Just a connect into the `lease_out` call, in case Root wants to force some lease to happen
   * independently of any other on-chain mechanism to use it.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   */
  export function force_lease(
    value: Omit<polkadot_runtime_common.slots.pallet.Call.force_lease, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Slots", value: { ...value, type: "force_lease" } }
  }
  /**
   * Try to onboard a parachain that has a lease for the current lease period.
   *
   * This function can be useful if there was some state issue with a para that should
   * have onboarded, but was unable to. As long as they have a lease period, we can
   * let them onboard from here.
   *
   * Origin must be signed, but can be called by anyone.
   */
  export function trigger_onboard(
    value: Omit<polkadot_runtime_common.slots.pallet.Call.trigger_onboard, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Slots", value: { ...value, type: "trigger_onboard" } }
  }
}
export namespace Staking {
  /**
   *  The active era information, it holds index and start.
   *
   *  The active era is the era being currently rewarded. Validator set of this era must be
   *  equal to [`SessionInterface::validators`].
   */
  export const ActiveEra = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$492,
  }
  /** Map from all locked "stash" accounts to the controller account. */
  export const Bonded = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$0,
  }
  /**
   *  A mapping from still-bonded eras to the first session index of that era.
   *
   *  Must contains information for eras for the range:
   *  `[active_era - bounding_duration; active_era]`
   */
  export const BondedEras = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$158,
  }
  /**
   *  The amount of currency given to reporters of a slash event which was
   *  canceled by extraordinary circumstances (e.g. governance).
   */
  export const CanceledSlashPayout = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$6,
  }
  /**
   *  The threshold for when users can start calling `chill_other` for other validators /
   *  nominators. The threshold is compared to the actual number of validators / nominators
   *  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
   */
  export const ChillThreshold = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$205,
  }
  /** Counter for the related counted storage map */
  export const CounterForNominators = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Counter for the related counted storage map */
  export const CounterForValidators = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  The current era index.
   *
   *  This is the latest planned era, depending on how the Session pallet queues the validator
   *  set, it might be active or not.
   */
  export const CurrentEra = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  The last planned session scheduled by the session pallet.
   *
   *  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
   */
  export const CurrentPlannedSession = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Rewards for the last `HISTORY_DEPTH` eras.
   *  If reward hasn't been set or has been removed then 0 reward is returned.
   */
  export const ErasRewardPoints = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$495,
  }
  /**
   *  Exposure of validator at era.
   *
   *  This is keyed first by the era index to allow bulk deletion and then the stash account.
   *
   *  Is it removed after `HISTORY_DEPTH` eras.
   *  If stakers hasn't been set or has been removed then empty exposure is returned.
   */
  export const ErasStakers = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$494,
    value: _codec.$57,
  }
  /**
   *  Clipped Exposure of validator at era.
   *
   *  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
   *  `T::MaxNominatorRewardedPerValidator` biggest stakers.
   *  (Note: the field `total` and `own` of the exposure remains unchanged).
   *  This is used to limit the i/o cost for the nominator payout.
   *
   *  This is keyed fist by the era index to allow bulk deletion and then the stash account.
   *
   *  Is it removed after `HISTORY_DEPTH` eras.
   *  If stakers hasn't been set or has been removed then empty exposure is returned.
   */
  export const ErasStakersClipped = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$494,
    value: _codec.$57,
  }
  /**
   *  The session index at which the era start for the last `HISTORY_DEPTH` eras.
   *
   *  Note: This tracks the starting session (i.e. session index when era start being active)
   *  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
   */
  export const ErasStartSessionIndex = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$4,
  }
  /**
   *  The total amount staked for the last `HISTORY_DEPTH` eras.
   *  If total hasn't been set or has been removed then 0 stake is returned.
   */
  export const ErasTotalStake = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$6,
  }
  /**
   *  Similar to `ErasStakers`, this holds the preferences of validators.
   *
   *  This is keyed first by the era index to allow bulk deletion and then the stash account.
   *
   *  Is it removed after `HISTORY_DEPTH` eras.
   */
  export const ErasValidatorPrefs = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$494,
    value: _codec.$40,
  }
  /**
   *  The total validator era payout for the last `HISTORY_DEPTH` eras.
   *
   *  Eras that haven't finished yet or has been removed doesn't have reward.
   */
  export const ErasValidatorReward = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$6,
  }
  /** Mode of era forcing. */
  export const ForceEra = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$499,
  }
  /**
   *  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
   *  easy to initialize and the performance hit is minimal (we expect no more than four
   *  invulnerables) and restricted to testnets.
   */
  export const Invulnerables = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$206,
  }
  /** Map from all (unlocked) "controller" accounts to the info regarding the staking. */
  export const Ledger = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$485,
  }
  /**
   *  The maximum nominator count before we stop allowing new validators to join.
   *
   *  When this value is not set, no limits are enforced.
   */
  export const MaxNominatorsCount = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  The maximum validator count before we stop allowing new validators to join.
   *
   *  When this value is not set, no limits are enforced.
   */
  export const MaxValidatorsCount = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  The minimum amount of commission that validators can set.
   *
   *  If set to `0`, no limit exists.
   */
  export const MinCommission = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$42,
  }
  /** The minimum active bond to become and maintain the role of a nominator. */
  export const MinNominatorBond = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$6,
  }
  /** The minimum active bond to become and maintain the role of a validator. */
  export const MinValidatorBond = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$6,
  }
  /** Minimum number of staking participants before emergency conditions are imposed. */
  export const MinimumValidatorCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** All slashing events on nominators, mapped by era to the highest slash value of the era. */
  export const NominatorSlashInEra = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$494,
    value: _codec.$6,
  }
  /**
   *  The map from nominator stash key to their nomination preferences, namely the validators that
   *  they wish to support.
   *
   *  Note that the keys of this storage map might become non-decodable in case the
   *  [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
   *  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
   *  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
   *  nominators will effectively not-exist, until they re-submit their preferences such that it
   *  is within the bounds of the newly set `Config::MaxNominations`.
   *
   *  This implies that `::iter_keys().count()` and `::iter().count()` might return different
   *  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
   *  number of keys that exist.
   *
   *  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
   *  [`Call::chill_other`] dispatchable by anyone.
   */
  export const Nominators = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$490,
  }
  /**
   *  Indices of validators that have offended in the active era and whether they are currently
   *  disabled.
   *
   *  This value should be a superset of disabled validators since not all offences lead to the
   *  validator being disabled (if there was no slash). This is needed to track the percentage of
   *  validators that have offended in the current era, ensuring a new era is forced if
   *  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
   *  whether a given validator has previously offended using binary search. It gets cleared when
   *  the era ends.
   */
  export const OffendingValidators = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$505,
  }
  /** Where the reward payment should be made. Keyed by stash. */
  export const Payee = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$203,
  }
  /**
   *  The percentage of the slash that is distributed to reporters.
   *
   *  The rest of the slashed value is handled by the `Slash`.
   */
  export const SlashRewardFraction = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$42,
  }
  /** Slashing spans for stash accounts. */
  export const SlashingSpans = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$503,
  }
  /**
   *  Records information about the maximum slash of a stash within a slashing span,
   *  as well as how much reward has been paid out.
   */
  export const SpanSlash = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$498),
    value: _codec.$504,
  }
  /**
   *  True if network has been upgraded to this version.
   *  Storage version of the pallet.
   *
   *  This is set to v7.0.0 for new networks.
   */
  export const StorageVersion = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$507,
  }
  /** All unapplied slashes that are queued for later. */
  export const UnappliedSlashes = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$500,
  }
  /** The ideal number of staking participants. */
  export const ValidatorCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  All slashing events on validators, mapped by era to the highest slash proportion
   *  and slash value of the era.
   */
  export const ValidatorSlashInEra = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Twox64Concat"],
    key: _codec.$494,
    value: _codec.$502,
  }
  /** The map from (wannabe) validator stash key to the preferences of that validator. */
  export const Validators = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$40,
  }
  /**
   * Take the origin account as a stash and lock up `value` of its balance. `controller` will
   * be the account that controls it.
   *
   * `value` must be more than the `minimum_balance` specified by `T::Currency`.
   *
   * The dispatch origin for this call must be _Signed_ by the stash account.
   *
   * Emits `Bonded`.
   * # <weight>
   * - Independent of the arguments. Moderate complexity.
   * - O(1).
   * - Three extra DB entries.
   *
   * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
   * unless the `origin` falls below _existential deposit_ and gets removed as dust.
   * ------------------
   * # </weight>
   */
  export function bond(
    value: Omit<pallet_staking.pallet.pallet.Call.bond, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "bond" } }
  }
  /**
   * Add some extra amount that have appeared in the stash `free_balance` into the balance up
   * for staking.
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * Use this if there are additional funds in your stash account that you wish to bond.
   * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
   * any limitation on the amount that can be added.
   *
   * Emits `Bonded`.
   *
   * # <weight>
   * - Independent of the arguments. Insignificant complexity.
   * - O(1).
   * # </weight>
   */
  export function bond_extra(
    value: Omit<pallet_staking.pallet.pallet.Call.bond_extra, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "bond_extra" } }
  }
  /**
   * Cancel enactment of a deferred slash.
   *
   * Can be called by the `T::SlashCancelOrigin`.
   *
   * Parameters: era and indices of the slashes for that era to kill.
   */
  export function cancel_deferred_slash(
    value: Omit<pallet_staking.pallet.pallet.Call.cancel_deferred_slash, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "cancel_deferred_slash" } }
  }
  /**
   * Declare no desire to either validate or nominate.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * # <weight>
   * - Independent of the arguments. Insignificant complexity.
   * - Contains one read.
   * - Writes are limited to the `origin` account key.
   * # </weight>
   */
  export function chill(): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { type: "chill" } }
  }
  /**
   * Declare a `controller` to stop participating as either a validator or nominator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_, but can be called by anyone.
   *
   * If the caller is the same as the controller being targeted, then no further checks are
   * enforced, and this function behaves just like `chill`.
   *
   * If the caller is different than the controller being targeted, the following conditions
   * must be met:
   *
   * * `controller` must belong to a nominator who has become non-decodable,
   *
   * Or:
   *
   * * A `ChillThreshold` must be set and checked which defines how close to the max
   *   nominators or validators we must reach before users can start chilling one-another.
   * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
   *   how close we are to the threshold.
   * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
   *   if this is a person that should be chilled because they have not met the threshold
   *   bond required.
   *
   * This can be helpful if bond requirements are updated, and we need to remove old users
   * who do not satisfy these requirements.
   */
  export function chill_other(
    value: Omit<pallet_staking.pallet.pallet.Call.chill_other, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "chill_other" } }
  }
  /**
   * Force a validator to have at least the minimum commission. This will not affect a
   * validator who already has a commission greater than or equal to the minimum. Any account
   * can call this.
   */
  export function force_apply_min_commission(
    value: Omit<pallet_staking.pallet.pallet.Call.force_apply_min_commission, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "force_apply_min_commission" } }
  }
  /**
   * Force there to be a new era at the end of the next session. After this, it will be
   * reset to normal (non-forced) behaviour.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   *
   * # <weight>
   * - No arguments.
   * - Weight: O(1)
   * - Write ForceEra
   * # </weight>
   */
  export function force_new_era(): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { type: "force_new_era" } }
  }
  /**
   * Force there to be a new era at the end of sessions indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   */
  export function force_new_era_always(): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { type: "force_new_era_always" } }
  }
  /**
   * Force there to be no new eras indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * Thus the election process may be ongoing when this is called. In this case the
   * election will continue until the next era is triggered.
   *
   * # <weight>
   * - No arguments.
   * - Weight: O(1)
   * - Write: ForceEra
   * # </weight>
   */
  export function force_no_eras(): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { type: "force_no_eras" } }
  }
  /**
   * Force a current staker to become completely unstaked, immediately.
   *
   * The dispatch origin must be Root.
   */
  export function force_unstake(
    value: Omit<pallet_staking.pallet.pallet.Call.force_unstake, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "force_unstake" } }
  }
  /**
   * Increments the ideal number of validators.
   *
   * The dispatch origin must be Root.
   *
   * # <weight>
   * Same as [`Self::set_validator_count`].
   * # </weight>
   */
  export function increase_validator_count(
    value: Omit<pallet_staking.pallet.pallet.Call.increase_validator_count, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "increase_validator_count" } }
  }
  /**
   * Remove the given nominations from the calling validator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * - `who`: A list of nominator stash accounts who are nominating this validator which
   *   should no longer be nominating this validator.
   *
   * Note: Making this call only makes sense if you first set the validator preferences to
   * block any further nominations.
   */
  export function kick(
    value: Omit<pallet_staking.pallet.pallet.Call.kick, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "kick" } }
  }
  /**
   * Declare the desire to nominate `targets` for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * # <weight>
   * - The transaction's complexity is proportional to the size of `targets` (N)
   * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
   * - Both the reads and writes follow a similar pattern.
   * # </weight>
   */
  export function nominate(
    value: Omit<pallet_staking.pallet.pallet.Call.nominate, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "nominate" } }
  }
  /**
   * Pay out all the stakers behind a single validator for a single era.
   *
   * - `validator_stash` is the stash account of the validator. Their nominators, up to
   *   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * # <weight>
   * - Time complexity: at most O(MaxNominatorRewardedPerValidator).
   * - Contains a limited number of reads and writes.
   * -----------
   * N is the Number of payouts for the validator (including the validator)
   * Weight:
   * - Reward Destination Staked: O(N)
   * - Reward Destination Controller (Creating): O(N)
   *
   *   NOTE: weights are assuming that payouts are made to alive stash account (Staked).
   *   Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.
   * # </weight>
   */
  export function payout_stakers(
    value: Omit<pallet_staking.pallet.pallet.Call.payout_stakers, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "payout_stakers" } }
  }
  /**
   * Remove all data structures concerning a staker/stash once it is at a state where it can
   * be considered `dust` in the staking system. The requirements are:
   *
   * 1. the `total_balance` of the stash is below existential deposit.
   * 2. or, the `ledger.total` of the stash is below existential deposit.
   *
   * The former can happen in cases like a slash; the latter when a fully unbonded account
   * is still receiving staking rewards in `RewardDestination::Staked`.
   *
   * It can be called by anyone, as long as `stash` meets the above requirements.
   *
   * Refunds the transaction fees upon successful execution.
   */
  export function reap_stash(
    value: Omit<pallet_staking.pallet.pallet.Call.reap_stash, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "reap_stash" } }
  }
  /**
   * Rebond a portion of the stash scheduled to be unlocked.
   *
   * The dispatch origin must be signed by the controller.
   *
   * # <weight>
   * - Time complexity: O(L), where L is unlocking chunks
   * - Bounded by `MaxUnlockingChunks`.
   * - Storage changes: Can't increase storage, only decrease it.
   * # </weight>
   */
  export function rebond(
    value: Omit<pallet_staking.pallet.pallet.Call.rebond, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "rebond" } }
  }
  /**
   * Scale up the ideal number of validators by a factor.
   *
   * The dispatch origin must be Root.
   *
   * # <weight>
   * Same as [`Self::set_validator_count`].
   * # </weight>
   */
  export function scale_validator_count(
    value: Omit<pallet_staking.pallet.pallet.Call.scale_validator_count, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "scale_validator_count" } }
  }
  /**
   * (Re-)set the controller of a stash.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * # <weight>
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   * ----------
   * Weight: O(1)
   * DB Weight:
   * - Read: Bonded, Ledger New Controller, Ledger Old Controller
   * - Write: Bonded, Ledger New Controller, Ledger Old Controller
   * # </weight>
   */
  export function set_controller(
    value: Omit<pallet_staking.pallet.pallet.Call.set_controller, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "set_controller" } }
  }
  /**
   * Set the validators who cannot be slashed (if any).
   *
   * The dispatch origin must be Root.
   */
  export function set_invulnerables(
    value: Omit<pallet_staking.pallet.pallet.Call.set_invulnerables, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "set_invulnerables" } }
  }
  /**
   * (Re-)set the payment target for a controller.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * # <weight>
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   * ---------
   * - Weight: O(1)
   * - DB Weight:
   *     - Read: Ledger
   *     - Write: Payee
   * # </weight>
   */
  export function set_payee(
    value: Omit<pallet_staking.pallet.pallet.Call.set_payee, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "set_payee" } }
  }
  /**
   * Update the various staking configurations .
   *
   * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
   * * `min_validator_bond`: The minimum active bond needed to be a validator.
   * * `max_nominator_count`: The max number of users who can be a nominator at once. When
   *   set to `None`, no limit is enforced.
   * * `max_validator_count`: The max number of users who can be a validator at once. When
   *   set to `None`, no limit is enforced.
   * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
   *   should be filled in order for the `chill_other` transaction to work.
   * * `min_commission`: The minimum amount of commission that each validators must maintain.
   *   This is checked only upon calling `validate`. Existing validators are not affected.
   *
   * RuntimeOrigin must be Root to call this function.
   *
   * NOTE: Existing nominators and validators will not be affected by this update.
   * to kick people under the new limits, `chill_other` should be called.
   */
  export function set_staking_configs(
    value: Omit<pallet_staking.pallet.pallet.Call.set_staking_configs, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "set_staking_configs" } }
  }
  /**
   * Sets the ideal number of validators.
   *
   * The dispatch origin must be Root.
   *
   * # <weight>
   * Weight: O(1)
   * Write: Validator Count
   * # </weight>
   */
  export function set_validator_count(
    value: Omit<pallet_staking.pallet.pallet.Call.set_validator_count, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "set_validator_count" } }
  }
  /**
   * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
   * period ends. If this leaves an amount actively bonded less than
   * T::Currency::minimum_balance(), then it is increased to the full amount.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
   * the funds out of management ready for transfer.
   *
   * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
   * can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need
   * to be called first to remove some of the chunks (if possible).
   *
   * If a user encounters the `InsufficientBond` error when calling this extrinsic,
   * they should call `chill` first in order to free up their bonded funds.
   *
   * Emits `Unbonded`.
   *
   * See also [`Call::withdraw_unbonded`].
   */
  export function unbond(
    value: Omit<pallet_staking.pallet.pallet.Call.unbond, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "unbond" } }
  }
  /**
   * Declare the desire to validate for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   */
  export function validate(
    value: Omit<pallet_staking.pallet.pallet.Call.validate, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "validate" } }
  }
  /**
   * Remove any unlocked chunks from the `unlocking` queue from our management.
   *
   * This essentially frees up that balance to be used by the stash account to do
   * whatever it wants.
   *
   * The dispatch origin for this call must be _Signed_ by the controller.
   *
   * Emits `Withdrawn`.
   *
   * See also [`Call::unbond`].
   *
   * # <weight>
   * Complexity O(S) where S is the number of slashing spans to remove
   * NOTE: Weight annotation is the kill scenario, we refund otherwise.
   * # </weight>
   */
  export function withdraw_unbonded(
    value: Omit<pallet_staking.pallet.pallet.Call.withdraw_unbonded, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Staking", value: { ...value, type: "withdraw_unbonded" } }
  }
}
export namespace System {
  /** The full account information for a particular account ID. */
  export const Account = {
    type: "Map",
    modifier: "Default",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$3,
  }
  /** Total length (in bytes) for all extrinsics put together, for the current block. */
  export const AllExtrinsicsLen = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Map of block numbers to block hashes. */
  export const BlockHash = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$11,
  }
  /** The current weight for the block. */
  export const BlockWeight = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$7,
  }
  /** Digest of the current block, also part of the block header. */
  export const Digest = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$13,
  }
  /** The number of events in the `Events<T>` list. */
  export const EventCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  Mapping between a topic (represented by T::Hash) and a vector of indexes
   *  of events in the `<Events<T>>` list.
   *
   *  All topic vectors have deterministic storage locations depending on the topic. This
   *  allows light-clients to leverage the changes trie storage tracking mechanism and
   *  in case of changes fetch the list of events of interest.
   *
   *  The value has the type `(T::BlockNumber, EventIndex)` because if we used only just
   *  the `EventIndex` then in case if the topic has the same contents on the next block
   *  no notification will be triggered thus the event might be lost.
   */
  export const EventTopics = {
    type: "Map",
    modifier: "Default",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$11),
    value: _codec.$158,
  }
  /**
   *  Events deposited for the current block.
   *
   *  NOTE: The item is unbound and should therefore never be read on chain.
   *  It could otherwise inflate the PoV size of a block.
   *
   *  Events have a large in-memory size. Box the events to not go out-of-memory
   *  just in case someone still reads them from within the runtime.
   */
  export const Events = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$17,
  }
  /** The execution phase of the block. */
  export const ExecutionPhase = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$156,
  }
  /** Total extrinsics count for the current block. */
  export const ExtrinsicCount = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Extrinsics data for the current block (maps an extrinsic's index to its data). */
  export const ExtrinsicData = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$12,
  }
  /** Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened. */
  export const LastRuntimeUpgrade = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$159,
  }
  /** The current block number being processed. Set by `execute_block`. */
  export const Number = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Hash of the previous block. */
  export const ParentHash = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$11,
  }
  /**
   *  True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
   *  (default) if not.
   */
  export const UpgradedToTripleRefCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$43,
  }
  /** True if we have upgraded so that `type RefCount` is `u32`. False (default) if not. */
  export const UpgradedToU32RefCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$43,
  }
  /** A dispatch that will fill the block weight up to the given ratio. */
  export function fill_block(
    value: Omit<frame_system.pallet.Call.fill_block, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "fill_block" } }
  }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   */
  export function kill_prefix(
    value: Omit<frame_system.pallet.Call.kill_prefix, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "kill_prefix" } }
  }
  /** Kill some items from storage. */
  export function kill_storage(
    value: Omit<frame_system.pallet.Call.kill_storage, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "kill_storage" } }
  }
  /**
   * Make some on-chain remark.
   *
   * # <weight>
   * - `O(1)`
   * # </weight>
   */
  export function remark(
    value: Omit<frame_system.pallet.Call.remark, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "remark" } }
  }
  /** Make some on-chain remark and emit event. */
  export function remark_with_event(
    value: Omit<frame_system.pallet.Call.remark_with_event, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "remark_with_event" } }
  }
  /**
   * Set the new runtime code.
   *
   * # <weight>
   * - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`
   * - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is
   *   expensive).
   * - 1 storage write (codec `O(C)`).
   * - 1 digest item.
   * - 1 event.
   * The weight of this function is dependent on the runtime, but generally this is very
   * expensive. We will treat this as a full block.
   * # </weight>
   */
  export function set_code(
    value: Omit<frame_system.pallet.Call.set_code, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "set_code" } }
  }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * # <weight>
   * - `O(C)` where `C` length of `code`
   * - 1 storage write (codec `O(C)`).
   * - 1 digest item.
   * - 1 event.
   * The weight of this function is dependent on the runtime. We will treat this as a full
   * block. # </weight>
   */
  export function set_code_without_checks(
    value: Omit<frame_system.pallet.Call.set_code_without_checks, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "set_code_without_checks" } }
  }
  /** Set the number of pages in the WebAssembly environment's heap. */
  export function set_heap_pages(
    value: Omit<frame_system.pallet.Call.set_heap_pages, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "set_heap_pages" } }
  }
  /** Set some items of storage. */
  export function set_storage(
    value: Omit<frame_system.pallet.Call.set_storage, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "System", value: { ...value, type: "set_storage" } }
  }
}
export namespace TechnicalCommittee {
  /** The current members of the collective. This is stored sorted (just by value). */
  export const Members = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$206,
  }
  /** The prime member that helps determine the default vote behavior in case of absentations. */
  export const Prime = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$0,
  }
  /** Proposals so far. */
  export const ProposalCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Actual proposal for a given hash, if it's current. */
  export const ProposalOf = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$181,
  }
  /** The hashes of the active proposals. */
  export const Proposals = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$548,
  }
  /** Votes on a given proposal, if it is ongoing. */
  export const Voting = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$546,
  }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * # <weight>
   * ## Weight
   * - `O(B + M + P1 + P2)` where:
   *   - `B` is `proposal` size in bytes (length-fee-bounded)
   *   - `M` is members-count (code- and governance-bounded)
   *   - `P1` is the complexity of `proposal` preimage.
   *   - `P2` is proposal-count (code-bounded)
   * - DB:
   *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
   *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
   *    `O(P2)`)
   *  - any mutations done while executing `proposal` (`P1`)
   * - up to 3 events
   * # </weight>
   */
  export function close(
    value: Omit<pallet_collective.pallet.Call.close, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalCommittee", value: { ...value, type: "close" } }
  }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * # <weight>
   * ## Weight
   * - `O(B + M + P1 + P2)` where:
   *   - `B` is `proposal` size in bytes (length-fee-bounded)
   *   - `M` is members-count (code- and governance-bounded)
   *   - `P1` is the complexity of `proposal` preimage.
   *   - `P2` is proposal-count (code-bounded)
   * - DB:
   *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
   *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
   *    `O(P2)`)
   *  - any mutations done while executing `proposal` (`P1`)
   * - up to 3 events
   * # </weight>
   */
  export function close_old_weight(
    value: Omit<pallet_collective.pallet.Call.close_old_weight, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalCommittee", value: { ...value, type: "close_old_weight" } }
  }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * # <weight>
   * Complexity: O(P) where P is the number of max proposals
   * DB Weight:
   * * Reads: Proposals
   * * Writes: Voting, Proposals, ProposalOf
   * # </weight>
   */
  export function disapprove_proposal(
    value: Omit<pallet_collective.pallet.Call.disapprove_proposal, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalCommittee", value: { ...value, type: "disapprove_proposal" } }
  }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * # <weight>
   * ## Weight
   * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
   *   `proposal`
   * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
   * - 1 event
   * # </weight>
   */
  export function execute(
    value: Omit<pallet_collective.pallet.Call.execute, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalCommittee", value: { ...value, type: "execute" } }
  }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * # <weight>
   * ## Weight
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   *   - `B` is `proposal` size in bytes (length-fee-bounded)
   *   - `M` is members-count (code- and governance-bounded)
   *   - branching is influenced by `threshold` where:
   *     - `P1` is proposal execution complexity (`threshold < 2`)
   *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   * - DB:
   *   - 1 storage read `is_member` (codec `O(M)`)
   *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
   *   - DB accesses influenced by `threshold`:
   *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
   *     - OR proposal insertion (`threshold <= 2`)
   *       - 1 storage mutation `Proposals` (codec `O(P2)`)
   *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
   *       - 1 storage write `ProposalOf` (codec `O(B)`)
   *       - 1 storage write `Voting` (codec `O(M)`)
   *   - 1 event
   * # </weight>
   */
  export function propose(
    value: Omit<pallet_collective.pallet.Call.propose, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalCommittee", value: { ...value, type: "propose" } }
  }
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   *   weight estimation.
   *
   * Requires root origin.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   *       the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * # <weight>
   * ## Weight
   * - `O(MP + N)` where:
   *   - `M` old-members-count (code- and governance-bounded)
   *   - `N` new-members-count (code- and governance-bounded)
   *   - `P` proposals-count (code-bounded)
   * - DB:
   *   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the
   *     members
   *   - 1 storage read (codec `O(P)`) for reading the proposals
   *   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
   *   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
   * # </weight>
   */
  export function set_members(
    value: Omit<pallet_collective.pallet.Call.set_members, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalCommittee", value: { ...value, type: "set_members" } }
  }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * # <weight>
   * ## Weight
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   * - DB:
   *   - 1 storage read `Members` (codec `O(M)`)
   *   - 1 storage mutation `Voting` (codec `O(M)`)
   * - 1 event
   * # </weight>
   */
  export function vote(
    value: Omit<pallet_collective.pallet.Call.vote, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalCommittee", value: { ...value, type: "vote" } }
  }
}
export namespace TechnicalMembership {
  /** The current membership, stored as an ordered Vec. */
  export const Members = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$554,
  }
  /** The current prime member, if one exists. */
  export const Prime = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$0,
  }
  /**
   * Add a member `who` to the set.
   *
   * May only be called from `T::AddOrigin`.
   */
  export function add_member(
    value: Omit<pallet_membership.pallet.Call.add_member, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalMembership", value: { ...value, type: "add_member" } }
  }
  /**
   * Swap out the sending member for some other key `new`.
   *
   * May only be called from `Signed` origin of a current member.
   *
   * Prime membership is passed from the origin account to `new`, if extant.
   */
  export function change_key(
    value: Omit<pallet_membership.pallet.Call.change_key, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalMembership", value: { ...value, type: "change_key" } }
  }
  /**
   * Remove the prime member if it exists.
   *
   * May only be called from `T::PrimeOrigin`.
   */
  export function clear_prime(): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalMembership", value: { type: "clear_prime" } }
  }
  /**
   * Remove a member `who` from the set.
   *
   * May only be called from `T::RemoveOrigin`.
   */
  export function remove_member(
    value: Omit<pallet_membership.pallet.Call.remove_member, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalMembership", value: { ...value, type: "remove_member" } }
  }
  /**
   * Change the membership to a new set, disregarding the existing membership. Be nice and
   * pass `members` pre-sorted.
   *
   * May only be called from `T::ResetOrigin`.
   */
  export function reset_members(
    value: Omit<pallet_membership.pallet.Call.reset_members, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalMembership", value: { ...value, type: "reset_members" } }
  }
  /**
   * Set the prime member. Must be a current member.
   *
   * May only be called from `T::PrimeOrigin`.
   */
  export function set_prime(
    value: Omit<pallet_membership.pallet.Call.set_prime, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalMembership", value: { ...value, type: "set_prime" } }
  }
  /**
   * Swap out one member `remove` for another `add`.
   *
   * May only be called from `T::SwapOrigin`.
   *
   * Prime membership is *not* passed from `remove` to `add`, if extant.
   */
  export function swap_member(
    value: Omit<pallet_membership.pallet.Call.swap_member, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "TechnicalMembership", value: { ...value, type: "swap_member" } }
  }
}
export namespace Timestamp {
  /** Did the timestamp get updated in this block? */
  export const DidUpdate = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$43,
  }
  /** Current time for the current block. */
  export const Now = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$10,
  }
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * `MinimumPeriod`.
   *
   * The dispatch origin for this call must be `Inherent`.
   *
   * # <weight>
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
   *   `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   * # </weight>
   */
  export function set(
    value: Omit<pallet_timestamp.pallet.Call.set, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Timestamp", value: { ...value, type: "set" } }
  }
}
export namespace Tips {
  /**
   *  Simple preimage lookup from the reason's hash to the original data. Again, has an
   *  insecure enumerable hash since the key is guaranteed to be the result of a secure hash.
   */
  export const Reasons = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$12,
  }
  /**
   *  TipsMap that are not yet completed. Keyed by the hash of `(reason, who)` from the value.
   *  This has the insecure enumerable hash function since the key itself is already
   *  guaranteed to be a secure hash.
   */
  export const Tips = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$11),
    value: _codec.$598,
  }
  /**
   * Close and payout a tip.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * The tip identified by `hash` must have finished its countdown period.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   *   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * # <weight>
   * - Complexity: `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length
   *   `T`. `T` is charged as upper bound given by `ContainsLengthBound`. The actual cost
   *   depends on the implementation of `T::Tippers`.
   * - DbReads: `Tips`, `Tippers`, `tip finder`
   * - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
   * # </weight>
   */
  export function close_tip(
    value: Omit<pallet_tips.pallet.Call.close_tip, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Tips", value: { ...value, type: "close_tip" } }
  }
  /**
   * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   *   a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   *
   * Emits `NewTip` if successful.
   *
   * # <weight>
   * - Complexity: `O(R)` where `R` length of `reason`.
   *   - encoding and hashing of 'reason'
   * - DbReads: `Reasons`, `Tips`
   * - DbWrites: `Reasons`, `Tips`
   * # </weight>
   */
  export function report_awesome(
    value: Omit<pallet_tips.pallet.Call.report_awesome, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Tips", value: { ...value, type: "report_awesome" } }
  }
  /**
   * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
   *
   * If successful, the original deposit will be unreserved.
   *
   * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
   * must have been reported by the signing account through `report_awesome` (and not
   * through `tip_new`).
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   *   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * Emits `TipRetracted` if successful.
   *
   * # <weight>
   * - Complexity: `O(1)`
   *   - Depends on the length of `T::Hash` which is fixed.
   * - DbReads: `Tips`, `origin account`
   * - DbWrites: `Reasons`, `Tips`, `origin account`
   * # </weight>
   */
  export function retract_tip(
    value: Omit<pallet_tips.pallet.Call.retract_tip, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Tips", value: { ...value, type: "retract_tip" } }
  }
  /**
   * Remove and slash an already-open tip.
   *
   * May only be called from `T::RejectOrigin`.
   *
   * As a result, the finder is slashed and the deposits are lost.
   *
   * Emits `TipSlashed` if successful.
   *
   * # <weight>
   *   `T` is charged as upper bound given by `ContainsLengthBound`.
   *   The actual cost depends on the implementation of `T::Tippers`.
   * # </weight>
   */
  export function slash_tip(
    value: Omit<pallet_tips.pallet.Call.slash_tip, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Tips", value: { ...value, type: "slash_tip" } }
  }
  /**
   * Declare a tip value for an already-open tip.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   *   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
   *   account ID.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   *   value of active tippers will be given to the `who`.
   *
   * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
   * has started.
   *
   * # <weight>
   * - Complexity: `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length
   *   `T`, insert tip and check closing, `T` is charged as upper bound given by
   *   `ContainsLengthBound`. The actual cost depends on the implementation of `T::Tippers`.
   *
   *   Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
   *   is weighted as if almost full i.e of length `T-1`.
   * - DbReads: `Tippers`, `Tips`
   * - DbWrites: `Tips`
   * # </weight>
   */
  export function tip(
    value: Omit<pallet_tips.pallet.Call.tip, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Tips", value: { ...value, type: "tip" } }
  }
  /**
   * Give a tip for something new; no finder's fee will be taken.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   *   a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   *   value of active tippers will be given to the `who`.
   *
   * Emits `NewTip` if successful.
   *
   * # <weight>
   * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
   *   - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
   *     `ContainsLengthBound`. The actual cost depends on the implementation of
   *     `T::Tippers`.
   *   - `O(R)`: hashing and encoding of reason of length `R`
   * - DbReads: `Tippers`, `Reasons`
   * - DbWrites: `Reasons`, `Tips`
   * # </weight>
   */
  export function tip_new(
    value: Omit<pallet_tips.pallet.Call.tip_new, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Tips", value: { ...value, type: "tip_new" } }
  }
}
export namespace TransactionPayment {
  export const NextFeeMultiplier = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$479,
  }
  export const StorageVersion = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$480,
  }
}
export namespace Treasury {
  /** Proposal indices that have been approved but not yet awarded. */
  export const Approvals = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$557,
  }
  /** Number of proposals that have been made. */
  export const ProposalCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** Proposals that have been made. */
  export const Proposals = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$4),
    value: _codec.$556,
  }
  /**
   * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
   * and the original deposit will be returned.
   *
   * May only be called from `T::ApproveOrigin`.
   *
   * # <weight>
   * - Complexity: O(1).
   * - DbReads: `Proposals`, `Approvals`
   * - DbWrite: `Approvals`
   * # </weight>
   */
  export function approve_proposal(
    value: Omit<pallet_treasury.pallet.Call.approve_proposal, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Treasury", value: { ...value, type: "approve_proposal" } }
  }
  /**
   * Put forward a suggestion for spending. A deposit proportional to the value
   * is reserved and slashed if the proposal is rejected. It is returned once the
   * proposal is awarded.
   *
   * # <weight>
   * - Complexity: O(1)
   * - DbReads: `ProposalCount`, `origin account`
   * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
   * # </weight>
   */
  export function propose_spend(
    value: Omit<pallet_treasury.pallet.Call.propose_spend, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Treasury", value: { ...value, type: "propose_spend" } }
  }
  /**
   * Reject a proposed spend. The original deposit will be slashed.
   *
   * May only be called from `T::RejectOrigin`.
   *
   * # <weight>
   * - Complexity: O(1)
   * - DbReads: `Proposals`, `rejected proposer account`
   * - DbWrites: `Proposals`, `rejected proposer account`
   * # </weight>
   */
  export function reject_proposal(
    value: Omit<pallet_treasury.pallet.Call.reject_proposal, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Treasury", value: { ...value, type: "reject_proposal" } }
  }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   * The original deposit will no longer be returned.
   *
   * May only be called from `T::RejectOrigin`.
   * - `proposal_id`: The index of a proposal
   *
   * # <weight>
   * - Complexity: O(A) where `A` is the number of approvals
   * - Db reads and writes: `Approvals`
   * # </weight>
   *
   * Errors:
   * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
   * i.e., the proposal has not been approved. This could also mean the proposal does not
   * exist altogether, thus there is no way it would have been approved in the first place.
   */
  export function remove_approval(
    value: Omit<pallet_treasury.pallet.Call.remove_approval, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Treasury", value: { ...value, type: "remove_approval" } }
  }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   */
  export function spend(
    value: Omit<pallet_treasury.pallet.Call.spend, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Treasury", value: { ...value, type: "spend" } }
  }
}
export namespace Ump {
  /**
   *  The ordered list of `ParaId`s that have a `RelayDispatchQueue` entry.
   *
   *  Invariant:
   *  - The set of items from this vector should be exactly the set of the keys in
   *    `RelayDispatchQueues` and `RelayDispatchQueueSize`.
   */
  export const NeedsDispatch = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$662,
  }
  /**
   *  This is the para that gets will get dispatched first during the next upward dispatchable queue
   *  execution round.
   *
   *  Invariant:
   *  - If `Some(para)`, then `para` must be present in `NeedsDispatch`.
   */
  export const NextDispatchRoundStartWith = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$98,
  }
  /**
   *  The messages that exceeded max individual message weight budget.
   *
   *  These messages stay there until manually dispatched.
   */
  export const Overweight = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$10),
    value: _codec.$684,
  }
  /**
   *  The number of overweight messages ever recorded in `Overweight` (and thus the lowest free
   *  index).
   */
  export const OverweightCount = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$10,
  }
  /**
   *  Size of the dispatch queues. Caches sizes of the queues in `RelayDispatchQueue`.
   *
   *  First item in the tuple is the count of messages and second
   *  is the total length (in bytes) of the message payloads.
   *
   *  Note that this is an auxiliary mapping: it's possible to tell the byte size and the number of
   *  messages only looking at `RelayDispatchQueues`. This mapping is separate to avoid the cost of
   *  loading the whole message queue if only the total size and count are required.
   *
   *  Invariant:
   *  - The set of keys should exactly match the set of keys of `RelayDispatchQueues`.
   */
  export const RelayDispatchQueueSize = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$30,
  }
  /**
   *  The messages waiting to be handled by the relay-chain originating from a certain parachain.
   *
   *  Note that some upward messages might have been already processed by the inclusion logic. E.g.
   *  channel management messages.
   *
   *  The messages are processed in FIFO order.
   */
  export const RelayDispatchQueues = {
    type: "Map",
    modifier: "Default",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$98),
    value: _codec.$164,
  }
  /**
   * Service a single overweight upward message.
   *
   * - `origin`: Must pass `ExecuteOverweightOrigin`.
   * - `index`: The index of the overweight message to service.
   * - `weight_limit`: The amount of weight that message execution may take.
   *
   * Errors:
   * - `UnknownMessageIndex`: Message of `index` is unknown.
   * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
   *
   * Events:
   * - `OverweightServiced`: On success.
   */
  export function service_overweight(
    value: Omit<polkadot_runtime_parachains.ump.pallet.Call.service_overweight, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Ump", value: { ...value, type: "service_overweight" } }
  }
}
export namespace Utility {
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   */
  export function as_derivative(
    value: Omit<pallet_utility.pallet.Call.as_derivative, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Utility", value: { ...value, type: "as_derivative" } }
  }
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   *   exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then call are dispatch without checking origin filter. (This includes
   * bypassing `frame_system::Config::BaseCallFilter`).
   *
   * # <weight>
   * - Complexity: O(C) where C is the number of calls to be batched.
   * # </weight>
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   */
  export function batch(
    value: Omit<pallet_utility.pallet.Call.batch, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Utility", value: { ...value, type: "batch" } }
  }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   *   exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then call are dispatch without checking origin filter. (This includes
   * bypassing `frame_system::Config::BaseCallFilter`).
   *
   * # <weight>
   * - Complexity: O(C) where C is the number of calls to be batched.
   * # </weight>
   */
  export function batch_all(
    value: Omit<pallet_utility.pallet.Call.batch_all, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Utility", value: { ...value, type: "batch_all" } }
  }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * # <weight>
   * - O(1).
   * - Limited storage reads.
   * - One DB write (event).
   * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
   * # </weight>
   */
  export function dispatch_as(
    value: Omit<pallet_utility.pallet.Call.dispatch_as, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Utility", value: { ...value, type: "dispatch_as" } }
  }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   *   exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then call are dispatch without checking origin filter. (This includes
   * bypassing `frame_system::Config::BaseCallFilter`).
   *
   * # <weight>
   * - Complexity: O(C) where C is the number of calls to be batched.
   * # </weight>
   */
  export function force_batch(
    value: Omit<pallet_utility.pallet.Call.force_batch, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Utility", value: { ...value, type: "force_batch" } }
  }
}
export namespace Vesting {
  /**
   *  Storage version of the pallet.
   *
   *  New networks start with latest version, as determined by the genesis build.
   */
  export const StorageVersion = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$565,
  }
  /** Information regarding the vesting of a given account. */
  export const Vesting = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$563,
  }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * # <weight>
   * - `O(1)`.
   * - DbWeight: 4 Reads, 4 Writes
   *     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
   *     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
   * # </weight>
   */
  export function force_vested_transfer(
    value: Omit<pallet_vesting.pallet.Call.force_vested_transfer, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Vesting", value: { ...value, type: "force_vested_transfer" } }
  }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   *   current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   */
  export function merge_schedules(
    value: Omit<pallet_vesting.pallet.Call.merge_schedules, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Vesting", value: { ...value, type: "merge_schedules" } }
  }
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * # <weight>
   * - `O(1)`.
   * - DbWeight: 2 Reads, 2 Writes
   *     - Reads: Vesting Storage, Balances Locks, [Sender Account]
   *     - Writes: Vesting Storage, Balances Locks, [Sender Account]
   * # </weight>
   */
  export function vest(): polkadot_runtime.RuntimeCall {
    return { type: "Vesting", value: { type: "vest" } }
  }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * # <weight>
   * - `O(1)`.
   * - DbWeight: 3 Reads, 3 Writes
   *     - Reads: Vesting Storage, Balances Locks, Target Account
   *     - Writes: Vesting Storage, Balances Locks, Target Account
   * # </weight>
   */
  export function vest_other(
    value: Omit<pallet_vesting.pallet.Call.vest_other, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Vesting", value: { ...value, type: "vest_other" } }
  }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * # <weight>
   * - `O(1)`.
   * - DbWeight: 3 Reads, 3 Writes
   *     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
   *     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
   * # </weight>
   */
  export function vested_transfer(
    value: Omit<pallet_vesting.pallet.Call.vested_transfer, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "Vesting", value: { ...value, type: "vested_transfer" } }
  }
}
export namespace VoterList {
  /** Counter for the related counted storage map */
  export const CounterForListNodes = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /**
   *  A bag stored in storage.
   *
   *  Stores a `Bag` struct, which stores head and tail pointers to itself.
   */
  export const ListBags = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$10),
    value: _codec.$613,
  }
  /**
   *  A single node, within some bag.
   *
   *  Nodes store links forward and back within their respective bags.
   */
  export const ListNodes = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat"],
    key: $.tuple(_codec.$0),
    value: _codec.$612,
  }
  /**
   * Move the caller's Id directly in front of `lighter`.
   *
   * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
   * the account going in front of `lighter`.
   *
   * Only works if
   * - both nodes are within the same bag,
   * - and `origin` has a greater `Score` than `lighter`.
   */
  export function put_in_front_of(
    value: Omit<pallet_bags_list.pallet.Call.put_in_front_of, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "VoterList", value: { ...value, type: "put_in_front_of" } }
  }
  /**
   * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
   * changed its score that it should properly fall into a different bag than its current
   * one.
   *
   * Anyone can call this function about any potentially dislocated account.
   *
   * Will always update the stored score of `dislocated` to the correct score, based on
   * `ScoreProvider`.
   *
   * If `dislocated` does not exists, it returns an error.
   */
  export function rebag(
    value: Omit<pallet_bags_list.pallet.Call.rebag, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "VoterList", value: { ...value, type: "rebag" } }
  }
}
export namespace XcmPallet {
  /**
   *  The existing asset traps.
   *
   *  Key is the blake2 256 hash of (origin, versioned `MultiAssets`) pair. Value is the number of
   *  times this pair has been trapped (usually just 1 if it exists at all).
   */
  export const AssetTraps = {
    type: "Map",
    modifier: "Default",
    hashers: ["Identity"],
    key: $.tuple(_codec.$11),
    value: _codec.$4,
  }
  /** The current migration's stage, if any. */
  export const CurrentMigration = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$722,
  }
  /** The ongoing queries. */
  export const Queries = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Blake2_128Concat"],
    key: $.tuple(_codec.$10),
    value: _codec.$713,
  }
  /** The latest available query index. */
  export const QueryCounter = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$10,
  }
  /**
   *  Default version to encode XCM when latest version of destination is unknown. If `None`,
   *  then the destinations whose XCM version is unknown are considered unreachable.
   */
  export const SafeXcmVersion = {
    type: "Plain",
    modifier: "Optional",
    hashers: [],
    key: [],
    value: _codec.$4,
  }
  /** The Latest versions that we know various locations support. */
  export const SupportedVersion = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Blake2_128Concat"],
    key: _codec.$717,
    value: _codec.$4,
  }
  /**
   *  Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
   *  the `u32` counter is the number of times that a send to the destination has been attempted,
   *  which is used as a prioritization.
   */
  export const VersionDiscoveryQueue = {
    type: "Plain",
    modifier: "Default",
    hashers: [],
    key: [],
    value: _codec.$719,
  }
  /** All locations that we have requested version notifications from. */
  export const VersionNotifiers = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Blake2_128Concat"],
    key: _codec.$717,
    value: _codec.$10,
  }
  /**
   *  The target locations that are subscribed to our version changes, as well as the most recent
   *  of our versions we informed them of.
   */
  export const VersionNotifyTargets = {
    type: "Map",
    modifier: "Optional",
    hashers: ["Twox64Concat", "Blake2_128Concat"],
    key: _codec.$717,
    value: _codec.$718,
  }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than the
   * maximum amount of weight that the message could take to be executed, then no execution
   * attempt will be made.
   *
   * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
   * to completion; only that *some* of it was executed.
   */
  export function execute(
    value: Omit<pallet_xcm.pallet.Call.execute, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "execute" } }
  }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be Root.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   */
  export function force_default_xcm_version(
    value: Omit<pallet_xcm.pallet.Call.force_default_xcm_version, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "force_default_xcm_version" } }
  }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be Root.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   */
  export function force_subscribe_version_notify(
    value: Omit<pallet_xcm.pallet.Call.force_subscribe_version_notify, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "force_subscribe_version_notify" } }
  }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be Root.
   * - `location`: The location to which we are currently subscribed for XCM version
   *   notifications which we no longer desire.
   */
  export function force_unsubscribe_version_notify(
    value: Omit<pallet_xcm.pallet.Call.force_unsubscribe_version_notify, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "force_unsubscribe_version_notify" } }
  }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be Root.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   */
  export function force_xcm_version(
    value: Omit<pallet_xcm.pallet.Call.force_xcm_version, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "force_xcm_version" } }
  }
  /**
   * Transfer some assets from the local chain to the sovereign account of a destination
   * chain and forward a notification XCM.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the assets send may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
   *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
   *   an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
   *   `dest` side.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   *   fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   */
  export function limited_reserve_transfer_assets(
    value: Omit<pallet_xcm.pallet.Call.limited_reserve_transfer_assets, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "limited_reserve_transfer_assets" } }
  }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the assets send may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
   *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
   *   an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
   *   `dest` side. May not be empty.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   *   fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   */
  export function limited_teleport_assets(
    value: Omit<pallet_xcm.pallet.Call.limited_teleport_assets, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "limited_teleport_assets" } }
  }
  /**
   * Transfer some assets from the local chain to the sovereign account of a destination
   * chain and forward a notification XCM.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
   *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
   *   an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
   *   `dest` side.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   *   fees.
   */
  export function reserve_transfer_assets(
    value: Omit<pallet_xcm.pallet.Call.reserve_transfer_assets, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "reserve_transfer_assets" } }
  }
  export function send(
    value: Omit<pallet_xcm.pallet.Call.send, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "send" } }
  }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
   *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
   *   an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
   *   `dest` side. May not be empty.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   *   fees.
   */
  export function teleport_assets(
    value: Omit<pallet_xcm.pallet.Call.teleport_assets, "type">,
  ): polkadot_runtime.RuntimeCall {
    return { type: "XcmPallet", value: { ...value, type: "teleport_assets" } }
  }
}
export namespace bitvec {
  export namespace order {
    export const $lsb0: $.Codec<bitvec.order.Lsb0> = _codec.$384
    export function Lsb0() {
      return null
    }
    export type Lsb0 = null
  }
}
export namespace finality_grandpa {
  export const $precommit: $.Codec<finality_grandpa.Precommit> = _codec.$225
  export const $prevote: $.Codec<finality_grandpa.Prevote> = _codec.$220
  export namespace Equivocation {
    export namespace $$finality_grandpa {
      export const $precommit: $.Codec<finality_grandpa.Equivocation.$$finality_grandpa.Precommit> =
        _codec.$224
      export const $prevote: $.Codec<finality_grandpa.Equivocation.$$finality_grandpa.Prevote> =
        _codec.$219
      export interface Precommit {
        round_number: u64
        identity: sp_finality_grandpa.app.Public
        first: [finality_grandpa.Precommit, sp_finality_grandpa.app.Signature]
        second: [finality_grandpa.Precommit, sp_finality_grandpa.app.Signature]
      }
      export function Precommit(value: finality_grandpa.Equivocation.$$finality_grandpa.Precommit) {
        return value
      }
      export interface Prevote {
        round_number: u64
        identity: sp_finality_grandpa.app.Public
        first: [finality_grandpa.Prevote, sp_finality_grandpa.app.Signature]
        second: [finality_grandpa.Prevote, sp_finality_grandpa.app.Signature]
      }
      export function Prevote(value: finality_grandpa.Equivocation.$$finality_grandpa.Prevote) {
        return value
      }
    }
  }
  export interface Precommit {
    target_hash: primitive_types.H256
    target_number: u32
  }
  export function Precommit(value: finality_grandpa.Precommit) {
    return value
  }
  export interface Prevote {
    target_hash: primitive_types.H256
    target_number: u32
  }
  export function Prevote(value: finality_grandpa.Prevote) {
    return value
  }
}
export namespace frame_support {
  export const $palletId: $.Codec<frame_support.PalletId> = _codec.$560
  export type PalletId = Uint8Array
  export function PalletId(value: frame_support.PalletId) {
    return value
  }
  export namespace dispatch {
    export const $dispatchClass: $.Codec<frame_support.dispatch.DispatchClass> = _codec.$22
    export const $dispatchInfo: $.Codec<frame_support.dispatch.DispatchInfo> = _codec.$21
    export const $pays: $.Codec<frame_support.dispatch.Pays> = _codec.$23
    export const $rawOrigin: $.Codec<frame_support.dispatch.RawOrigin> = _codec.$257
    export type DispatchClass = "Normal" | "Operational" | "Mandatory"
    export interface DispatchInfo {
      weight: sp_weights.weight_v2.Weight
      class: frame_support.dispatch.DispatchClass
      pays_fee: frame_support.dispatch.Pays
    }
    export function DispatchInfo(value: frame_support.dispatch.DispatchInfo) {
      return value
    }
    export type Pays = "Yes" | "No"
    export namespace PerDispatchClass {
      export const $$$u32: $.Codec<frame_support.dispatch.PerDispatchClass.$$u32> = _codec.$170
      export namespace $$frame_system {
        export namespace limits {
          export const $weightsPerClass: $.Codec<
            frame_support.dispatch.PerDispatchClass.$$frame_system.limits.WeightsPerClass
          > = _codec.$166
          export interface WeightsPerClass {
            normal: frame_system.limits.WeightsPerClass
            operational: frame_system.limits.WeightsPerClass
            mandatory: frame_system.limits.WeightsPerClass
          }
          export function WeightsPerClass(
            value: frame_support.dispatch.PerDispatchClass.$$frame_system.limits.WeightsPerClass,
          ) {
            return value
          }
        }
      }
      export namespace $$sp_weights {
        export namespace weight_v2 {
          export const $weight: $.Codec<
            frame_support.dispatch.PerDispatchClass.$$sp_weights.weight_v2.Weight
          > = _codec.$7
          export interface Weight {
            normal: sp_weights.weight_v2.Weight
            operational: sp_weights.weight_v2.Weight
            mandatory: sp_weights.weight_v2.Weight
          }
          export function Weight(
            value: frame_support.dispatch.PerDispatchClass.$$sp_weights.weight_v2.Weight,
          ) {
            return value
          }
        }
      }
      export interface $$u32 {
        normal: u32
        operational: u32
        mandatory: u32
      }
      export function $$u32(value: frame_support.dispatch.PerDispatchClass.$$u32) {
        return value
      }
    }
    export type RawOrigin =
      | frame_support.dispatch.RawOrigin.Root
      | frame_support.dispatch.RawOrigin.Signed
      | frame_support.dispatch.RawOrigin.None
    export namespace RawOrigin {
      export function None(): frame_support.dispatch.RawOrigin.None {
        return { type: "None" }
      }
      export interface None {
        type: "None"
      }
      export function Root(): frame_support.dispatch.RawOrigin.Root {
        return { type: "Root" }
      }
      export interface Root {
        type: "Root"
      }
      export function Signed(
        value: frame_support.dispatch.RawOrigin.Signed["value"],
      ): frame_support.dispatch.RawOrigin.Signed {
        return { type: "Signed", value }
      }
      export interface Signed {
        type: "Signed"
        value: sp_core.crypto.AccountId32
      }
    }
  }
  export namespace traits {
    export namespace misc {
      export const $wrapperOpaque: $.Codec<pallet_im_online.BoundedOpaqueNetworkState> = _codec.$522
    }
    export namespace preimages {
      export const $bounded: $.Codec<frame_support.traits.preimages.Bounded> = _codec.$180
      export type Bounded =
        | frame_support.traits.preimages.Bounded.Legacy
        | frame_support.traits.preimages.Bounded.Inline
        | frame_support.traits.preimages.Bounded.Lookup
      export namespace Bounded {
        export function Inline(
          value: frame_support.traits.preimages.Bounded.Inline["value"],
        ): frame_support.traits.preimages.Bounded.Inline {
          return { type: "Inline", value }
        }
        export interface Inline {
          type: "Inline"
          value: Uint8Array
        }
        export function Legacy(
          value: Omit<frame_support.traits.preimages.Bounded.Legacy, "type">,
        ): frame_support.traits.preimages.Bounded.Legacy {
          return { type: "Legacy", ...value }
        }
        export interface Legacy {
          type: "Legacy"
          hash: primitive_types.H256
        }
        export function Lookup(
          value: Omit<frame_support.traits.preimages.Bounded.Lookup, "type">,
        ): frame_support.traits.preimages.Bounded.Lookup {
          return { type: "Lookup", ...value }
        }
        export interface Lookup {
          type: "Lookup"
          hash: primitive_types.H256
          len: u32
        }
      }
    }
    export namespace tokens {
      export namespace misc {
        export const $balanceStatus: $.Codec<frame_support.traits.tokens.misc.BalanceStatus> =
          _codec.$37
        export type BalanceStatus = "Free" | "Reserved"
      }
    }
  }
}
export namespace frame_system {
  export const $accountInfo: $.Codec<frame_system.AccountInfo> = _codec.$3
  export const $eventRecord: $.Codec<frame_system.EventRecord> = _codec.$18
  export const $lastRuntimeUpgradeInfo: $.Codec<frame_system.LastRuntimeUpgradeInfo> = _codec.$159
  export const $phase: $.Codec<frame_system.Phase> = _codec.$156
  export interface AccountInfo {
    nonce: u32
    consumers: u32
    providers: u32
    sufficients: u32
    data: pallet_balances.AccountData
  }
  export function AccountInfo(value: frame_system.AccountInfo) {
    return value
  }
  export interface EventRecord {
    phase: frame_system.Phase
    event: polkadot_runtime.RuntimeEvent
    topics: Array<primitive_types.H256>
  }
  export function EventRecord(value: frame_system.EventRecord) {
    return value
  }
  export interface LastRuntimeUpgradeInfo {
    spec_version: Compact<u32>
    spec_name: string
  }
  export function LastRuntimeUpgradeInfo(value: frame_system.LastRuntimeUpgradeInfo) {
    return value
  }
  export type Phase =
    | frame_system.Phase.ApplyExtrinsic
    | frame_system.Phase.Finalization
    | frame_system.Phase.Initialization
  export namespace Phase {
    export function ApplyExtrinsic(
      value: frame_system.Phase.ApplyExtrinsic["value"],
    ): frame_system.Phase.ApplyExtrinsic {
      return { type: "ApplyExtrinsic", value }
    }
    export interface ApplyExtrinsic {
      type: "ApplyExtrinsic"
      value: u32
    }
    export function Finalization(): frame_system.Phase.Finalization {
      return { type: "Finalization" }
    }
    export interface Finalization {
      type: "Finalization"
    }
    export function Initialization(): frame_system.Phase.Initialization {
      return { type: "Initialization" }
    }
    export interface Initialization {
      type: "Initialization"
    }
  }
  export namespace extensions {
    export namespace check_genesis {
      export const $checkGenesis: $.Codec<frame_system.extensions.check_genesis.CheckGenesis> =
        _codec.$730
      export function CheckGenesis() {
        return null
      }
      export type CheckGenesis = null
    }
    export namespace check_non_zero_sender {
      export const $checkNonZeroSender: $.Codec<
        frame_system.extensions.check_non_zero_sender.CheckNonZeroSender
      > = _codec.$727
      export function CheckNonZeroSender() {
        return null
      }
      export type CheckNonZeroSender = null
    }
    export namespace check_spec_version {
      export const $checkSpecVersion: $.Codec<
        frame_system.extensions.check_spec_version.CheckSpecVersion
      > = _codec.$728
      export function CheckSpecVersion() {
        return null
      }
      export type CheckSpecVersion = null
    }
    export namespace check_tx_version {
      export const $checkTxVersion: $.Codec<
        frame_system.extensions.check_tx_version.CheckTxVersion
      > = _codec.$729
      export function CheckTxVersion() {
        return null
      }
      export type CheckTxVersion = null
    }
    export namespace check_weight {
      export const $checkWeight: $.Codec<frame_system.extensions.check_weight.CheckWeight> =
        _codec.$734
      export function CheckWeight() {
        return null
      }
      export type CheckWeight = null
    }
  }
  export namespace limits {
    export const $blockLength: $.Codec<frame_system.limits.BlockLength> = _codec.$169
    export const $blockWeights: $.Codec<frame_system.limits.BlockWeights> = _codec.$165
    export const $weightsPerClass: $.Codec<frame_system.limits.WeightsPerClass> = _codec.$167
    export interface BlockLength {
      max: frame_support.dispatch.PerDispatchClass.$$u32
    }
    export function BlockLength(value: frame_system.limits.BlockLength) {
      return value
    }
    export interface BlockWeights {
      base_block: sp_weights.weight_v2.Weight
      max_block: sp_weights.weight_v2.Weight
      per_class: frame_support.dispatch.PerDispatchClass.$$frame_system.limits.WeightsPerClass
    }
    export function BlockWeights(value: frame_system.limits.BlockWeights) {
      return value
    }
    export interface WeightsPerClass {
      base_extrinsic: sp_weights.weight_v2.Weight
      max_extrinsic: sp_weights.weight_v2.Weight | undefined
      max_total: sp_weights.weight_v2.Weight | undefined
      reserved: sp_weights.weight_v2.Weight | undefined
    }
    export function WeightsPerClass(value: frame_system.limits.WeightsPerClass) {
      return value
    }
  }
  export namespace pallet {
    export const $call: $.Codec<frame_system.pallet.Call> = _codec.$161
    export const $error: $.Codec<frame_system.pallet.Error> = _codec.$176
    export const $event: $.Codec<frame_system.pallet.Event> = _codec.$20
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | frame_system.pallet.Call.fill_block
      | frame_system.pallet.Call.remark
      | frame_system.pallet.Call.set_heap_pages
      | frame_system.pallet.Call.set_code
      | frame_system.pallet.Call.set_code_without_checks
      | frame_system.pallet.Call.set_storage
      | frame_system.pallet.Call.kill_storage
      | frame_system.pallet.Call.kill_prefix
      | frame_system.pallet.Call.remark_with_event
    export namespace Call {
      /** A dispatch that will fill the block weight up to the given ratio. */
      export function fill_block(
        value: Omit<frame_system.pallet.Call.fill_block, "type">,
      ): frame_system.pallet.Call.fill_block {
        return { type: "fill_block", ...value }
      }
      /** A dispatch that will fill the block weight up to the given ratio. */
      export interface fill_block {
        type: "fill_block"
        ratio: sp_arithmetic.per_things.Perbill
      }
      /**
       * Kill all storage items with a key that starts with the given prefix.
       *
       * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
       * the prefix we are removing to accurately calculate the weight of this function.
       */
      export function kill_prefix(
        value: Omit<frame_system.pallet.Call.kill_prefix, "type">,
      ): frame_system.pallet.Call.kill_prefix {
        return { type: "kill_prefix", ...value }
      }
      /**
       * Kill all storage items with a key that starts with the given prefix.
       *
       * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
       * the prefix we are removing to accurately calculate the weight of this function.
       */
      export interface kill_prefix {
        type: "kill_prefix"
        prefix: Uint8Array
        subkeys: u32
      }
      /** Kill some items from storage. */
      export function kill_storage(
        value: Omit<frame_system.pallet.Call.kill_storage, "type">,
      ): frame_system.pallet.Call.kill_storage {
        return { type: "kill_storage", ...value }
      }
      /** Kill some items from storage. */
      export interface kill_storage {
        type: "kill_storage"
        keys: Array<Uint8Array>
      }
      /**
       * Make some on-chain remark.
       *
       * # <weight>
       * - `O(1)`
       * # </weight>
       */
      export function remark(
        value: Omit<frame_system.pallet.Call.remark, "type">,
      ): frame_system.pallet.Call.remark {
        return { type: "remark", ...value }
      }
      /**
       * Make some on-chain remark.
       *
       * # <weight>
       * - `O(1)`
       * # </weight>
       */
      export interface remark {
        type: "remark"
        remark: Uint8Array
      }
      /** Make some on-chain remark and emit event. */
      export function remark_with_event(
        value: Omit<frame_system.pallet.Call.remark_with_event, "type">,
      ): frame_system.pallet.Call.remark_with_event {
        return { type: "remark_with_event", ...value }
      }
      /** Make some on-chain remark and emit event. */
      export interface remark_with_event {
        type: "remark_with_event"
        remark: Uint8Array
      }
      /**
       * Set the new runtime code.
       *
       * # <weight>
       * - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`
       * - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is
       *   expensive).
       * - 1 storage write (codec `O(C)`).
       * - 1 digest item.
       * - 1 event.
       * The weight of this function is dependent on the runtime, but generally this is very
       * expensive. We will treat this as a full block.
       * # </weight>
       */
      export function set_code(
        value: Omit<frame_system.pallet.Call.set_code, "type">,
      ): frame_system.pallet.Call.set_code {
        return { type: "set_code", ...value }
      }
      /**
       * Set the new runtime code.
       *
       * # <weight>
       * - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`
       * - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is
       *   expensive).
       * - 1 storage write (codec `O(C)`).
       * - 1 digest item.
       * - 1 event.
       * The weight of this function is dependent on the runtime, but generally this is very
       * expensive. We will treat this as a full block.
       * # </weight>
       */
      export interface set_code {
        type: "set_code"
        code: Uint8Array
      }
      /**
       * Set the new runtime code without doing any checks of the given `code`.
       *
       * # <weight>
       * - `O(C)` where `C` length of `code`
       * - 1 storage write (codec `O(C)`).
       * - 1 digest item.
       * - 1 event.
       * The weight of this function is dependent on the runtime. We will treat this as a full
       * block. # </weight>
       */
      export function set_code_without_checks(
        value: Omit<frame_system.pallet.Call.set_code_without_checks, "type">,
      ): frame_system.pallet.Call.set_code_without_checks {
        return { type: "set_code_without_checks", ...value }
      }
      /**
       * Set the new runtime code without doing any checks of the given `code`.
       *
       * # <weight>
       * - `O(C)` where `C` length of `code`
       * - 1 storage write (codec `O(C)`).
       * - 1 digest item.
       * - 1 event.
       * The weight of this function is dependent on the runtime. We will treat this as a full
       * block. # </weight>
       */
      export interface set_code_without_checks {
        type: "set_code_without_checks"
        code: Uint8Array
      }
      /** Set the number of pages in the WebAssembly environment's heap. */
      export function set_heap_pages(
        value: Omit<frame_system.pallet.Call.set_heap_pages, "type">,
      ): frame_system.pallet.Call.set_heap_pages {
        return { type: "set_heap_pages", ...value }
      }
      /** Set the number of pages in the WebAssembly environment's heap. */
      export interface set_heap_pages {
        type: "set_heap_pages"
        pages: u64
      }
      /** Set some items of storage. */
      export function set_storage(
        value: Omit<frame_system.pallet.Call.set_storage, "type">,
      ): frame_system.pallet.Call.set_storage {
        return { type: "set_storage", ...value }
      }
      /** Set some items of storage. */
      export interface set_storage {
        type: "set_storage"
        items: Array<[Uint8Array, Uint8Array]>
      }
    }
    /** Error for the System pallet */
    export type Error =
      | "InvalidSpecName"
      | "SpecVersionNeedsToIncrease"
      | "FailedToExtractRuntimeVersion"
      | "NonDefaultComposite"
      | "NonZeroRefCount"
      | "CallFiltered"
    /** Event for the System pallet. */
    export type Event =
      | frame_system.pallet.Event.ExtrinsicSuccess
      | frame_system.pallet.Event.ExtrinsicFailed
      | frame_system.pallet.Event.CodeUpdated
      | frame_system.pallet.Event.NewAccount
      | frame_system.pallet.Event.KilledAccount
      | frame_system.pallet.Event.Remarked
    export namespace Event {
      /** `:code` was updated. */
      export function CodeUpdated(): frame_system.pallet.Event.CodeUpdated {
        return { type: "CodeUpdated" }
      }
      /** `:code` was updated. */
      export interface CodeUpdated {
        type: "CodeUpdated"
      }
      /** An extrinsic failed. */
      export function ExtrinsicFailed(
        value: Omit<frame_system.pallet.Event.ExtrinsicFailed, "type">,
      ): frame_system.pallet.Event.ExtrinsicFailed {
        return { type: "ExtrinsicFailed", ...value }
      }
      /** An extrinsic failed. */
      export interface ExtrinsicFailed {
        type: "ExtrinsicFailed"
        dispatch_error: sp_runtime.DispatchError
        dispatch_info: frame_support.dispatch.DispatchInfo
      }
      /** An extrinsic completed successfully. */
      export function ExtrinsicSuccess(
        value: Omit<frame_system.pallet.Event.ExtrinsicSuccess, "type">,
      ): frame_system.pallet.Event.ExtrinsicSuccess {
        return { type: "ExtrinsicSuccess", ...value }
      }
      /** An extrinsic completed successfully. */
      export interface ExtrinsicSuccess {
        type: "ExtrinsicSuccess"
        dispatch_info: frame_support.dispatch.DispatchInfo
      }
      /** An account was reaped. */
      export function KilledAccount(
        value: Omit<frame_system.pallet.Event.KilledAccount, "type">,
      ): frame_system.pallet.Event.KilledAccount {
        return { type: "KilledAccount", ...value }
      }
      /** An account was reaped. */
      export interface KilledAccount {
        type: "KilledAccount"
        account: sp_core.crypto.AccountId32
      }
      /** A new account was created. */
      export function NewAccount(
        value: Omit<frame_system.pallet.Event.NewAccount, "type">,
      ): frame_system.pallet.Event.NewAccount {
        return { type: "NewAccount", ...value }
      }
      /** A new account was created. */
      export interface NewAccount {
        type: "NewAccount"
        account: sp_core.crypto.AccountId32
      }
      /** On on-chain remark happened. */
      export function Remarked(
        value: Omit<frame_system.pallet.Event.Remarked, "type">,
      ): frame_system.pallet.Event.Remarked {
        return { type: "Remarked", ...value }
      }
      /** On on-chain remark happened. */
      export interface Remarked {
        type: "Remarked"
        sender: sp_core.crypto.AccountId32
        hash: primitive_types.H256
      }
    }
  }
}
export namespace pallet_authorship {
  export const $uncleEntryItem: $.Codec<pallet_authorship.UncleEntryItem> = _codec.$482
  export type UncleEntryItem =
    | pallet_authorship.UncleEntryItem.InclusionHeight
    | pallet_authorship.UncleEntryItem.Uncle
  export namespace UncleEntryItem {
    export function InclusionHeight(
      value: pallet_authorship.UncleEntryItem.InclusionHeight["value"],
    ): pallet_authorship.UncleEntryItem.InclusionHeight {
      return { type: "InclusionHeight", value }
    }
    export interface InclusionHeight {
      type: "InclusionHeight"
      value: u32
    }
    export function Uncle(
      ...value: pallet_authorship.UncleEntryItem.Uncle["value"]
    ): pallet_authorship.UncleEntryItem.Uncle {
      return { type: "Uncle", value }
    }
    export interface Uncle {
      type: "Uncle"
      value: [primitive_types.H256, sp_core.crypto.AccountId32 | undefined]
    }
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_authorship.pallet.Call> = _codec.$200
    export const $error: $.Codec<pallet_authorship.pallet.Error> = _codec.$484
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call = pallet_authorship.pallet.Call.set_uncles
    export namespace Call {
      /** Provide a set of uncles. */
      export function set_uncles(
        value: Omit<pallet_authorship.pallet.Call.set_uncles, "type">,
      ): pallet_authorship.pallet.Call.set_uncles {
        return { type: "set_uncles", ...value }
      }
      /** Provide a set of uncles. */
      export interface set_uncles {
        type: "set_uncles"
        new_uncles: Array<sp_runtime.generic.header.Header>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "InvalidUncleParent"
      | "UnclesAlreadySet"
      | "TooManyUncles"
      | "GenesisUncle"
      | "TooHighUncle"
      | "UncleAlreadyIncluded"
      | "OldUncle"
  }
}
export namespace pallet_babe {
  export namespace pallet {
    export const $call: $.Codec<pallet_babe.pallet.Call> = _codec.$185
    export const $error: $.Codec<pallet_babe.pallet.Error> = _codec.$467
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_babe.pallet.Call.report_equivocation
      | pallet_babe.pallet.Call.report_equivocation_unsigned
      | pallet_babe.pallet.Call.plan_config_change
    export namespace Call {
      /**
       * Plan an epoch config change. The epoch config change is recorded and will be enacted on
       * the next call to `enact_epoch_change`. The config will be activated one epoch after.
       * Multiple calls to this method will replace any existing planned config change that had
       * not been enacted yet.
       */
      export function plan_config_change(
        value: Omit<pallet_babe.pallet.Call.plan_config_change, "type">,
      ): pallet_babe.pallet.Call.plan_config_change {
        return { type: "plan_config_change", ...value }
      }
      /**
       * Plan an epoch config change. The epoch config change is recorded and will be enacted on
       * the next call to `enact_epoch_change`. The config will be activated one epoch after.
       * Multiple calls to this method will replace any existing planned config change that had
       * not been enacted yet.
       */
      export interface plan_config_change {
        type: "plan_config_change"
        config: sp_consensus_babe.digests.NextConfigDescriptor
      }
      /**
       * Report authority equivocation/misbehavior. This method will verify
       * the equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence will
       * be reported.
       */
      export function report_equivocation(
        value: Omit<pallet_babe.pallet.Call.report_equivocation, "type">,
      ): pallet_babe.pallet.Call.report_equivocation {
        return { type: "report_equivocation", ...value }
      }
      /**
       * Report authority equivocation/misbehavior. This method will verify
       * the equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence will
       * be reported.
       */
      export interface report_equivocation {
        type: "report_equivocation"
        equivocation_proof: sp_consensus_slots.EquivocationProof
        key_owner_proof: sp_session.MembershipProof
      }
      /**
       * Report authority equivocation/misbehavior. This method will verify
       * the equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence will
       * be reported.
       * This extrinsic must be called unsigned and it is expected that only
       * block authors will call it (validated in `ValidateUnsigned`), as such
       * if the block author is defined it will be defined as the equivocation
       * reporter.
       */
      export function report_equivocation_unsigned(
        value: Omit<pallet_babe.pallet.Call.report_equivocation_unsigned, "type">,
      ): pallet_babe.pallet.Call.report_equivocation_unsigned {
        return { type: "report_equivocation_unsigned", ...value }
      }
      /**
       * Report authority equivocation/misbehavior. This method will verify
       * the equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence will
       * be reported.
       * This extrinsic must be called unsigned and it is expected that only
       * block authors will call it (validated in `ValidateUnsigned`), as such
       * if the block author is defined it will be defined as the equivocation
       * reporter.
       */
      export interface report_equivocation_unsigned {
        type: "report_equivocation_unsigned"
        equivocation_proof: sp_consensus_slots.EquivocationProof
        key_owner_proof: sp_session.MembershipProof
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "InvalidEquivocationProof"
      | "InvalidKeyOwnershipProof"
      | "DuplicateOffenceReport"
      | "InvalidConfiguration"
  }
}
export namespace pallet_bags_list {
  export namespace list {
    export const $bag: $.Codec<pallet_bags_list.list.Bag> = _codec.$613
    export const $listError: $.Codec<pallet_bags_list.list.ListError> = _codec.$616
    export const $node: $.Codec<pallet_bags_list.list.Node> = _codec.$612
    export interface Bag {
      head: sp_core.crypto.AccountId32 | undefined
      tail: sp_core.crypto.AccountId32 | undefined
    }
    export function Bag(value: pallet_bags_list.list.Bag) {
      return value
    }
    export type ListError = "Duplicate" | "NotHeavier" | "NotInSameBag" | "NodeNotFound"
    export interface Node {
      id: sp_core.crypto.AccountId32
      prev: sp_core.crypto.AccountId32 | undefined
      next: sp_core.crypto.AccountId32 | undefined
      bag_upper: u64
      score: u64
    }
    export function Node(value: pallet_bags_list.list.Node) {
      return value
    }
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_bags_list.pallet.Call> = _codec.$368
    export const $error: $.Codec<pallet_bags_list.pallet.Error> = _codec.$615
    export const $event: $.Codec<pallet_bags_list.pallet.Event> = _codec.$89
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_bags_list.pallet.Call.rebag
      | pallet_bags_list.pallet.Call.put_in_front_of
    export namespace Call {
      /**
       * Move the caller's Id directly in front of `lighter`.
       *
       * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
       * the account going in front of `lighter`.
       *
       * Only works if
       * - both nodes are within the same bag,
       * - and `origin` has a greater `Score` than `lighter`.
       */
      export function put_in_front_of(
        value: Omit<pallet_bags_list.pallet.Call.put_in_front_of, "type">,
      ): pallet_bags_list.pallet.Call.put_in_front_of {
        return { type: "put_in_front_of", ...value }
      }
      /**
       * Move the caller's Id directly in front of `lighter`.
       *
       * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
       * the account going in front of `lighter`.
       *
       * Only works if
       * - both nodes are within the same bag,
       * - and `origin` has a greater `Score` than `lighter`.
       */
      export interface put_in_front_of {
        type: "put_in_front_of"
        lighter: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
       * changed its score that it should properly fall into a different bag than its current
       * one.
       *
       * Anyone can call this function about any potentially dislocated account.
       *
       * Will always update the stored score of `dislocated` to the correct score, based on
       * `ScoreProvider`.
       *
       * If `dislocated` does not exists, it returns an error.
       */
      export function rebag(
        value: Omit<pallet_bags_list.pallet.Call.rebag, "type">,
      ): pallet_bags_list.pallet.Call.rebag {
        return { type: "rebag", ...value }
      }
      /**
       * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
       * changed its score that it should properly fall into a different bag than its current
       * one.
       *
       * Anyone can call this function about any potentially dislocated account.
       *
       * Will always update the stored score of `dislocated` to the correct score, based on
       * `ScoreProvider`.
       *
       * If `dislocated` does not exists, it returns an error.
       */
      export interface rebag {
        type: "rebag"
        dislocated: sp_runtime.multiaddress.MultiAddress
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error = pallet_bags_list.pallet.Error.List
    export namespace Error {
      /** A error in the list interface implementation. */
      export function List(
        value: pallet_bags_list.pallet.Error.List["value"],
      ): pallet_bags_list.pallet.Error.List {
        return { type: "List", value }
      }
      /** A error in the list interface implementation. */
      export interface List {
        type: "List"
        value: pallet_bags_list.list.ListError
      }
    }
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_bags_list.pallet.Event.Rebagged
      | pallet_bags_list.pallet.Event.ScoreUpdated
    export namespace Event {
      /** Moved an account from one bag to another. */
      export function Rebagged(
        value: Omit<pallet_bags_list.pallet.Event.Rebagged, "type">,
      ): pallet_bags_list.pallet.Event.Rebagged {
        return { type: "Rebagged", ...value }
      }
      /** Moved an account from one bag to another. */
      export interface Rebagged {
        type: "Rebagged"
        who: sp_core.crypto.AccountId32
        from: u64
        to: u64
      }
      /** Updated the score of some account to the given amount. */
      export function ScoreUpdated(
        value: Omit<pallet_bags_list.pallet.Event.ScoreUpdated, "type">,
      ): pallet_bags_list.pallet.Event.ScoreUpdated {
        return { type: "ScoreUpdated", ...value }
      }
      /** Updated the score of some account to the given amount. */
      export interface ScoreUpdated {
        type: "ScoreUpdated"
        who: sp_core.crypto.AccountId32
        new_score: u64
      }
    }
  }
}
export namespace pallet_balances {
  export const $accountData: $.Codec<pallet_balances.AccountData> = _codec.$5
  export const $balanceLock: $.Codec<pallet_balances.BalanceLock> = _codec.$471
  export const $reasons: $.Codec<pallet_balances.Reasons> = _codec.$472
  export const $releases: $.Codec<pallet_balances.Releases> = _codec.$477
  export const $reserveData: $.Codec<pallet_balances.ReserveData> = _codec.$475
  export interface AccountData {
    free: u128
    reserved: u128
    misc_frozen: u128
    fee_frozen: u128
  }
  export function AccountData(value: pallet_balances.AccountData) {
    return value
  }
  export interface BalanceLock {
    id: Uint8Array
    amount: u128
    reasons: pallet_balances.Reasons
  }
  export function BalanceLock(value: pallet_balances.BalanceLock) {
    return value
  }
  export type Reasons = "Fee" | "Misc" | "All"
  export type Releases = "V1_0_0" | "V2_0_0"
  export interface ReserveData {
    id: Uint8Array
    amount: u128
  }
  export function ReserveData(value: pallet_balances.ReserveData) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_balances.pallet.Call> = _codec.$199
    export const $error: $.Codec<pallet_balances.pallet.Error> = _codec.$478
    export const $event: $.Codec<pallet_balances.pallet.Event> = _codec.$36
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_balances.pallet.Call.transfer
      | pallet_balances.pallet.Call.set_balance
      | pallet_balances.pallet.Call.force_transfer
      | pallet_balances.pallet.Call.transfer_keep_alive
      | pallet_balances.pallet.Call.transfer_all
      | pallet_balances.pallet.Call.force_unreserve
    export namespace Call {
      /**
       * Exactly as `transfer`, except the origin must be root and the source account may be
       * specified.
       * # <weight>
       * - Same as transfer, but additional read and write because the source account is not
       *   assumed to be in the overlay.
       * # </weight>
       */
      export function force_transfer(
        value: Omit<pallet_balances.pallet.Call.force_transfer, "type">,
      ): pallet_balances.pallet.Call.force_transfer {
        return { type: "force_transfer", ...value }
      }
      /**
       * Exactly as `transfer`, except the origin must be root and the source account may be
       * specified.
       * # <weight>
       * - Same as transfer, but additional read and write because the source account is not
       *   assumed to be in the overlay.
       * # </weight>
       */
      export interface force_transfer {
        type: "force_transfer"
        source: sp_runtime.multiaddress.MultiAddress
        dest: sp_runtime.multiaddress.MultiAddress
        value: Compact<u128>
      }
      /**
       * Unreserve some balance from a user by force.
       *
       * Can only be called by ROOT.
       */
      export function force_unreserve(
        value: Omit<pallet_balances.pallet.Call.force_unreserve, "type">,
      ): pallet_balances.pallet.Call.force_unreserve {
        return { type: "force_unreserve", ...value }
      }
      /**
       * Unreserve some balance from a user by force.
       *
       * Can only be called by ROOT.
       */
      export interface force_unreserve {
        type: "force_unreserve"
        who: sp_runtime.multiaddress.MultiAddress
        amount: u128
      }
      /**
       * Set the balances of a given account.
       *
       * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
       * also alter the total issuance of the system (`TotalIssuance`) appropriately.
       * If the new free or reserved balance is below the existential deposit,
       * it will reset the account nonce (`frame_system::AccountNonce`).
       *
       * The dispatch origin for this call is `root`.
       */
      export function set_balance(
        value: Omit<pallet_balances.pallet.Call.set_balance, "type">,
      ): pallet_balances.pallet.Call.set_balance {
        return { type: "set_balance", ...value }
      }
      /**
       * Set the balances of a given account.
       *
       * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
       * also alter the total issuance of the system (`TotalIssuance`) appropriately.
       * If the new free or reserved balance is below the existential deposit,
       * it will reset the account nonce (`frame_system::AccountNonce`).
       *
       * The dispatch origin for this call is `root`.
       */
      export interface set_balance {
        type: "set_balance"
        who: sp_runtime.multiaddress.MultiAddress
        new_free: Compact<u128>
        new_reserved: Compact<u128>
      }
      /**
       * Transfer some liquid free balance to another account.
       *
       * `transfer` will set the `FreeBalance` of the sender and receiver.
       * If the sender's account is below the existential deposit as a result
       * of the transfer, the account will be reaped.
       *
       * The dispatch origin for this call must be `Signed` by the transactor.
       *
       * # <weight>
       * - Dependent on arguments but not critical, given proper implementations for input config
       *   types. See related functions below.
       * - It contains a limited number of reads and writes internally and no complex
       *   computation.
       *
       * Related functions:
       *
       *   - `ensure_can_withdraw` is always called internally but has a bounded complexity.
       *   - Transferring balances to accounts that did not exist before will cause
       *     `T::OnNewAccount::on_new_account` to be called.
       *   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
       *   - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
       *     that the transfer will not kill the origin account.
       * ---------------------------------
       * - Origin account is already in memory, so no DB operations for them.
       * # </weight>
       */
      export function transfer(
        value: Omit<pallet_balances.pallet.Call.transfer, "type">,
      ): pallet_balances.pallet.Call.transfer {
        return { type: "transfer", ...value }
      }
      /**
       * Transfer some liquid free balance to another account.
       *
       * `transfer` will set the `FreeBalance` of the sender and receiver.
       * If the sender's account is below the existential deposit as a result
       * of the transfer, the account will be reaped.
       *
       * The dispatch origin for this call must be `Signed` by the transactor.
       *
       * # <weight>
       * - Dependent on arguments but not critical, given proper implementations for input config
       *   types. See related functions below.
       * - It contains a limited number of reads and writes internally and no complex
       *   computation.
       *
       * Related functions:
       *
       *   - `ensure_can_withdraw` is always called internally but has a bounded complexity.
       *   - Transferring balances to accounts that did not exist before will cause
       *     `T::OnNewAccount::on_new_account` to be called.
       *   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
       *   - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
       *     that the transfer will not kill the origin account.
       * ---------------------------------
       * - Origin account is already in memory, so no DB operations for them.
       * # </weight>
       */
      export interface transfer {
        type: "transfer"
        dest: sp_runtime.multiaddress.MultiAddress
        value: Compact<u128>
      }
      /**
       * Transfer the entire transferable balance from the caller account.
       *
       * NOTE: This function only attempts to transfer _transferable_ balances. This means that
       * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
       * transferred by this function. To ensure that this function results in a killed account,
       * you might need to prepare the account by removing any reference counters, storage
       * deposits, etc...
       *
       * The dispatch origin of this call must be Signed.
       *
       * - `dest`: The recipient of the transfer.
       * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
       *   of the funds the account has, causing the sender account to be killed (false), or
       *   transfer everything except at least the existential deposit, which will guarantee to
       *   keep the sender account alive (true). # <weight>
       * - O(1). Just like transfer, but reading the user's transferable balance first.
       *   #</weight>
       */
      export function transfer_all(
        value: Omit<pallet_balances.pallet.Call.transfer_all, "type">,
      ): pallet_balances.pallet.Call.transfer_all {
        return { type: "transfer_all", ...value }
      }
      /**
       * Transfer the entire transferable balance from the caller account.
       *
       * NOTE: This function only attempts to transfer _transferable_ balances. This means that
       * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
       * transferred by this function. To ensure that this function results in a killed account,
       * you might need to prepare the account by removing any reference counters, storage
       * deposits, etc...
       *
       * The dispatch origin of this call must be Signed.
       *
       * - `dest`: The recipient of the transfer.
       * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
       *   of the funds the account has, causing the sender account to be killed (false), or
       *   transfer everything except at least the existential deposit, which will guarantee to
       *   keep the sender account alive (true). # <weight>
       * - O(1). Just like transfer, but reading the user's transferable balance first.
       *   #</weight>
       */
      export interface transfer_all {
        type: "transfer_all"
        dest: sp_runtime.multiaddress.MultiAddress
        keep_alive: boolean
      }
      /**
       * Same as the [`transfer`] call, but with a check that the transfer will not kill the
       * origin account.
       *
       * 99% of the time you want [`transfer`] instead.
       *
       * [`transfer`]: struct.Pallet.html#method.transfer
       */
      export function transfer_keep_alive(
        value: Omit<pallet_balances.pallet.Call.transfer_keep_alive, "type">,
      ): pallet_balances.pallet.Call.transfer_keep_alive {
        return { type: "transfer_keep_alive", ...value }
      }
      /**
       * Same as the [`transfer`] call, but with a check that the transfer will not kill the
       * origin account.
       *
       * 99% of the time you want [`transfer`] instead.
       *
       * [`transfer`]: struct.Pallet.html#method.transfer
       */
      export interface transfer_keep_alive {
        type: "transfer_keep_alive"
        dest: sp_runtime.multiaddress.MultiAddress
        value: Compact<u128>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "VestingBalance"
      | "LiquidityRestrictions"
      | "InsufficientBalance"
      | "ExistentialDeposit"
      | "KeepAlive"
      | "ExistingVestingSchedule"
      | "DeadAccount"
      | "TooManyReserves"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_balances.pallet.Event.Endowed
      | pallet_balances.pallet.Event.DustLost
      | pallet_balances.pallet.Event.Transfer
      | pallet_balances.pallet.Event.BalanceSet
      | pallet_balances.pallet.Event.Reserved
      | pallet_balances.pallet.Event.Unreserved
      | pallet_balances.pallet.Event.ReserveRepatriated
      | pallet_balances.pallet.Event.Deposit
      | pallet_balances.pallet.Event.Withdraw
      | pallet_balances.pallet.Event.Slashed
    export namespace Event {
      /** A balance was set by root. */
      export function BalanceSet(
        value: Omit<pallet_balances.pallet.Event.BalanceSet, "type">,
      ): pallet_balances.pallet.Event.BalanceSet {
        return { type: "BalanceSet", ...value }
      }
      /** A balance was set by root. */
      export interface BalanceSet {
        type: "BalanceSet"
        who: sp_core.crypto.AccountId32
        free: u128
        reserved: u128
      }
      /** Some amount was deposited (e.g. for transaction fees). */
      export function Deposit(
        value: Omit<pallet_balances.pallet.Event.Deposit, "type">,
      ): pallet_balances.pallet.Event.Deposit {
        return { type: "Deposit", ...value }
      }
      /** Some amount was deposited (e.g. for transaction fees). */
      export interface Deposit {
        type: "Deposit"
        who: sp_core.crypto.AccountId32
        amount: u128
      }
      /**
       * An account was removed whose balance was non-zero but below ExistentialDeposit,
       * resulting in an outright loss.
       */
      export function DustLost(
        value: Omit<pallet_balances.pallet.Event.DustLost, "type">,
      ): pallet_balances.pallet.Event.DustLost {
        return { type: "DustLost", ...value }
      }
      /**
       * An account was removed whose balance was non-zero but below ExistentialDeposit,
       * resulting in an outright loss.
       */
      export interface DustLost {
        type: "DustLost"
        account: sp_core.crypto.AccountId32
        amount: u128
      }
      /** An account was created with some free balance. */
      export function Endowed(
        value: Omit<pallet_balances.pallet.Event.Endowed, "type">,
      ): pallet_balances.pallet.Event.Endowed {
        return { type: "Endowed", ...value }
      }
      /** An account was created with some free balance. */
      export interface Endowed {
        type: "Endowed"
        account: sp_core.crypto.AccountId32
        free_balance: u128
      }
      /**
       * Some balance was moved from the reserve of the first account to the second account.
       * Final argument indicates the destination balance type.
       */
      export function ReserveRepatriated(
        value: Omit<pallet_balances.pallet.Event.ReserveRepatriated, "type">,
      ): pallet_balances.pallet.Event.ReserveRepatriated {
        return { type: "ReserveRepatriated", ...value }
      }
      /**
       * Some balance was moved from the reserve of the first account to the second account.
       * Final argument indicates the destination balance type.
       */
      export interface ReserveRepatriated {
        type: "ReserveRepatriated"
        from: sp_core.crypto.AccountId32
        to: sp_core.crypto.AccountId32
        amount: u128
        destination_status: frame_support.traits.tokens.misc.BalanceStatus
      }
      /** Some balance was reserved (moved from free to reserved). */
      export function Reserved(
        value: Omit<pallet_balances.pallet.Event.Reserved, "type">,
      ): pallet_balances.pallet.Event.Reserved {
        return { type: "Reserved", ...value }
      }
      /** Some balance was reserved (moved from free to reserved). */
      export interface Reserved {
        type: "Reserved"
        who: sp_core.crypto.AccountId32
        amount: u128
      }
      /** Some amount was removed from the account (e.g. for misbehavior). */
      export function Slashed(
        value: Omit<pallet_balances.pallet.Event.Slashed, "type">,
      ): pallet_balances.pallet.Event.Slashed {
        return { type: "Slashed", ...value }
      }
      /** Some amount was removed from the account (e.g. for misbehavior). */
      export interface Slashed {
        type: "Slashed"
        who: sp_core.crypto.AccountId32
        amount: u128
      }
      /** Transfer succeeded. */
      export function Transfer(
        value: Omit<pallet_balances.pallet.Event.Transfer, "type">,
      ): pallet_balances.pallet.Event.Transfer {
        return { type: "Transfer", ...value }
      }
      /** Transfer succeeded. */
      export interface Transfer {
        type: "Transfer"
        from: sp_core.crypto.AccountId32
        to: sp_core.crypto.AccountId32
        amount: u128
      }
      /** Some balance was unreserved (moved from reserved to free). */
      export function Unreserved(
        value: Omit<pallet_balances.pallet.Event.Unreserved, "type">,
      ): pallet_balances.pallet.Event.Unreserved {
        return { type: "Unreserved", ...value }
      }
      /** Some balance was unreserved (moved from reserved to free). */
      export interface Unreserved {
        type: "Unreserved"
        who: sp_core.crypto.AccountId32
        amount: u128
      }
      /** Some amount was withdrawn from the account (e.g. for transaction fees). */
      export function Withdraw(
        value: Omit<pallet_balances.pallet.Event.Withdraw, "type">,
      ): pallet_balances.pallet.Event.Withdraw {
        return { type: "Withdraw", ...value }
      }
      /** Some amount was withdrawn from the account (e.g. for transaction fees). */
      export interface Withdraw {
        type: "Withdraw"
        who: sp_core.crypto.AccountId32
        amount: u128
      }
    }
  }
}
export namespace pallet_bounties {
  export const $bounty: $.Codec<pallet_bounties.Bounty> = _codec.$591
  export const $bountyStatus: $.Codec<pallet_bounties.BountyStatus> = _codec.$592
  export interface Bounty {
    proposer: sp_core.crypto.AccountId32
    value: u128
    fee: u128
    curator_deposit: u128
    bond: u128
    status: pallet_bounties.BountyStatus
  }
  export function Bounty(value: pallet_bounties.Bounty) {
    return value
  }
  export type BountyStatus =
    | pallet_bounties.BountyStatus.Proposed
    | pallet_bounties.BountyStatus.Approved
    | pallet_bounties.BountyStatus.Funded
    | pallet_bounties.BountyStatus.CuratorProposed
    | pallet_bounties.BountyStatus.Active
    | pallet_bounties.BountyStatus.PendingPayout
  export namespace BountyStatus {
    export function Active(
      value: Omit<pallet_bounties.BountyStatus.Active, "type">,
    ): pallet_bounties.BountyStatus.Active {
      return { type: "Active", ...value }
    }
    export interface Active {
      type: "Active"
      curator: sp_core.crypto.AccountId32
      update_due: u32
    }
    export function Approved(): pallet_bounties.BountyStatus.Approved {
      return { type: "Approved" }
    }
    export interface Approved {
      type: "Approved"
    }
    export function CuratorProposed(
      value: Omit<pallet_bounties.BountyStatus.CuratorProposed, "type">,
    ): pallet_bounties.BountyStatus.CuratorProposed {
      return { type: "CuratorProposed", ...value }
    }
    export interface CuratorProposed {
      type: "CuratorProposed"
      curator: sp_core.crypto.AccountId32
    }
    export function Funded(): pallet_bounties.BountyStatus.Funded {
      return { type: "Funded" }
    }
    export interface Funded {
      type: "Funded"
    }
    export function PendingPayout(
      value: Omit<pallet_bounties.BountyStatus.PendingPayout, "type">,
    ): pallet_bounties.BountyStatus.PendingPayout {
      return { type: "PendingPayout", ...value }
    }
    export interface PendingPayout {
      type: "PendingPayout"
      curator: sp_core.crypto.AccountId32
      beneficiary: sp_core.crypto.AccountId32
      unlock_at: u32
    }
    export function Proposed(): pallet_bounties.BountyStatus.Proposed {
      return { type: "Proposed" }
    }
    export interface Proposed {
      type: "Proposed"
    }
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_bounties.pallet.Call> = _codec.$307
    export const $error: $.Codec<pallet_bounties.pallet.Error> = _codec.$594
    export const $event: $.Codec<pallet_bounties.pallet.Event> = _codec.$83
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_bounties.pallet.Call.propose_bounty
      | pallet_bounties.pallet.Call.approve_bounty
      | pallet_bounties.pallet.Call.propose_curator
      | pallet_bounties.pallet.Call.unassign_curator
      | pallet_bounties.pallet.Call.accept_curator
      | pallet_bounties.pallet.Call.award_bounty
      | pallet_bounties.pallet.Call.claim_bounty
      | pallet_bounties.pallet.Call.close_bounty
      | pallet_bounties.pallet.Call.extend_bounty_expiry
    export namespace Call {
      /**
       * Accept the curator role for a bounty.
       * A deposit will be reserved from curator and refund upon successful payout.
       *
       * May only be called from the curator.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function accept_curator(
        value: Omit<pallet_bounties.pallet.Call.accept_curator, "type">,
      ): pallet_bounties.pallet.Call.accept_curator {
        return { type: "accept_curator", ...value }
      }
      /**
       * Accept the curator role for a bounty.
       * A deposit will be reserved from curator and refund upon successful payout.
       *
       * May only be called from the curator.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface accept_curator {
        type: "accept_curator"
        bounty_id: Compact<u32>
      }
      /**
       * Approve a bounty proposal. At a later time, the bounty will be funded and become active
       * and the original deposit will be returned.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function approve_bounty(
        value: Omit<pallet_bounties.pallet.Call.approve_bounty, "type">,
      ): pallet_bounties.pallet.Call.approve_bounty {
        return { type: "approve_bounty", ...value }
      }
      /**
       * Approve a bounty proposal. At a later time, the bounty will be funded and become active
       * and the original deposit will be returned.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface approve_bounty {
        type: "approve_bounty"
        bounty_id: Compact<u32>
      }
      /**
       * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
       * after a delay.
       *
       * The dispatch origin for this call must be the curator of this bounty.
       *
       * - `bounty_id`: Bounty ID to award.
       * - `beneficiary`: The beneficiary account whom will receive the payout.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function award_bounty(
        value: Omit<pallet_bounties.pallet.Call.award_bounty, "type">,
      ): pallet_bounties.pallet.Call.award_bounty {
        return { type: "award_bounty", ...value }
      }
      /**
       * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
       * after a delay.
       *
       * The dispatch origin for this call must be the curator of this bounty.
       *
       * - `bounty_id`: Bounty ID to award.
       * - `beneficiary`: The beneficiary account whom will receive the payout.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface award_bounty {
        type: "award_bounty"
        bounty_id: Compact<u32>
        beneficiary: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Claim the payout from an awarded bounty after payout delay.
       *
       * The dispatch origin for this call must be the beneficiary of this bounty.
       *
       * - `bounty_id`: Bounty ID to claim.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function claim_bounty(
        value: Omit<pallet_bounties.pallet.Call.claim_bounty, "type">,
      ): pallet_bounties.pallet.Call.claim_bounty {
        return { type: "claim_bounty", ...value }
      }
      /**
       * Claim the payout from an awarded bounty after payout delay.
       *
       * The dispatch origin for this call must be the beneficiary of this bounty.
       *
       * - `bounty_id`: Bounty ID to claim.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface claim_bounty {
        type: "claim_bounty"
        bounty_id: Compact<u32>
      }
      /**
       * Cancel a proposed or active bounty. All the funds will be sent to treasury and
       * the curator deposit will be unreserved if possible.
       *
       * Only `T::RejectOrigin` is able to cancel a bounty.
       *
       * - `bounty_id`: Bounty ID to cancel.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function close_bounty(
        value: Omit<pallet_bounties.pallet.Call.close_bounty, "type">,
      ): pallet_bounties.pallet.Call.close_bounty {
        return { type: "close_bounty", ...value }
      }
      /**
       * Cancel a proposed or active bounty. All the funds will be sent to treasury and
       * the curator deposit will be unreserved if possible.
       *
       * Only `T::RejectOrigin` is able to cancel a bounty.
       *
       * - `bounty_id`: Bounty ID to cancel.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface close_bounty {
        type: "close_bounty"
        bounty_id: Compact<u32>
      }
      /**
       * Extend the expiry time of an active bounty.
       *
       * The dispatch origin for this call must be the curator of this bounty.
       *
       * - `bounty_id`: Bounty ID to extend.
       * - `remark`: additional information.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function extend_bounty_expiry(
        value: Omit<pallet_bounties.pallet.Call.extend_bounty_expiry, "type">,
      ): pallet_bounties.pallet.Call.extend_bounty_expiry {
        return { type: "extend_bounty_expiry", ...value }
      }
      /**
       * Extend the expiry time of an active bounty.
       *
       * The dispatch origin for this call must be the curator of this bounty.
       *
       * - `bounty_id`: Bounty ID to extend.
       * - `remark`: additional information.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface extend_bounty_expiry {
        type: "extend_bounty_expiry"
        bounty_id: Compact<u32>
        remark: Uint8Array
      }
      /**
       * Propose a new bounty.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
       * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
       * or slashed when rejected.
       *
       * - `curator`: The curator account whom will manage this bounty.
       * - `fee`: The curator fee.
       * - `value`: The total payment amount of this bounty, curator fee included.
       * - `description`: The description of this bounty.
       */
      export function propose_bounty(
        value: Omit<pallet_bounties.pallet.Call.propose_bounty, "type">,
      ): pallet_bounties.pallet.Call.propose_bounty {
        return { type: "propose_bounty", ...value }
      }
      /**
       * Propose a new bounty.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
       * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
       * or slashed when rejected.
       *
       * - `curator`: The curator account whom will manage this bounty.
       * - `fee`: The curator fee.
       * - `value`: The total payment amount of this bounty, curator fee included.
       * - `description`: The description of this bounty.
       */
      export interface propose_bounty {
        type: "propose_bounty"
        value: Compact<u128>
        description: Uint8Array
      }
      /**
       * Assign a curator to a funded bounty.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function propose_curator(
        value: Omit<pallet_bounties.pallet.Call.propose_curator, "type">,
      ): pallet_bounties.pallet.Call.propose_curator {
        return { type: "propose_curator", ...value }
      }
      /**
       * Assign a curator to a funded bounty.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface propose_curator {
        type: "propose_curator"
        bounty_id: Compact<u32>
        curator: sp_runtime.multiaddress.MultiAddress
        fee: Compact<u128>
      }
      /**
       * Unassign curator from a bounty.
       *
       * This function can only be called by the `RejectOrigin` a signed origin.
       *
       * If this function is called by the `RejectOrigin`, we assume that the curator is
       * malicious or inactive. As a result, we will slash the curator when possible.
       *
       * If the origin is the curator, we take this as a sign they are unable to do their job and
       * they willingly give up. We could slash them, but for now we allow them to recover their
       * deposit and exit without issue. (We may want to change this if it is abused.)
       *
       * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
       * anyone in the community to call out that a curator is not doing their due diligence, and
       * we should pick a new curator. In this case the curator should also be slashed.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export function unassign_curator(
        value: Omit<pallet_bounties.pallet.Call.unassign_curator, "type">,
      ): pallet_bounties.pallet.Call.unassign_curator {
        return { type: "unassign_curator", ...value }
      }
      /**
       * Unassign curator from a bounty.
       *
       * This function can only be called by the `RejectOrigin` a signed origin.
       *
       * If this function is called by the `RejectOrigin`, we assume that the curator is
       * malicious or inactive. As a result, we will slash the curator when possible.
       *
       * If the origin is the curator, we take this as a sign they are unable to do their job and
       * they willingly give up. We could slash them, but for now we allow them to recover their
       * deposit and exit without issue. (We may want to change this if it is abused.)
       *
       * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
       * anyone in the community to call out that a curator is not doing their due diligence, and
       * we should pick a new curator. In this case the curator should also be slashed.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       */
      export interface unassign_curator {
        type: "unassign_curator"
        bounty_id: Compact<u32>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "InsufficientProposersBalance"
      | "InvalidIndex"
      | "ReasonTooBig"
      | "UnexpectedStatus"
      | "RequireCurator"
      | "InvalidValue"
      | "InvalidFee"
      | "PendingPayout"
      | "Premature"
      | "HasActiveChildBounty"
      | "TooManyQueued"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_bounties.pallet.Event.BountyProposed
      | pallet_bounties.pallet.Event.BountyRejected
      | pallet_bounties.pallet.Event.BountyBecameActive
      | pallet_bounties.pallet.Event.BountyAwarded
      | pallet_bounties.pallet.Event.BountyClaimed
      | pallet_bounties.pallet.Event.BountyCanceled
      | pallet_bounties.pallet.Event.BountyExtended
    export namespace Event {
      /** A bounty is awarded to a beneficiary. */
      export function BountyAwarded(
        value: Omit<pallet_bounties.pallet.Event.BountyAwarded, "type">,
      ): pallet_bounties.pallet.Event.BountyAwarded {
        return { type: "BountyAwarded", ...value }
      }
      /** A bounty is awarded to a beneficiary. */
      export interface BountyAwarded {
        type: "BountyAwarded"
        index: u32
        beneficiary: sp_core.crypto.AccountId32
      }
      /** A bounty proposal is funded and became active. */
      export function BountyBecameActive(
        value: Omit<pallet_bounties.pallet.Event.BountyBecameActive, "type">,
      ): pallet_bounties.pallet.Event.BountyBecameActive {
        return { type: "BountyBecameActive", ...value }
      }
      /** A bounty proposal is funded and became active. */
      export interface BountyBecameActive {
        type: "BountyBecameActive"
        index: u32
      }
      /** A bounty is cancelled. */
      export function BountyCanceled(
        value: Omit<pallet_bounties.pallet.Event.BountyCanceled, "type">,
      ): pallet_bounties.pallet.Event.BountyCanceled {
        return { type: "BountyCanceled", ...value }
      }
      /** A bounty is cancelled. */
      export interface BountyCanceled {
        type: "BountyCanceled"
        index: u32
      }
      /** A bounty is claimed by beneficiary. */
      export function BountyClaimed(
        value: Omit<pallet_bounties.pallet.Event.BountyClaimed, "type">,
      ): pallet_bounties.pallet.Event.BountyClaimed {
        return { type: "BountyClaimed", ...value }
      }
      /** A bounty is claimed by beneficiary. */
      export interface BountyClaimed {
        type: "BountyClaimed"
        index: u32
        payout: u128
        beneficiary: sp_core.crypto.AccountId32
      }
      /** A bounty expiry is extended. */
      export function BountyExtended(
        value: Omit<pallet_bounties.pallet.Event.BountyExtended, "type">,
      ): pallet_bounties.pallet.Event.BountyExtended {
        return { type: "BountyExtended", ...value }
      }
      /** A bounty expiry is extended. */
      export interface BountyExtended {
        type: "BountyExtended"
        index: u32
      }
      /** New bounty proposal. */
      export function BountyProposed(
        value: Omit<pallet_bounties.pallet.Event.BountyProposed, "type">,
      ): pallet_bounties.pallet.Event.BountyProposed {
        return { type: "BountyProposed", ...value }
      }
      /** New bounty proposal. */
      export interface BountyProposed {
        type: "BountyProposed"
        index: u32
      }
      /** A bounty proposal was rejected; funds were slashed. */
      export function BountyRejected(
        value: Omit<pallet_bounties.pallet.Event.BountyRejected, "type">,
      ): pallet_bounties.pallet.Event.BountyRejected {
        return { type: "BountyRejected", ...value }
      }
      /** A bounty proposal was rejected; funds were slashed. */
      export interface BountyRejected {
        type: "BountyRejected"
        index: u32
        bond: u128
      }
    }
  }
}
export namespace pallet_child_bounties {
  export const $childBounty: $.Codec<pallet_child_bounties.ChildBounty> = _codec.$595
  export const $childBountyStatus: $.Codec<pallet_child_bounties.ChildBountyStatus> = _codec.$596
  export interface ChildBounty {
    parent_bounty: u32
    value: u128
    fee: u128
    curator_deposit: u128
    status: pallet_child_bounties.ChildBountyStatus
  }
  export function ChildBounty(value: pallet_child_bounties.ChildBounty) {
    return value
  }
  export type ChildBountyStatus =
    | pallet_child_bounties.ChildBountyStatus.Added
    | pallet_child_bounties.ChildBountyStatus.CuratorProposed
    | pallet_child_bounties.ChildBountyStatus.Active
    | pallet_child_bounties.ChildBountyStatus.PendingPayout
  export namespace ChildBountyStatus {
    export function Active(
      value: Omit<pallet_child_bounties.ChildBountyStatus.Active, "type">,
    ): pallet_child_bounties.ChildBountyStatus.Active {
      return { type: "Active", ...value }
    }
    export interface Active {
      type: "Active"
      curator: sp_core.crypto.AccountId32
    }
    export function Added(): pallet_child_bounties.ChildBountyStatus.Added {
      return { type: "Added" }
    }
    export interface Added {
      type: "Added"
    }
    export function CuratorProposed(
      value: Omit<pallet_child_bounties.ChildBountyStatus.CuratorProposed, "type">,
    ): pallet_child_bounties.ChildBountyStatus.CuratorProposed {
      return { type: "CuratorProposed", ...value }
    }
    export interface CuratorProposed {
      type: "CuratorProposed"
      curator: sp_core.crypto.AccountId32
    }
    export function PendingPayout(
      value: Omit<pallet_child_bounties.ChildBountyStatus.PendingPayout, "type">,
    ): pallet_child_bounties.ChildBountyStatus.PendingPayout {
      return { type: "PendingPayout", ...value }
    }
    export interface PendingPayout {
      type: "PendingPayout"
      curator: sp_core.crypto.AccountId32
      beneficiary: sp_core.crypto.AccountId32
      unlock_at: u32
    }
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_child_bounties.pallet.Call> = _codec.$308
    export const $error: $.Codec<pallet_child_bounties.pallet.Error> = _codec.$597
    export const $event: $.Codec<pallet_child_bounties.pallet.Event> = _codec.$84
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_child_bounties.pallet.Call.add_child_bounty
      | pallet_child_bounties.pallet.Call.propose_curator
      | pallet_child_bounties.pallet.Call.accept_curator
      | pallet_child_bounties.pallet.Call.unassign_curator
      | pallet_child_bounties.pallet.Call.award_child_bounty
      | pallet_child_bounties.pallet.Call.claim_child_bounty
      | pallet_child_bounties.pallet.Call.close_child_bounty
    export namespace Call {
      /**
       * Accept the curator role for the child-bounty.
       *
       * The dispatch origin for this call must be the curator of this
       * child-bounty.
       *
       * A deposit will be reserved from the curator and refund upon
       * successful payout or cancellation.
       *
       * Fee for curator is deducted from curator fee of parent bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in "CuratorProposed" state, for processing the
       * call. And state of child-bounty is moved to "Active" on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export function accept_curator(
        value: Omit<pallet_child_bounties.pallet.Call.accept_curator, "type">,
      ): pallet_child_bounties.pallet.Call.accept_curator {
        return { type: "accept_curator", ...value }
      }
      /**
       * Accept the curator role for the child-bounty.
       *
       * The dispatch origin for this call must be the curator of this
       * child-bounty.
       *
       * A deposit will be reserved from the curator and refund upon
       * successful payout or cancellation.
       *
       * Fee for curator is deducted from curator fee of parent bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in "CuratorProposed" state, for processing the
       * call. And state of child-bounty is moved to "Active" on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export interface accept_curator {
        type: "accept_curator"
        parent_bounty_id: Compact<u32>
        child_bounty_id: Compact<u32>
      }
      /**
       * Add a new child-bounty.
       *
       * The dispatch origin for this call must be the curator of parent
       * bounty and the parent bounty must be in "active" state.
       *
       * Child-bounty gets added successfully & fund gets transferred from
       * parent bounty to child-bounty account, if parent bounty has enough
       * funds, else the call fails.
       *
       * Upper bound to maximum number of active  child bounties that can be
       * added are managed via runtime trait config
       * [`Config::MaxActiveChildBountyCount`].
       *
       * If the call is success, the status of child-bounty is updated to
       * "Added".
       *
       * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
       * - `value`: Value for executing the proposal.
       * - `description`: Text description for the child-bounty.
       */
      export function add_child_bounty(
        value: Omit<pallet_child_bounties.pallet.Call.add_child_bounty, "type">,
      ): pallet_child_bounties.pallet.Call.add_child_bounty {
        return { type: "add_child_bounty", ...value }
      }
      /**
       * Add a new child-bounty.
       *
       * The dispatch origin for this call must be the curator of parent
       * bounty and the parent bounty must be in "active" state.
       *
       * Child-bounty gets added successfully & fund gets transferred from
       * parent bounty to child-bounty account, if parent bounty has enough
       * funds, else the call fails.
       *
       * Upper bound to maximum number of active  child bounties that can be
       * added are managed via runtime trait config
       * [`Config::MaxActiveChildBountyCount`].
       *
       * If the call is success, the status of child-bounty is updated to
       * "Added".
       *
       * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
       * - `value`: Value for executing the proposal.
       * - `description`: Text description for the child-bounty.
       */
      export interface add_child_bounty {
        type: "add_child_bounty"
        parent_bounty_id: Compact<u32>
        value: Compact<u128>
        description: Uint8Array
      }
      /**
       * Award child-bounty to a beneficiary.
       *
       * The beneficiary will be able to claim the funds after a delay.
       *
       * The dispatch origin for this call must be the parent curator or
       * curator of this child-bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in active state, for processing the call. And
       * state of child-bounty is moved to "PendingPayout" on successful call
       * completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       * - `beneficiary`: Beneficiary account.
       */
      export function award_child_bounty(
        value: Omit<pallet_child_bounties.pallet.Call.award_child_bounty, "type">,
      ): pallet_child_bounties.pallet.Call.award_child_bounty {
        return { type: "award_child_bounty", ...value }
      }
      /**
       * Award child-bounty to a beneficiary.
       *
       * The beneficiary will be able to claim the funds after a delay.
       *
       * The dispatch origin for this call must be the parent curator or
       * curator of this child-bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in active state, for processing the call. And
       * state of child-bounty is moved to "PendingPayout" on successful call
       * completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       * - `beneficiary`: Beneficiary account.
       */
      export interface award_child_bounty {
        type: "award_child_bounty"
        parent_bounty_id: Compact<u32>
        child_bounty_id: Compact<u32>
        beneficiary: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Claim the payout from an awarded child-bounty after payout delay.
       *
       * The dispatch origin for this call may be any signed origin.
       *
       * Call works independent of parent bounty state, No need for parent
       * bounty to be in active state.
       *
       * The Beneficiary is paid out with agreed bounty value. Curator fee is
       * paid & curator deposit is unreserved.
       *
       * Child-bounty must be in "PendingPayout" state, for processing the
       * call. And instance of child-bounty is removed from the state on
       * successful call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export function claim_child_bounty(
        value: Omit<pallet_child_bounties.pallet.Call.claim_child_bounty, "type">,
      ): pallet_child_bounties.pallet.Call.claim_child_bounty {
        return { type: "claim_child_bounty", ...value }
      }
      /**
       * Claim the payout from an awarded child-bounty after payout delay.
       *
       * The dispatch origin for this call may be any signed origin.
       *
       * Call works independent of parent bounty state, No need for parent
       * bounty to be in active state.
       *
       * The Beneficiary is paid out with agreed bounty value. Curator fee is
       * paid & curator deposit is unreserved.
       *
       * Child-bounty must be in "PendingPayout" state, for processing the
       * call. And instance of child-bounty is removed from the state on
       * successful call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export interface claim_child_bounty {
        type: "claim_child_bounty"
        parent_bounty_id: Compact<u32>
        child_bounty_id: Compact<u32>
      }
      /**
       * Cancel a proposed or active child-bounty. Child-bounty account funds
       * are transferred to parent bounty account. The child-bounty curator
       * deposit may be unreserved if possible.
       *
       * The dispatch origin for this call must be either parent curator or
       * `T::RejectOrigin`.
       *
       * If the state of child-bounty is `Active`, curator deposit is
       * unreserved.
       *
       * If the state of child-bounty is `PendingPayout`, call fails &
       * returns `PendingPayout` error.
       *
       * For the origin other than T::RejectOrigin, parent bounty must be in
       * active state, for this child-bounty call to work. For origin
       * T::RejectOrigin execution is forced.
       *
       * Instance of child-bounty is removed from the state on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export function close_child_bounty(
        value: Omit<pallet_child_bounties.pallet.Call.close_child_bounty, "type">,
      ): pallet_child_bounties.pallet.Call.close_child_bounty {
        return { type: "close_child_bounty", ...value }
      }
      /**
       * Cancel a proposed or active child-bounty. Child-bounty account funds
       * are transferred to parent bounty account. The child-bounty curator
       * deposit may be unreserved if possible.
       *
       * The dispatch origin for this call must be either parent curator or
       * `T::RejectOrigin`.
       *
       * If the state of child-bounty is `Active`, curator deposit is
       * unreserved.
       *
       * If the state of child-bounty is `PendingPayout`, call fails &
       * returns `PendingPayout` error.
       *
       * For the origin other than T::RejectOrigin, parent bounty must be in
       * active state, for this child-bounty call to work. For origin
       * T::RejectOrigin execution is forced.
       *
       * Instance of child-bounty is removed from the state on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export interface close_child_bounty {
        type: "close_child_bounty"
        parent_bounty_id: Compact<u32>
        child_bounty_id: Compact<u32>
      }
      /**
       * Propose curator for funded child-bounty.
       *
       * The dispatch origin for this call must be curator of parent bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in "Added" state, for processing the call. And
       * state of child-bounty is moved to "CuratorProposed" on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       * - `curator`: Address of child-bounty curator.
       * - `fee`: payment fee to child-bounty curator for execution.
       */
      export function propose_curator(
        value: Omit<pallet_child_bounties.pallet.Call.propose_curator, "type">,
      ): pallet_child_bounties.pallet.Call.propose_curator {
        return { type: "propose_curator", ...value }
      }
      /**
       * Propose curator for funded child-bounty.
       *
       * The dispatch origin for this call must be curator of parent bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in "Added" state, for processing the call. And
       * state of child-bounty is moved to "CuratorProposed" on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       * - `curator`: Address of child-bounty curator.
       * - `fee`: payment fee to child-bounty curator for execution.
       */
      export interface propose_curator {
        type: "propose_curator"
        parent_bounty_id: Compact<u32>
        child_bounty_id: Compact<u32>
        curator: sp_runtime.multiaddress.MultiAddress
        fee: Compact<u128>
      }
      /**
       * Unassign curator from a child-bounty.
       *
       * The dispatch origin for this call can be either `RejectOrigin`, or
       * the curator of the parent bounty, or any signed origin.
       *
       * For the origin other than T::RejectOrigin and the child-bounty
       * curator, parent bounty must be in active state, for this call to
       * work. We allow child-bounty curator and T::RejectOrigin to execute
       * this call irrespective of the parent bounty state.
       *
       * If this function is called by the `RejectOrigin` or the
       * parent bounty curator, we assume that the child-bounty curator is
       * malicious or inactive. As a result, child-bounty curator deposit is
       * slashed.
       *
       * If the origin is the child-bounty curator, we take this as a sign
       * that they are unable to do their job, and are willingly giving up.
       * We could slash the deposit, but for now we allow them to unreserve
       * their deposit and exit without issue. (We may want to change this if
       * it is abused.)
       *
       * Finally, the origin can be anyone iff the child-bounty curator is
       * "inactive". Expiry update due of parent bounty is used to estimate
       * inactive state of child-bounty curator.
       *
       * This allows anyone in the community to call out that a child-bounty
       * curator is not doing their due diligence, and we should pick a new
       * one. In this case the child-bounty curator deposit is slashed.
       *
       * State of child-bounty is moved to Added state on successful call
       * completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export function unassign_curator(
        value: Omit<pallet_child_bounties.pallet.Call.unassign_curator, "type">,
      ): pallet_child_bounties.pallet.Call.unassign_curator {
        return { type: "unassign_curator", ...value }
      }
      /**
       * Unassign curator from a child-bounty.
       *
       * The dispatch origin for this call can be either `RejectOrigin`, or
       * the curator of the parent bounty, or any signed origin.
       *
       * For the origin other than T::RejectOrigin and the child-bounty
       * curator, parent bounty must be in active state, for this call to
       * work. We allow child-bounty curator and T::RejectOrigin to execute
       * this call irrespective of the parent bounty state.
       *
       * If this function is called by the `RejectOrigin` or the
       * parent bounty curator, we assume that the child-bounty curator is
       * malicious or inactive. As a result, child-bounty curator deposit is
       * slashed.
       *
       * If the origin is the child-bounty curator, we take this as a sign
       * that they are unable to do their job, and are willingly giving up.
       * We could slash the deposit, but for now we allow them to unreserve
       * their deposit and exit without issue. (We may want to change this if
       * it is abused.)
       *
       * Finally, the origin can be anyone iff the child-bounty curator is
       * "inactive". Expiry update due of parent bounty is used to estimate
       * inactive state of child-bounty curator.
       *
       * This allows anyone in the community to call out that a child-bounty
       * curator is not doing their due diligence, and we should pick a new
       * one. In this case the child-bounty curator deposit is slashed.
       *
       * State of child-bounty is moved to Added state on successful call
       * completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       */
      export interface unassign_curator {
        type: "unassign_curator"
        parent_bounty_id: Compact<u32>
        child_bounty_id: Compact<u32>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "ParentBountyNotActive"
      | "InsufficientBountyBalance"
      | "TooManyChildBounties"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_child_bounties.pallet.Event.Added
      | pallet_child_bounties.pallet.Event.Awarded
      | pallet_child_bounties.pallet.Event.Claimed
      | pallet_child_bounties.pallet.Event.Canceled
    export namespace Event {
      /** A child-bounty is added. */
      export function Added(
        value: Omit<pallet_child_bounties.pallet.Event.Added, "type">,
      ): pallet_child_bounties.pallet.Event.Added {
        return { type: "Added", ...value }
      }
      /** A child-bounty is added. */
      export interface Added {
        type: "Added"
        index: u32
        child_index: u32
      }
      /** A child-bounty is awarded to a beneficiary. */
      export function Awarded(
        value: Omit<pallet_child_bounties.pallet.Event.Awarded, "type">,
      ): pallet_child_bounties.pallet.Event.Awarded {
        return { type: "Awarded", ...value }
      }
      /** A child-bounty is awarded to a beneficiary. */
      export interface Awarded {
        type: "Awarded"
        index: u32
        child_index: u32
        beneficiary: sp_core.crypto.AccountId32
      }
      /** A child-bounty is cancelled. */
      export function Canceled(
        value: Omit<pallet_child_bounties.pallet.Event.Canceled, "type">,
      ): pallet_child_bounties.pallet.Event.Canceled {
        return { type: "Canceled", ...value }
      }
      /** A child-bounty is cancelled. */
      export interface Canceled {
        type: "Canceled"
        index: u32
        child_index: u32
      }
      /** A child-bounty is claimed by beneficiary. */
      export function Claimed(
        value: Omit<pallet_child_bounties.pallet.Event.Claimed, "type">,
      ): pallet_child_bounties.pallet.Event.Claimed {
        return { type: "Claimed", ...value }
      }
      /** A child-bounty is claimed by beneficiary. */
      export interface Claimed {
        type: "Claimed"
        index: u32
        child_index: u32
        payout: u128
        beneficiary: sp_core.crypto.AccountId32
      }
    }
  }
}
export namespace pallet_collective {
  export const $rawOrigin: $.Codec<pallet_collective.RawOrigin> = _codec.$258
  export const $votes: $.Codec<pallet_collective.Votes> = _codec.$546
  export type RawOrigin =
    | pallet_collective.RawOrigin.Members
    | pallet_collective.RawOrigin.Member
    | pallet_collective.RawOrigin._Phantom
  export namespace RawOrigin {
    export function _Phantom(): pallet_collective.RawOrigin._Phantom {
      return { type: "_Phantom" }
    }
    export interface _Phantom {
      type: "_Phantom"
    }
    export function Member(
      value: pallet_collective.RawOrigin.Member["value"],
    ): pallet_collective.RawOrigin.Member {
      return { type: "Member", value }
    }
    export interface Member {
      type: "Member"
      value: sp_core.crypto.AccountId32
    }
    export function Members(
      ...value: pallet_collective.RawOrigin.Members["value"]
    ): pallet_collective.RawOrigin.Members {
      return { type: "Members", value }
    }
    export interface Members {
      type: "Members"
      value: [u32, u32]
    }
  }
  export interface Votes {
    index: u32
    threshold: u32
    ayes: Array<sp_core.crypto.AccountId32>
    nays: Array<sp_core.crypto.AccountId32>
    end: u32
  }
  export function Votes(value: pallet_collective.Votes) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_collective.pallet.Call> = _codec.$237
    export const $error: $.Codec<pallet_collective.pallet.Error> = _codec.$547
    export const $event: $.Codec<pallet_collective.pallet.Event> = _codec.$65
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_collective.pallet.Call.set_members
      | pallet_collective.pallet.Call.execute
      | pallet_collective.pallet.Call.propose
      | pallet_collective.pallet.Call.vote
      | pallet_collective.pallet.Call.close_old_weight
      | pallet_collective.pallet.Call.disapprove_proposal
      | pallet_collective.pallet.Call.close
    export namespace Call {
      /**
       * Close a vote that is either approved, disapproved or whose voting period has ended.
       *
       * May be called by any signed account in order to finish voting and close the proposal.
       *
       * If called before the end of the voting period it will only close the vote if it is
       * has enough votes to be approved or disapproved.
       *
       * If called after the end of the voting period abstentions are counted as rejections
       * unless there is a prime member set and the prime member cast an approval.
       *
       * If the close operation completes successfully with disapproval, the transaction fee will
       * be waived. Otherwise execution of the approved operation will be charged to the caller.
       *
       * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
       * proposal.
       * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
       * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1 + P2)` where:
       *   - `B` is `proposal` size in bytes (length-fee-bounded)
       *   - `M` is members-count (code- and governance-bounded)
       *   - `P1` is the complexity of `proposal` preimage.
       *   - `P2` is proposal-count (code-bounded)
       * - DB:
       *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
       *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
       *    `O(P2)`)
       *  - any mutations done while executing `proposal` (`P1`)
       * - up to 3 events
       * # </weight>
       */
      export function close(
        value: Omit<pallet_collective.pallet.Call.close, "type">,
      ): pallet_collective.pallet.Call.close {
        return { type: "close", ...value }
      }
      /**
       * Close a vote that is either approved, disapproved or whose voting period has ended.
       *
       * May be called by any signed account in order to finish voting and close the proposal.
       *
       * If called before the end of the voting period it will only close the vote if it is
       * has enough votes to be approved or disapproved.
       *
       * If called after the end of the voting period abstentions are counted as rejections
       * unless there is a prime member set and the prime member cast an approval.
       *
       * If the close operation completes successfully with disapproval, the transaction fee will
       * be waived. Otherwise execution of the approved operation will be charged to the caller.
       *
       * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
       * proposal.
       * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
       * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1 + P2)` where:
       *   - `B` is `proposal` size in bytes (length-fee-bounded)
       *   - `M` is members-count (code- and governance-bounded)
       *   - `P1` is the complexity of `proposal` preimage.
       *   - `P2` is proposal-count (code-bounded)
       * - DB:
       *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
       *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
       *    `O(P2)`)
       *  - any mutations done while executing `proposal` (`P1`)
       * - up to 3 events
       * # </weight>
       */
      export interface close {
        type: "close"
        proposal_hash: primitive_types.H256
        index: Compact<u32>
        proposal_weight_bound: sp_weights.weight_v2.Weight
        length_bound: Compact<u32>
      }
      /**
       * Close a vote that is either approved, disapproved or whose voting period has ended.
       *
       * May be called by any signed account in order to finish voting and close the proposal.
       *
       * If called before the end of the voting period it will only close the vote if it is
       * has enough votes to be approved or disapproved.
       *
       * If called after the end of the voting period abstentions are counted as rejections
       * unless there is a prime member set and the prime member cast an approval.
       *
       * If the close operation completes successfully with disapproval, the transaction fee will
       * be waived. Otherwise execution of the approved operation will be charged to the caller.
       *
       * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
       * proposal.
       * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
       * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1 + P2)` where:
       *   - `B` is `proposal` size in bytes (length-fee-bounded)
       *   - `M` is members-count (code- and governance-bounded)
       *   - `P1` is the complexity of `proposal` preimage.
       *   - `P2` is proposal-count (code-bounded)
       * - DB:
       *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
       *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
       *    `O(P2)`)
       *  - any mutations done while executing `proposal` (`P1`)
       * - up to 3 events
       * # </weight>
       */
      export function close_old_weight(
        value: Omit<pallet_collective.pallet.Call.close_old_weight, "type">,
      ): pallet_collective.pallet.Call.close_old_weight {
        return { type: "close_old_weight", ...value }
      }
      /**
       * Close a vote that is either approved, disapproved or whose voting period has ended.
       *
       * May be called by any signed account in order to finish voting and close the proposal.
       *
       * If called before the end of the voting period it will only close the vote if it is
       * has enough votes to be approved or disapproved.
       *
       * If called after the end of the voting period abstentions are counted as rejections
       * unless there is a prime member set and the prime member cast an approval.
       *
       * If the close operation completes successfully with disapproval, the transaction fee will
       * be waived. Otherwise execution of the approved operation will be charged to the caller.
       *
       * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
       * proposal.
       * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
       * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1 + P2)` where:
       *   - `B` is `proposal` size in bytes (length-fee-bounded)
       *   - `M` is members-count (code- and governance-bounded)
       *   - `P1` is the complexity of `proposal` preimage.
       *   - `P2` is proposal-count (code-bounded)
       * - DB:
       *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
       *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
       *    `O(P2)`)
       *  - any mutations done while executing `proposal` (`P1`)
       * - up to 3 events
       * # </weight>
       */
      export interface close_old_weight {
        type: "close_old_weight"
        proposal_hash: primitive_types.H256
        index: Compact<u32>
        proposal_weight_bound: Compact<sp_weights.OldWeight>
        length_bound: Compact<u32>
      }
      /**
       * Disapprove a proposal, close, and remove it from the system, regardless of its current
       * state.
       *
       * Must be called by the Root origin.
       *
       * Parameters:
       * * `proposal_hash`: The hash of the proposal that should be disapproved.
       *
       * # <weight>
       * Complexity: O(P) where P is the number of max proposals
       * DB Weight:
       * * Reads: Proposals
       * * Writes: Voting, Proposals, ProposalOf
       * # </weight>
       */
      export function disapprove_proposal(
        value: Omit<pallet_collective.pallet.Call.disapprove_proposal, "type">,
      ): pallet_collective.pallet.Call.disapprove_proposal {
        return { type: "disapprove_proposal", ...value }
      }
      /**
       * Disapprove a proposal, close, and remove it from the system, regardless of its current
       * state.
       *
       * Must be called by the Root origin.
       *
       * Parameters:
       * * `proposal_hash`: The hash of the proposal that should be disapproved.
       *
       * # <weight>
       * Complexity: O(P) where P is the number of max proposals
       * DB Weight:
       * * Reads: Proposals
       * * Writes: Voting, Proposals, ProposalOf
       * # </weight>
       */
      export interface disapprove_proposal {
        type: "disapprove_proposal"
        proposal_hash: primitive_types.H256
      }
      /**
       * Dispatch a proposal from a member using the `Member` origin.
       *
       * Origin must be a member of the collective.
       *
       * # <weight>
       * ## Weight
       * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
       *   `proposal`
       * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
       * - 1 event
       * # </weight>
       */
      export function execute(
        value: Omit<pallet_collective.pallet.Call.execute, "type">,
      ): pallet_collective.pallet.Call.execute {
        return { type: "execute", ...value }
      }
      /**
       * Dispatch a proposal from a member using the `Member` origin.
       *
       * Origin must be a member of the collective.
       *
       * # <weight>
       * ## Weight
       * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
       *   `proposal`
       * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
       * - 1 event
       * # </weight>
       */
      export interface execute {
        type: "execute"
        proposal: polkadot_runtime.RuntimeCall
        length_bound: Compact<u32>
      }
      /**
       * Add a new proposal to either be voted on or executed directly.
       *
       * Requires the sender to be member.
       *
       * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
       * or put up for voting.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1)` or `O(B + M + P2)` where:
       *   - `B` is `proposal` size in bytes (length-fee-bounded)
       *   - `M` is members-count (code- and governance-bounded)
       *   - branching is influenced by `threshold` where:
       *     - `P1` is proposal execution complexity (`threshold < 2`)
       *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
       * - DB:
       *   - 1 storage read `is_member` (codec `O(M)`)
       *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
       *   - DB accesses influenced by `threshold`:
       *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
       *     - OR proposal insertion (`threshold <= 2`)
       *       - 1 storage mutation `Proposals` (codec `O(P2)`)
       *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
       *       - 1 storage write `ProposalOf` (codec `O(B)`)
       *       - 1 storage write `Voting` (codec `O(M)`)
       *   - 1 event
       * # </weight>
       */
      export function propose(
        value: Omit<pallet_collective.pallet.Call.propose, "type">,
      ): pallet_collective.pallet.Call.propose {
        return { type: "propose", ...value }
      }
      /**
       * Add a new proposal to either be voted on or executed directly.
       *
       * Requires the sender to be member.
       *
       * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
       * or put up for voting.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1)` or `O(B + M + P2)` where:
       *   - `B` is `proposal` size in bytes (length-fee-bounded)
       *   - `M` is members-count (code- and governance-bounded)
       *   - branching is influenced by `threshold` where:
       *     - `P1` is proposal execution complexity (`threshold < 2`)
       *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
       * - DB:
       *   - 1 storage read `is_member` (codec `O(M)`)
       *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
       *   - DB accesses influenced by `threshold`:
       *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
       *     - OR proposal insertion (`threshold <= 2`)
       *       - 1 storage mutation `Proposals` (codec `O(P2)`)
       *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
       *       - 1 storage write `ProposalOf` (codec `O(B)`)
       *       - 1 storage write `Voting` (codec `O(M)`)
       *   - 1 event
       * # </weight>
       */
      export interface propose {
        type: "propose"
        threshold: Compact<u32>
        proposal: polkadot_runtime.RuntimeCall
        length_bound: Compact<u32>
      }
      /**
       * Set the collective's membership.
       *
       * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
       * - `prime`: The prime member whose vote sets the default.
       * - `old_count`: The upper bound for the previous number of members in storage. Used for
       *   weight estimation.
       *
       * Requires root origin.
       *
       * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
       *       the weight estimations rely on it to estimate dispatchable weight.
       *
       * # WARNING:
       *
       * The `pallet-collective` can also be managed by logic outside of the pallet through the
       * implementation of the trait [`ChangeMembers`].
       * Any call to `set_members` must be careful that the member set doesn't get out of sync
       * with other logic managing the member set.
       *
       * # <weight>
       * ## Weight
       * - `O(MP + N)` where:
       *   - `M` old-members-count (code- and governance-bounded)
       *   - `N` new-members-count (code- and governance-bounded)
       *   - `P` proposals-count (code-bounded)
       * - DB:
       *   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the
       *     members
       *   - 1 storage read (codec `O(P)`) for reading the proposals
       *   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
       *   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
       * # </weight>
       */
      export function set_members(
        value: Omit<pallet_collective.pallet.Call.set_members, "type">,
      ): pallet_collective.pallet.Call.set_members {
        return { type: "set_members", ...value }
      }
      /**
       * Set the collective's membership.
       *
       * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
       * - `prime`: The prime member whose vote sets the default.
       * - `old_count`: The upper bound for the previous number of members in storage. Used for
       *   weight estimation.
       *
       * Requires root origin.
       *
       * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
       *       the weight estimations rely on it to estimate dispatchable weight.
       *
       * # WARNING:
       *
       * The `pallet-collective` can also be managed by logic outside of the pallet through the
       * implementation of the trait [`ChangeMembers`].
       * Any call to `set_members` must be careful that the member set doesn't get out of sync
       * with other logic managing the member set.
       *
       * # <weight>
       * ## Weight
       * - `O(MP + N)` where:
       *   - `M` old-members-count (code- and governance-bounded)
       *   - `N` new-members-count (code- and governance-bounded)
       *   - `P` proposals-count (code-bounded)
       * - DB:
       *   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the
       *     members
       *   - 1 storage read (codec `O(P)`) for reading the proposals
       *   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
       *   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
       * # </weight>
       */
      export interface set_members {
        type: "set_members"
        new_members: Array<sp_core.crypto.AccountId32>
        prime: sp_core.crypto.AccountId32 | undefined
        old_count: u32
      }
      /**
       * Add an aye or nay vote for the sender to the given proposal.
       *
       * Requires the sender to be a member.
       *
       * Transaction fees will be waived if the member is voting on any particular proposal
       * for the first time and the call is successful. Subsequent vote changes will charge a
       * fee.
       * # <weight>
       * ## Weight
       * - `O(M)` where `M` is members-count (code- and governance-bounded)
       * - DB:
       *   - 1 storage read `Members` (codec `O(M)`)
       *   - 1 storage mutation `Voting` (codec `O(M)`)
       * - 1 event
       * # </weight>
       */
      export function vote(
        value: Omit<pallet_collective.pallet.Call.vote, "type">,
      ): pallet_collective.pallet.Call.vote {
        return { type: "vote", ...value }
      }
      /**
       * Add an aye or nay vote for the sender to the given proposal.
       *
       * Requires the sender to be a member.
       *
       * Transaction fees will be waived if the member is voting on any particular proposal
       * for the first time and the call is successful. Subsequent vote changes will charge a
       * fee.
       * # <weight>
       * ## Weight
       * - `O(M)` where `M` is members-count (code- and governance-bounded)
       * - DB:
       *   - 1 storage read `Members` (codec `O(M)`)
       *   - 1 storage mutation `Voting` (codec `O(M)`)
       * - 1 event
       * # </weight>
       */
      export interface vote {
        type: "vote"
        proposal: primitive_types.H256
        index: Compact<u32>
        approve: boolean
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "NotMember"
      | "DuplicateProposal"
      | "ProposalMissing"
      | "WrongIndex"
      | "DuplicateVote"
      | "AlreadyInitialized"
      | "TooEarly"
      | "TooManyProposals"
      | "WrongProposalWeight"
      | "WrongProposalLength"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_collective.pallet.Event.Proposed
      | pallet_collective.pallet.Event.Voted
      | pallet_collective.pallet.Event.Approved
      | pallet_collective.pallet.Event.Disapproved
      | pallet_collective.pallet.Event.Executed
      | pallet_collective.pallet.Event.MemberExecuted
      | pallet_collective.pallet.Event.Closed
    export namespace Event {
      /** A motion was approved by the required threshold. */
      export function Approved(
        value: Omit<pallet_collective.pallet.Event.Approved, "type">,
      ): pallet_collective.pallet.Event.Approved {
        return { type: "Approved", ...value }
      }
      /** A motion was approved by the required threshold. */
      export interface Approved {
        type: "Approved"
        proposal_hash: primitive_types.H256
      }
      /** A proposal was closed because its threshold was reached or after its duration was up. */
      export function Closed(
        value: Omit<pallet_collective.pallet.Event.Closed, "type">,
      ): pallet_collective.pallet.Event.Closed {
        return { type: "Closed", ...value }
      }
      /** A proposal was closed because its threshold was reached or after its duration was up. */
      export interface Closed {
        type: "Closed"
        proposal_hash: primitive_types.H256
        yes: u32
        no: u32
      }
      /** A motion was not approved by the required threshold. */
      export function Disapproved(
        value: Omit<pallet_collective.pallet.Event.Disapproved, "type">,
      ): pallet_collective.pallet.Event.Disapproved {
        return { type: "Disapproved", ...value }
      }
      /** A motion was not approved by the required threshold. */
      export interface Disapproved {
        type: "Disapproved"
        proposal_hash: primitive_types.H256
      }
      /** A motion was executed; result will be `Ok` if it returned without error. */
      export function Executed(
        value: Omit<pallet_collective.pallet.Event.Executed, "type">,
      ): pallet_collective.pallet.Event.Executed {
        return { type: "Executed", ...value }
      }
      /** A motion was executed; result will be `Ok` if it returned without error. */
      export interface Executed {
        type: "Executed"
        proposal_hash: primitive_types.H256
        result: null | ChainError<sp_runtime.DispatchError>
      }
      /** A single member did some action; result will be `Ok` if it returned without error. */
      export function MemberExecuted(
        value: Omit<pallet_collective.pallet.Event.MemberExecuted, "type">,
      ): pallet_collective.pallet.Event.MemberExecuted {
        return { type: "MemberExecuted", ...value }
      }
      /** A single member did some action; result will be `Ok` if it returned without error. */
      export interface MemberExecuted {
        type: "MemberExecuted"
        proposal_hash: primitive_types.H256
        result: null | ChainError<sp_runtime.DispatchError>
      }
      /**
       * A motion (given hash) has been proposed (by given account) with a threshold (given
       * `MemberCount`).
       */
      export function Proposed(
        value: Omit<pallet_collective.pallet.Event.Proposed, "type">,
      ): pallet_collective.pallet.Event.Proposed {
        return { type: "Proposed", ...value }
      }
      /**
       * A motion (given hash) has been proposed (by given account) with a threshold (given
       * `MemberCount`).
       */
      export interface Proposed {
        type: "Proposed"
        account: sp_core.crypto.AccountId32
        proposal_index: u32
        proposal_hash: primitive_types.H256
        threshold: u32
      }
      /**
       * A motion (given hash) has been voted on by given account, leaving
       * a tally (yes votes and no votes given respectively as `MemberCount`).
       */
      export function Voted(
        value: Omit<pallet_collective.pallet.Event.Voted, "type">,
      ): pallet_collective.pallet.Event.Voted {
        return { type: "Voted", ...value }
      }
      /**
       * A motion (given hash) has been voted on by given account, leaving
       * a tally (yes votes and no votes given respectively as `MemberCount`).
       */
      export interface Voted {
        type: "Voted"
        account: sp_core.crypto.AccountId32
        proposal_hash: primitive_types.H256
        voted: boolean
        yes: u32
        no: u32
      }
    }
  }
}
export namespace pallet_democracy {
  export namespace conviction {
    export const $conviction: $.Codec<pallet_democracy.conviction.Conviction> = _codec.$235
    export type Conviction =
      | "None"
      | "Locked1x"
      | "Locked2x"
      | "Locked3x"
      | "Locked4x"
      | "Locked5x"
      | "Locked6x"
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_democracy.pallet.Call> = _codec.$234
    export const $error: $.Codec<pallet_democracy.pallet.Error> = _codec.$544
    export const $event: $.Codec<pallet_democracy.pallet.Event> = _codec.$61
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_democracy.pallet.Call.propose
      | pallet_democracy.pallet.Call.second
      | pallet_democracy.pallet.Call.vote
      | pallet_democracy.pallet.Call.emergency_cancel
      | pallet_democracy.pallet.Call.external_propose
      | pallet_democracy.pallet.Call.external_propose_majority
      | pallet_democracy.pallet.Call.external_propose_default
      | pallet_democracy.pallet.Call.fast_track
      | pallet_democracy.pallet.Call.veto_external
      | pallet_democracy.pallet.Call.cancel_referendum
      | pallet_democracy.pallet.Call.delegate
      | pallet_democracy.pallet.Call.undelegate
      | pallet_democracy.pallet.Call.clear_public_proposals
      | pallet_democracy.pallet.Call.unlock
      | pallet_democracy.pallet.Call.remove_vote
      | pallet_democracy.pallet.Call.remove_other_vote
      | pallet_democracy.pallet.Call.blacklist
      | pallet_democracy.pallet.Call.cancel_proposal
    export namespace Call {
      /**
       * Permanently place a proposal into the blacklist. This prevents it from ever being
       * proposed again.
       *
       * If called on a queued public or external proposal, then this will result in it being
       * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
       * then it will be cancelled.
       *
       * The dispatch origin of this call must be `BlacklistOrigin`.
       *
       * - `proposal_hash`: The proposal hash to blacklist permanently.
       * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
       * cancelled.
       *
       * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
       *   reasonable value).
       */
      export function blacklist(
        value: Omit<pallet_democracy.pallet.Call.blacklist, "type">,
      ): pallet_democracy.pallet.Call.blacklist {
        return { type: "blacklist", ...value }
      }
      /**
       * Permanently place a proposal into the blacklist. This prevents it from ever being
       * proposed again.
       *
       * If called on a queued public or external proposal, then this will result in it being
       * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
       * then it will be cancelled.
       *
       * The dispatch origin of this call must be `BlacklistOrigin`.
       *
       * - `proposal_hash`: The proposal hash to blacklist permanently.
       * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
       * cancelled.
       *
       * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
       *   reasonable value).
       */
      export interface blacklist {
        type: "blacklist"
        proposal_hash: primitive_types.H256
        maybe_ref_index: u32 | undefined
      }
      /**
       * Remove a proposal.
       *
       * The dispatch origin of this call must be `CancelProposalOrigin`.
       *
       * - `prop_index`: The index of the proposal to cancel.
       *
       * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
       */
      export function cancel_proposal(
        value: Omit<pallet_democracy.pallet.Call.cancel_proposal, "type">,
      ): pallet_democracy.pallet.Call.cancel_proposal {
        return { type: "cancel_proposal", ...value }
      }
      /**
       * Remove a proposal.
       *
       * The dispatch origin of this call must be `CancelProposalOrigin`.
       *
       * - `prop_index`: The index of the proposal to cancel.
       *
       * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
       */
      export interface cancel_proposal {
        type: "cancel_proposal"
        prop_index: Compact<u32>
      }
      /**
       * Remove a referendum.
       *
       * The dispatch origin of this call must be _Root_.
       *
       * - `ref_index`: The index of the referendum to cancel.
       *
       * # Weight: `O(1)`.
       */
      export function cancel_referendum(
        value: Omit<pallet_democracy.pallet.Call.cancel_referendum, "type">,
      ): pallet_democracy.pallet.Call.cancel_referendum {
        return { type: "cancel_referendum", ...value }
      }
      /**
       * Remove a referendum.
       *
       * The dispatch origin of this call must be _Root_.
       *
       * - `ref_index`: The index of the referendum to cancel.
       *
       * # Weight: `O(1)`.
       */
      export interface cancel_referendum {
        type: "cancel_referendum"
        ref_index: Compact<u32>
      }
      /**
       * Clears all public proposals.
       *
       * The dispatch origin of this call must be _Root_.
       *
       * Weight: `O(1)`.
       */
      export function clear_public_proposals(): pallet_democracy.pallet.Call.clear_public_proposals {
        return { type: "clear_public_proposals" }
      }
      /**
       * Clears all public proposals.
       *
       * The dispatch origin of this call must be _Root_.
       *
       * Weight: `O(1)`.
       */
      export interface clear_public_proposals {
        type: "clear_public_proposals"
      }
      /**
       * Delegate the voting power (with some given conviction) of the sending account.
       *
       * The balance delegated is locked for as long as it's delegated, and thereafter for the
       * time appropriate for the conviction's lock period.
       *
       * The dispatch origin of this call must be _Signed_, and the signing account must either:
       *   - be delegating already; or
       *   - have no voting activity (if there is, then it will need to be removed/consolidated
       *     through `reap_vote` or `unvote`).
       *
       * - `to`: The account whose voting the `target` account's voting power will follow.
       * - `conviction`: The conviction that will be attached to the delegated votes. When the
       *   account is undelegated, the funds will be locked for the corresponding period.
       * - `balance`: The amount of the account's balance to be used in delegating. This must not
       *   be more than the account's current balance.
       *
       * Emits `Delegated`.
       *
       * Weight: `O(R)` where R is the number of referendums the voter delegating to has
       *   voted on. Weight is charged as if maximum votes.
       */
      export function delegate(
        value: Omit<pallet_democracy.pallet.Call.delegate, "type">,
      ): pallet_democracy.pallet.Call.delegate {
        return { type: "delegate", ...value }
      }
      /**
       * Delegate the voting power (with some given conviction) of the sending account.
       *
       * The balance delegated is locked for as long as it's delegated, and thereafter for the
       * time appropriate for the conviction's lock period.
       *
       * The dispatch origin of this call must be _Signed_, and the signing account must either:
       *   - be delegating already; or
       *   - have no voting activity (if there is, then it will need to be removed/consolidated
       *     through `reap_vote` or `unvote`).
       *
       * - `to`: The account whose voting the `target` account's voting power will follow.
       * - `conviction`: The conviction that will be attached to the delegated votes. When the
       *   account is undelegated, the funds will be locked for the corresponding period.
       * - `balance`: The amount of the account's balance to be used in delegating. This must not
       *   be more than the account's current balance.
       *
       * Emits `Delegated`.
       *
       * Weight: `O(R)` where R is the number of referendums the voter delegating to has
       *   voted on. Weight is charged as if maximum votes.
       */
      export interface delegate {
        type: "delegate"
        to: sp_runtime.multiaddress.MultiAddress
        conviction: pallet_democracy.conviction.Conviction
        balance: u128
      }
      /**
       * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
       * referendum.
       *
       * The dispatch origin of this call must be `CancellationOrigin`.
       *
       * -`ref_index`: The index of the referendum to cancel.
       *
       * Weight: `O(1)`.
       */
      export function emergency_cancel(
        value: Omit<pallet_democracy.pallet.Call.emergency_cancel, "type">,
      ): pallet_democracy.pallet.Call.emergency_cancel {
        return { type: "emergency_cancel", ...value }
      }
      /**
       * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
       * referendum.
       *
       * The dispatch origin of this call must be `CancellationOrigin`.
       *
       * -`ref_index`: The index of the referendum to cancel.
       *
       * Weight: `O(1)`.
       */
      export interface emergency_cancel {
        type: "emergency_cancel"
        ref_index: u32
      }
      /**
       * Schedule a referendum to be tabled once it is legal to schedule an external
       * referendum.
       *
       * The dispatch origin of this call must be `ExternalOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       */
      export function external_propose(
        value: Omit<pallet_democracy.pallet.Call.external_propose, "type">,
      ): pallet_democracy.pallet.Call.external_propose {
        return { type: "external_propose", ...value }
      }
      /**
       * Schedule a referendum to be tabled once it is legal to schedule an external
       * referendum.
       *
       * The dispatch origin of this call must be `ExternalOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       */
      export interface external_propose {
        type: "external_propose"
        proposal: frame_support.traits.preimages.Bounded
      }
      /**
       * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
       * schedule an external referendum.
       *
       * The dispatch of this call must be `ExternalDefaultOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       *
       * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
       * pre-scheduled `external_propose` call.
       *
       * Weight: `O(1)`
       */
      export function external_propose_default(
        value: Omit<pallet_democracy.pallet.Call.external_propose_default, "type">,
      ): pallet_democracy.pallet.Call.external_propose_default {
        return { type: "external_propose_default", ...value }
      }
      /**
       * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
       * schedule an external referendum.
       *
       * The dispatch of this call must be `ExternalDefaultOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       *
       * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
       * pre-scheduled `external_propose` call.
       *
       * Weight: `O(1)`
       */
      export interface external_propose_default {
        type: "external_propose_default"
        proposal: frame_support.traits.preimages.Bounded
      }
      /**
       * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
       * an external referendum.
       *
       * The dispatch of this call must be `ExternalMajorityOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       *
       * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
       * pre-scheduled `external_propose` call.
       *
       * Weight: `O(1)`
       */
      export function external_propose_majority(
        value: Omit<pallet_democracy.pallet.Call.external_propose_majority, "type">,
      ): pallet_democracy.pallet.Call.external_propose_majority {
        return { type: "external_propose_majority", ...value }
      }
      /**
       * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
       * an external referendum.
       *
       * The dispatch of this call must be `ExternalMajorityOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       *
       * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
       * pre-scheduled `external_propose` call.
       *
       * Weight: `O(1)`
       */
      export interface external_propose_majority {
        type: "external_propose_majority"
        proposal: frame_support.traits.preimages.Bounded
      }
      /**
       * Schedule the currently externally-proposed majority-carries referendum to be tabled
       * immediately. If there is no externally-proposed referendum currently, or if there is one
       * but it is not a majority-carries referendum then it fails.
       *
       * The dispatch of this call must be `FastTrackOrigin`.
       *
       * - `proposal_hash`: The hash of the current external proposal.
       * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
       * 	Must be always greater than zero.
       * 	For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
       * - `delay`: The number of block after voting has ended in approval and this should be
       *   enacted. This doesn't have a minimum amount.
       *
       * Emits `Started`.
       *
       * Weight: `O(1)`
       */
      export function fast_track(
        value: Omit<pallet_democracy.pallet.Call.fast_track, "type">,
      ): pallet_democracy.pallet.Call.fast_track {
        return { type: "fast_track", ...value }
      }
      /**
       * Schedule the currently externally-proposed majority-carries referendum to be tabled
       * immediately. If there is no externally-proposed referendum currently, or if there is one
       * but it is not a majority-carries referendum then it fails.
       *
       * The dispatch of this call must be `FastTrackOrigin`.
       *
       * - `proposal_hash`: The hash of the current external proposal.
       * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
       * 	Must be always greater than zero.
       * 	For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
       * - `delay`: The number of block after voting has ended in approval and this should be
       *   enacted. This doesn't have a minimum amount.
       *
       * Emits `Started`.
       *
       * Weight: `O(1)`
       */
      export interface fast_track {
        type: "fast_track"
        proposal_hash: primitive_types.H256
        voting_period: u32
        delay: u32
      }
      /**
       * Propose a sensitive action to be taken.
       *
       * The dispatch origin of this call must be _Signed_ and the sender must
       * have funds to cover the deposit.
       *
       * - `proposal_hash`: The hash of the proposal preimage.
       * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
       *
       * Emits `Proposed`.
       */
      export function propose(
        value: Omit<pallet_democracy.pallet.Call.propose, "type">,
      ): pallet_democracy.pallet.Call.propose {
        return { type: "propose", ...value }
      }
      /**
       * Propose a sensitive action to be taken.
       *
       * The dispatch origin of this call must be _Signed_ and the sender must
       * have funds to cover the deposit.
       *
       * - `proposal_hash`: The hash of the proposal preimage.
       * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
       *
       * Emits `Proposed`.
       */
      export interface propose {
        type: "propose"
        proposal: frame_support.traits.preimages.Bounded
        value: Compact<u128>
      }
      /**
       * Remove a vote for a referendum.
       *
       * If the `target` is equal to the signer, then this function is exactly equivalent to
       * `remove_vote`. If not equal to the signer, then the vote must have expired,
       * either because the referendum was cancelled, because the voter lost the referendum or
       * because the conviction period is over.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `target`: The account of the vote to be removed; this account must have voted for
       *   referendum `index`.
       * - `index`: The index of referendum of the vote to be removed.
       *
       * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
       *   Weight is calculated for the maximum number of vote.
       */
      export function remove_other_vote(
        value: Omit<pallet_democracy.pallet.Call.remove_other_vote, "type">,
      ): pallet_democracy.pallet.Call.remove_other_vote {
        return { type: "remove_other_vote", ...value }
      }
      /**
       * Remove a vote for a referendum.
       *
       * If the `target` is equal to the signer, then this function is exactly equivalent to
       * `remove_vote`. If not equal to the signer, then the vote must have expired,
       * either because the referendum was cancelled, because the voter lost the referendum or
       * because the conviction period is over.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `target`: The account of the vote to be removed; this account must have voted for
       *   referendum `index`.
       * - `index`: The index of referendum of the vote to be removed.
       *
       * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
       *   Weight is calculated for the maximum number of vote.
       */
      export interface remove_other_vote {
        type: "remove_other_vote"
        target: sp_runtime.multiaddress.MultiAddress
        index: u32
      }
      /**
       * Remove a vote for a referendum.
       *
       * If:
       * - the referendum was cancelled, or
       * - the referendum is ongoing, or
       * - the referendum has ended such that
       *   - the vote of the account was in opposition to the result; or
       *   - there was no conviction to the account's vote; or
       *   - the account made a split vote
       * ...then the vote is removed cleanly and a following call to `unlock` may result in more
       * funds being available.
       *
       * If, however, the referendum has ended and:
       * - it finished corresponding to the vote of the account, and
       * - the account made a standard vote with conviction, and
       * - the lock period of the conviction is not over
       * ...then the lock will be aggregated into the overall account's lock, which may involve
       * *overlocking* (where the two locks are combined into a single lock that is the maximum
       * of both the amount locked and the time is it locked for).
       *
       * The dispatch origin of this call must be _Signed_, and the signer must have a vote
       * registered for referendum `index`.
       *
       * - `index`: The index of referendum of the vote to be removed.
       *
       * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
       *   Weight is calculated for the maximum number of vote.
       */
      export function remove_vote(
        value: Omit<pallet_democracy.pallet.Call.remove_vote, "type">,
      ): pallet_democracy.pallet.Call.remove_vote {
        return { type: "remove_vote", ...value }
      }
      /**
       * Remove a vote for a referendum.
       *
       * If:
       * - the referendum was cancelled, or
       * - the referendum is ongoing, or
       * - the referendum has ended such that
       *   - the vote of the account was in opposition to the result; or
       *   - there was no conviction to the account's vote; or
       *   - the account made a split vote
       * ...then the vote is removed cleanly and a following call to `unlock` may result in more
       * funds being available.
       *
       * If, however, the referendum has ended and:
       * - it finished corresponding to the vote of the account, and
       * - the account made a standard vote with conviction, and
       * - the lock period of the conviction is not over
       * ...then the lock will be aggregated into the overall account's lock, which may involve
       * *overlocking* (where the two locks are combined into a single lock that is the maximum
       * of both the amount locked and the time is it locked for).
       *
       * The dispatch origin of this call must be _Signed_, and the signer must have a vote
       * registered for referendum `index`.
       *
       * - `index`: The index of referendum of the vote to be removed.
       *
       * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
       *   Weight is calculated for the maximum number of vote.
       */
      export interface remove_vote {
        type: "remove_vote"
        index: u32
      }
      /**
       * Signals agreement with a particular proposal.
       *
       * The dispatch origin of this call must be _Signed_ and the sender
       * must have funds to cover the deposit, equal to the original deposit.
       *
       * - `proposal`: The index of the proposal to second.
       */
      export function second(
        value: Omit<pallet_democracy.pallet.Call.second, "type">,
      ): pallet_democracy.pallet.Call.second {
        return { type: "second", ...value }
      }
      /**
       * Signals agreement with a particular proposal.
       *
       * The dispatch origin of this call must be _Signed_ and the sender
       * must have funds to cover the deposit, equal to the original deposit.
       *
       * - `proposal`: The index of the proposal to second.
       */
      export interface second {
        type: "second"
        proposal: Compact<u32>
      }
      /**
       * Undelegate the voting power of the sending account.
       *
       * Tokens may be unlocked following once an amount of time consistent with the lock period
       * of the conviction with which the delegation was issued.
       *
       * The dispatch origin of this call must be _Signed_ and the signing account must be
       * currently delegating.
       *
       * Emits `Undelegated`.
       *
       * Weight: `O(R)` where R is the number of referendums the voter delegating to has
       *   voted on. Weight is charged as if maximum votes.
       */
      export function undelegate(): pallet_democracy.pallet.Call.undelegate {
        return { type: "undelegate" }
      }
      /**
       * Undelegate the voting power of the sending account.
       *
       * Tokens may be unlocked following once an amount of time consistent with the lock period
       * of the conviction with which the delegation was issued.
       *
       * The dispatch origin of this call must be _Signed_ and the signing account must be
       * currently delegating.
       *
       * Emits `Undelegated`.
       *
       * Weight: `O(R)` where R is the number of referendums the voter delegating to has
       *   voted on. Weight is charged as if maximum votes.
       */
      export interface undelegate {
        type: "undelegate"
      }
      /**
       * Unlock tokens that have an expired lock.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `target`: The account to remove the lock on.
       *
       * Weight: `O(R)` with R number of vote of target.
       */
      export function unlock(
        value: Omit<pallet_democracy.pallet.Call.unlock, "type">,
      ): pallet_democracy.pallet.Call.unlock {
        return { type: "unlock", ...value }
      }
      /**
       * Unlock tokens that have an expired lock.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `target`: The account to remove the lock on.
       *
       * Weight: `O(R)` with R number of vote of target.
       */
      export interface unlock {
        type: "unlock"
        target: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Veto and blacklist the external proposal hash.
       *
       * The dispatch origin of this call must be `VetoOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
       *
       * Emits `Vetoed`.
       *
       * Weight: `O(V + log(V))` where V is number of `existing vetoers`
       */
      export function veto_external(
        value: Omit<pallet_democracy.pallet.Call.veto_external, "type">,
      ): pallet_democracy.pallet.Call.veto_external {
        return { type: "veto_external", ...value }
      }
      /**
       * Veto and blacklist the external proposal hash.
       *
       * The dispatch origin of this call must be `VetoOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
       *
       * Emits `Vetoed`.
       *
       * Weight: `O(V + log(V))` where V is number of `existing vetoers`
       */
      export interface veto_external {
        type: "veto_external"
        proposal_hash: primitive_types.H256
      }
      /**
       * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
       * otherwise it is a vote to keep the status quo.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `ref_index`: The index of the referendum to vote for.
       * - `vote`: The vote configuration.
       */
      export function vote(
        value: Omit<pallet_democracy.pallet.Call.vote, "type">,
      ): pallet_democracy.pallet.Call.vote {
        return { type: "vote", ...value }
      }
      /**
       * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
       * otherwise it is a vote to keep the status quo.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `ref_index`: The index of the referendum to vote for.
       * - `vote`: The vote configuration.
       */
      export interface vote {
        type: "vote"
        ref_index: Compact<u32>
        vote: pallet_democracy.vote.AccountVote
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "ValueLow"
      | "ProposalMissing"
      | "AlreadyCanceled"
      | "DuplicateProposal"
      | "ProposalBlacklisted"
      | "NotSimpleMajority"
      | "InvalidHash"
      | "NoProposal"
      | "AlreadyVetoed"
      | "ReferendumInvalid"
      | "NoneWaiting"
      | "NotVoter"
      | "NoPermission"
      | "AlreadyDelegating"
      | "InsufficientFunds"
      | "NotDelegating"
      | "VotesExist"
      | "InstantNotAllowed"
      | "Nonsense"
      | "WrongUpperBound"
      | "MaxVotesReached"
      | "TooMany"
      | "VotingPeriodLow"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_democracy.pallet.Event.Proposed
      | pallet_democracy.pallet.Event.Tabled
      | pallet_democracy.pallet.Event.ExternalTabled
      | pallet_democracy.pallet.Event.Started
      | pallet_democracy.pallet.Event.Passed
      | pallet_democracy.pallet.Event.NotPassed
      | pallet_democracy.pallet.Event.Cancelled
      | pallet_democracy.pallet.Event.Delegated
      | pallet_democracy.pallet.Event.Undelegated
      | pallet_democracy.pallet.Event.Vetoed
      | pallet_democracy.pallet.Event.Blacklisted
      | pallet_democracy.pallet.Event.Voted
      | pallet_democracy.pallet.Event.Seconded
      | pallet_democracy.pallet.Event.ProposalCanceled
    export namespace Event {
      /** A proposal_hash has been blacklisted permanently. */
      export function Blacklisted(
        value: Omit<pallet_democracy.pallet.Event.Blacklisted, "type">,
      ): pallet_democracy.pallet.Event.Blacklisted {
        return { type: "Blacklisted", ...value }
      }
      /** A proposal_hash has been blacklisted permanently. */
      export interface Blacklisted {
        type: "Blacklisted"
        proposal_hash: primitive_types.H256
      }
      /** A referendum has been cancelled. */
      export function Cancelled(
        value: Omit<pallet_democracy.pallet.Event.Cancelled, "type">,
      ): pallet_democracy.pallet.Event.Cancelled {
        return { type: "Cancelled", ...value }
      }
      /** A referendum has been cancelled. */
      export interface Cancelled {
        type: "Cancelled"
        ref_index: u32
      }
      /** An account has delegated their vote to another account. */
      export function Delegated(
        value: Omit<pallet_democracy.pallet.Event.Delegated, "type">,
      ): pallet_democracy.pallet.Event.Delegated {
        return { type: "Delegated", ...value }
      }
      /** An account has delegated their vote to another account. */
      export interface Delegated {
        type: "Delegated"
        who: sp_core.crypto.AccountId32
        target: sp_core.crypto.AccountId32
      }
      /** An external proposal has been tabled. */
      export function ExternalTabled(): pallet_democracy.pallet.Event.ExternalTabled {
        return { type: "ExternalTabled" }
      }
      /** An external proposal has been tabled. */
      export interface ExternalTabled {
        type: "ExternalTabled"
      }
      /** A proposal has been rejected by referendum. */
      export function NotPassed(
        value: Omit<pallet_democracy.pallet.Event.NotPassed, "type">,
      ): pallet_democracy.pallet.Event.NotPassed {
        return { type: "NotPassed", ...value }
      }
      /** A proposal has been rejected by referendum. */
      export interface NotPassed {
        type: "NotPassed"
        ref_index: u32
      }
      /** A proposal has been approved by referendum. */
      export function Passed(
        value: Omit<pallet_democracy.pallet.Event.Passed, "type">,
      ): pallet_democracy.pallet.Event.Passed {
        return { type: "Passed", ...value }
      }
      /** A proposal has been approved by referendum. */
      export interface Passed {
        type: "Passed"
        ref_index: u32
      }
      /** A proposal got canceled. */
      export function ProposalCanceled(
        value: Omit<pallet_democracy.pallet.Event.ProposalCanceled, "type">,
      ): pallet_democracy.pallet.Event.ProposalCanceled {
        return { type: "ProposalCanceled", ...value }
      }
      /** A proposal got canceled. */
      export interface ProposalCanceled {
        type: "ProposalCanceled"
        prop_index: u32
      }
      /** A motion has been proposed by a public account. */
      export function Proposed(
        value: Omit<pallet_democracy.pallet.Event.Proposed, "type">,
      ): pallet_democracy.pallet.Event.Proposed {
        return { type: "Proposed", ...value }
      }
      /** A motion has been proposed by a public account. */
      export interface Proposed {
        type: "Proposed"
        proposal_index: u32
        deposit: u128
      }
      /** An account has secconded a proposal */
      export function Seconded(
        value: Omit<pallet_democracy.pallet.Event.Seconded, "type">,
      ): pallet_democracy.pallet.Event.Seconded {
        return { type: "Seconded", ...value }
      }
      /** An account has secconded a proposal */
      export interface Seconded {
        type: "Seconded"
        seconder: sp_core.crypto.AccountId32
        prop_index: u32
      }
      /** A referendum has begun. */
      export function Started(
        value: Omit<pallet_democracy.pallet.Event.Started, "type">,
      ): pallet_democracy.pallet.Event.Started {
        return { type: "Started", ...value }
      }
      /** A referendum has begun. */
      export interface Started {
        type: "Started"
        ref_index: u32
        threshold: pallet_democracy.vote_threshold.VoteThreshold
      }
      /** A public proposal has been tabled for referendum vote. */
      export function Tabled(
        value: Omit<pallet_democracy.pallet.Event.Tabled, "type">,
      ): pallet_democracy.pallet.Event.Tabled {
        return { type: "Tabled", ...value }
      }
      /** A public proposal has been tabled for referendum vote. */
      export interface Tabled {
        type: "Tabled"
        proposal_index: u32
        deposit: u128
      }
      /** An account has cancelled a previous delegation operation. */
      export function Undelegated(
        value: Omit<pallet_democracy.pallet.Event.Undelegated, "type">,
      ): pallet_democracy.pallet.Event.Undelegated {
        return { type: "Undelegated", ...value }
      }
      /** An account has cancelled a previous delegation operation. */
      export interface Undelegated {
        type: "Undelegated"
        account: sp_core.crypto.AccountId32
      }
      /** An external proposal has been vetoed. */
      export function Vetoed(
        value: Omit<pallet_democracy.pallet.Event.Vetoed, "type">,
      ): pallet_democracy.pallet.Event.Vetoed {
        return { type: "Vetoed", ...value }
      }
      /** An external proposal has been vetoed. */
      export interface Vetoed {
        type: "Vetoed"
        who: sp_core.crypto.AccountId32
        proposal_hash: primitive_types.H256
        until: u32
      }
      /** An account has voted in a referendum */
      export function Voted(
        value: Omit<pallet_democracy.pallet.Event.Voted, "type">,
      ): pallet_democracy.pallet.Event.Voted {
        return { type: "Voted", ...value }
      }
      /** An account has voted in a referendum */
      export interface Voted {
        type: "Voted"
        voter: sp_core.crypto.AccountId32
        ref_index: u32
        vote: pallet_democracy.vote.AccountVote
      }
    }
  }
  export namespace types {
    export const $delegations: $.Codec<pallet_democracy.types.Delegations> = _codec.$540
    export const $referendumInfo: $.Codec<pallet_democracy.types.ReferendumInfo> = _codec.$533
    export const $referendumStatus: $.Codec<pallet_democracy.types.ReferendumStatus> = _codec.$534
    export const $tally: $.Codec<pallet_democracy.types.Tally> = _codec.$535
    export interface Delegations {
      votes: u128
      capital: u128
    }
    export function Delegations(value: pallet_democracy.types.Delegations) {
      return value
    }
    export type ReferendumInfo =
      | pallet_democracy.types.ReferendumInfo.Ongoing
      | pallet_democracy.types.ReferendumInfo.Finished
    export namespace ReferendumInfo {
      export function Finished(
        value: Omit<pallet_democracy.types.ReferendumInfo.Finished, "type">,
      ): pallet_democracy.types.ReferendumInfo.Finished {
        return { type: "Finished", ...value }
      }
      export interface Finished {
        type: "Finished"
        approved: boolean
        end: u32
      }
      export function Ongoing(
        value: pallet_democracy.types.ReferendumInfo.Ongoing["value"],
      ): pallet_democracy.types.ReferendumInfo.Ongoing {
        return { type: "Ongoing", value }
      }
      export interface Ongoing {
        type: "Ongoing"
        value: pallet_democracy.types.ReferendumStatus
      }
    }
    export interface ReferendumStatus {
      end: u32
      proposal: frame_support.traits.preimages.Bounded
      threshold: pallet_democracy.vote_threshold.VoteThreshold
      delay: u32
      tally: pallet_democracy.types.Tally
    }
    export function ReferendumStatus(value: pallet_democracy.types.ReferendumStatus) {
      return value
    }
    export interface Tally {
      ayes: u128
      nays: u128
      turnout: u128
    }
    export function Tally(value: pallet_democracy.types.Tally) {
      return value
    }
  }
  export namespace vote {
    export const $accountVote: $.Codec<pallet_democracy.vote.AccountVote> = _codec.$63
    export const $priorLock: $.Codec<pallet_democracy.vote.PriorLock> = _codec.$541
    export const $vote: $.Codec<pallet_democracy.vote.Vote> = _codec.$64
    export const $voting: $.Codec<pallet_democracy.vote.Voting> = _codec.$536
    export type AccountVote =
      | pallet_democracy.vote.AccountVote.Standard
      | pallet_democracy.vote.AccountVote.Split
    export namespace AccountVote {
      export function Split(
        value: Omit<pallet_democracy.vote.AccountVote.Split, "type">,
      ): pallet_democracy.vote.AccountVote.Split {
        return { type: "Split", ...value }
      }
      export interface Split {
        type: "Split"
        aye: u128
        nay: u128
      }
      export function Standard(
        value: Omit<pallet_democracy.vote.AccountVote.Standard, "type">,
      ): pallet_democracy.vote.AccountVote.Standard {
        return { type: "Standard", ...value }
      }
      export interface Standard {
        type: "Standard"
        vote: pallet_democracy.vote.Vote
        balance: u128
      }
    }
    export type PriorLock = [u32, u128]
    export function PriorLock(...value: pallet_democracy.vote.PriorLock) {
      return value
    }
    export type Vote = u8
    export function Vote(value: pallet_democracy.vote.Vote) {
      return value
    }
    export type Voting =
      | pallet_democracy.vote.Voting.Direct
      | pallet_democracy.vote.Voting.Delegating
    export namespace Voting {
      export function Delegating(
        value: Omit<pallet_democracy.vote.Voting.Delegating, "type">,
      ): pallet_democracy.vote.Voting.Delegating {
        return { type: "Delegating", ...value }
      }
      export interface Delegating {
        type: "Delegating"
        balance: u128
        target: sp_core.crypto.AccountId32
        conviction: pallet_democracy.conviction.Conviction
        delegations: pallet_democracy.types.Delegations
        prior: pallet_democracy.vote.PriorLock
      }
      export function Direct(
        value: Omit<pallet_democracy.vote.Voting.Direct, "type">,
      ): pallet_democracy.vote.Voting.Direct {
        return { type: "Direct", ...value }
      }
      export interface Direct {
        type: "Direct"
        votes: Array<[u32, pallet_democracy.vote.AccountVote]>
        delegations: pallet_democracy.types.Delegations
        prior: pallet_democracy.vote.PriorLock
      }
    }
  }
  export namespace vote_threshold {
    export const $voteThreshold: $.Codec<pallet_democracy.vote_threshold.VoteThreshold> = _codec.$62
    export type VoteThreshold = "SuperMajorityApprove" | "SuperMajorityAgainst" | "SimpleMajority"
  }
}
export namespace pallet_election_provider_multi_phase {
  export const $electionCompute: $.Codec<pallet_election_provider_multi_phase.ElectionCompute> =
    _codec.$87
  export const $phase: $.Codec<pallet_election_provider_multi_phase.Phase> = _codec.$600
  export const $rawSolution: $.Codec<pallet_election_provider_multi_phase.RawSolution> = _codec.$311
  export const $readySolution: $.Codec<pallet_election_provider_multi_phase.ReadySolution> =
    _codec.$602
  export const $roundSnapshot: $.Codec<pallet_election_provider_multi_phase.RoundSnapshot> =
    _codec.$603
  export const $solutionOrSnapshotSize: $.Codec<
    pallet_election_provider_multi_phase.SolutionOrSnapshotSize
  > = _codec.$363
  export type ElectionCompute = "OnChain" | "Signed" | "Unsigned" | "Fallback" | "Emergency"
  export type Phase =
    | pallet_election_provider_multi_phase.Phase.Off
    | pallet_election_provider_multi_phase.Phase.Signed
    | pallet_election_provider_multi_phase.Phase.Unsigned
    | pallet_election_provider_multi_phase.Phase.Emergency
  export namespace Phase {
    export function Emergency(): pallet_election_provider_multi_phase.Phase.Emergency {
      return { type: "Emergency" }
    }
    export interface Emergency {
      type: "Emergency"
    }
    export function Off(): pallet_election_provider_multi_phase.Phase.Off {
      return { type: "Off" }
    }
    export interface Off {
      type: "Off"
    }
    export function Signed(): pallet_election_provider_multi_phase.Phase.Signed {
      return { type: "Signed" }
    }
    export interface Signed {
      type: "Signed"
    }
    export function Unsigned(
      value: pallet_election_provider_multi_phase.Phase.Unsigned["value"],
    ): pallet_election_provider_multi_phase.Phase.Unsigned {
      return { type: "Unsigned", value }
    }
    export interface Unsigned {
      type: "Unsigned"
      value: [boolean, u32]
    }
  }
  export interface RawSolution {
    solution: polkadot_runtime.NposCompactSolution16
    score: sp_npos_elections.ElectionScore
    round: u32
  }
  export function RawSolution(value: pallet_election_provider_multi_phase.RawSolution) {
    return value
  }
  export interface ReadySolution {
    supports: Array<[sp_core.crypto.AccountId32, sp_npos_elections.Support]>
    score: sp_npos_elections.ElectionScore
    compute: pallet_election_provider_multi_phase.ElectionCompute
  }
  export function ReadySolution(value: pallet_election_provider_multi_phase.ReadySolution) {
    return value
  }
  export interface RoundSnapshot {
    voters: Array<[sp_core.crypto.AccountId32, u64, Array<sp_core.crypto.AccountId32>]>
    targets: Array<sp_core.crypto.AccountId32>
  }
  export function RoundSnapshot(value: pallet_election_provider_multi_phase.RoundSnapshot) {
    return value
  }
  export interface SolutionOrSnapshotSize {
    voters: Compact<u32>
    targets: Compact<u32>
  }
  export function SolutionOrSnapshotSize(
    value: pallet_election_provider_multi_phase.SolutionOrSnapshotSize,
  ) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_election_provider_multi_phase.pallet.Call> = _codec.$310
    export const $error: $.Codec<pallet_election_provider_multi_phase.pallet.Error> = _codec.$611
    export const $event: $.Codec<pallet_election_provider_multi_phase.pallet.Event> = _codec.$86
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_election_provider_multi_phase.pallet.Call.submit_unsigned
      | pallet_election_provider_multi_phase.pallet.Call.set_minimum_untrusted_score
      | pallet_election_provider_multi_phase.pallet.Call.set_emergency_election_result
      | pallet_election_provider_multi_phase.pallet.Call.submit
      | pallet_election_provider_multi_phase.pallet.Call.governance_fallback
    export namespace Call {
      /**
       * Trigger the governance fallback.
       *
       * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
       * calling [`Call::set_emergency_election_result`].
       */
      export function governance_fallback(
        value: Omit<pallet_election_provider_multi_phase.pallet.Call.governance_fallback, "type">,
      ): pallet_election_provider_multi_phase.pallet.Call.governance_fallback {
        return { type: "governance_fallback", ...value }
      }
      /**
       * Trigger the governance fallback.
       *
       * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
       * calling [`Call::set_emergency_election_result`].
       */
      export interface governance_fallback {
        type: "governance_fallback"
        maybe_max_voters: u32 | undefined
        maybe_max_targets: u32 | undefined
      }
      /**
       * Set a solution in the queue, to be handed out to the client of this pallet in the next
       * call to `ElectionProvider::elect`.
       *
       * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
       *
       * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
       * feasibility check itself can in principle cause the election process to fail (due to
       * memory/weight constrains).
       */
      export function set_emergency_election_result(
        value: Omit<
          pallet_election_provider_multi_phase.pallet.Call.set_emergency_election_result,
          "type"
        >,
      ): pallet_election_provider_multi_phase.pallet.Call.set_emergency_election_result {
        return { type: "set_emergency_election_result", ...value }
      }
      /**
       * Set a solution in the queue, to be handed out to the client of this pallet in the next
       * call to `ElectionProvider::elect`.
       *
       * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
       *
       * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
       * feasibility check itself can in principle cause the election process to fail (due to
       * memory/weight constrains).
       */
      export interface set_emergency_election_result {
        type: "set_emergency_election_result"
        supports: Array<[sp_core.crypto.AccountId32, sp_npos_elections.Support]>
      }
      /**
       * Set a new value for `MinimumUntrustedScore`.
       *
       * Dispatch origin must be aligned with `T::ForceOrigin`.
       *
       * This check can be turned off by setting the value to `None`.
       */
      export function set_minimum_untrusted_score(
        value: Omit<
          pallet_election_provider_multi_phase.pallet.Call.set_minimum_untrusted_score,
          "type"
        >,
      ): pallet_election_provider_multi_phase.pallet.Call.set_minimum_untrusted_score {
        return { type: "set_minimum_untrusted_score", ...value }
      }
      /**
       * Set a new value for `MinimumUntrustedScore`.
       *
       * Dispatch origin must be aligned with `T::ForceOrigin`.
       *
       * This check can be turned off by setting the value to `None`.
       */
      export interface set_minimum_untrusted_score {
        type: "set_minimum_untrusted_score"
        maybe_next_score: sp_npos_elections.ElectionScore | undefined
      }
      /**
       * Submit a solution for the signed phase.
       *
       * The dispatch origin fo this call must be __signed__.
       *
       * The solution is potentially queued, based on the claimed score and processed at the end
       * of the signed phase.
       *
       * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
       * might be rewarded, slashed, or get all or a part of the deposit back.
       */
      export function submit(
        value: Omit<pallet_election_provider_multi_phase.pallet.Call.submit, "type">,
      ): pallet_election_provider_multi_phase.pallet.Call.submit {
        return { type: "submit", ...value }
      }
      /**
       * Submit a solution for the signed phase.
       *
       * The dispatch origin fo this call must be __signed__.
       *
       * The solution is potentially queued, based on the claimed score and processed at the end
       * of the signed phase.
       *
       * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
       * might be rewarded, slashed, or get all or a part of the deposit back.
       */
      export interface submit {
        type: "submit"
        raw_solution: pallet_election_provider_multi_phase.RawSolution
      }
      /**
       * Submit a solution for the unsigned phase.
       *
       * The dispatch origin fo this call must be __none__.
       *
       * This submission is checked on the fly. Moreover, this unsigned solution is only
       * validated when submitted to the pool from the **local** node. Effectively, this means
       * that only active validators can submit this transaction when authoring a block (similar
       * to an inherent).
       *
       * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
       * panic if the solution submitted by the validator is invalid in any way, effectively
       * putting their authoring reward at risk.
       *
       * No deposit or reward is associated with this submission.
       */
      export function submit_unsigned(
        value: Omit<pallet_election_provider_multi_phase.pallet.Call.submit_unsigned, "type">,
      ): pallet_election_provider_multi_phase.pallet.Call.submit_unsigned {
        return { type: "submit_unsigned", ...value }
      }
      /**
       * Submit a solution for the unsigned phase.
       *
       * The dispatch origin fo this call must be __none__.
       *
       * This submission is checked on the fly. Moreover, this unsigned solution is only
       * validated when submitted to the pool from the **local** node. Effectively, this means
       * that only active validators can submit this transaction when authoring a block (similar
       * to an inherent).
       *
       * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
       * panic if the solution submitted by the validator is invalid in any way, effectively
       * putting their authoring reward at risk.
       *
       * No deposit or reward is associated with this submission.
       */
      export interface submit_unsigned {
        type: "submit_unsigned"
        raw_solution: pallet_election_provider_multi_phase.RawSolution
        witness: pallet_election_provider_multi_phase.SolutionOrSnapshotSize
      }
    }
    /** Error of the pallet that can be returned in response to dispatches. */
    export type Error =
      | "PreDispatchEarlySubmission"
      | "PreDispatchWrongWinnerCount"
      | "PreDispatchWeakSubmission"
      | "SignedQueueFull"
      | "SignedCannotPayDeposit"
      | "SignedInvalidWitness"
      | "SignedTooMuchWeight"
      | "OcwCallWrongEra"
      | "MissingSnapshotMetadata"
      | "InvalidSubmissionIndex"
      | "CallNotAllowed"
      | "FallbackFailed"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_election_provider_multi_phase.pallet.Event.SolutionStored
      | pallet_election_provider_multi_phase.pallet.Event.ElectionFinalized
      | pallet_election_provider_multi_phase.pallet.Event.ElectionFailed
      | pallet_election_provider_multi_phase.pallet.Event.Rewarded
      | pallet_election_provider_multi_phase.pallet.Event.Slashed
      | pallet_election_provider_multi_phase.pallet.Event.SignedPhaseStarted
      | pallet_election_provider_multi_phase.pallet.Event.UnsignedPhaseStarted
    export namespace Event {
      /**
       * An election failed.
       *
       * Not much can be said about which computes failed in the process.
       */
      export function ElectionFailed(): pallet_election_provider_multi_phase.pallet.Event.ElectionFailed {
        return { type: "ElectionFailed" }
      }
      /**
       * An election failed.
       *
       * Not much can be said about which computes failed in the process.
       */
      export interface ElectionFailed {
        type: "ElectionFailed"
      }
      /** The election has been finalized, with the given computation and score. */
      export function ElectionFinalized(
        value: Omit<pallet_election_provider_multi_phase.pallet.Event.ElectionFinalized, "type">,
      ): pallet_election_provider_multi_phase.pallet.Event.ElectionFinalized {
        return { type: "ElectionFinalized", ...value }
      }
      /** The election has been finalized, with the given computation and score. */
      export interface ElectionFinalized {
        type: "ElectionFinalized"
        compute: pallet_election_provider_multi_phase.ElectionCompute
        score: sp_npos_elections.ElectionScore
      }
      /** An account has been rewarded for their signed submission being finalized. */
      export function Rewarded(
        value: Omit<pallet_election_provider_multi_phase.pallet.Event.Rewarded, "type">,
      ): pallet_election_provider_multi_phase.pallet.Event.Rewarded {
        return { type: "Rewarded", ...value }
      }
      /** An account has been rewarded for their signed submission being finalized. */
      export interface Rewarded {
        type: "Rewarded"
        account: sp_core.crypto.AccountId32
        value: u128
      }
      /** The signed phase of the given round has started. */
      export function SignedPhaseStarted(
        value: Omit<pallet_election_provider_multi_phase.pallet.Event.SignedPhaseStarted, "type">,
      ): pallet_election_provider_multi_phase.pallet.Event.SignedPhaseStarted {
        return { type: "SignedPhaseStarted", ...value }
      }
      /** The signed phase of the given round has started. */
      export interface SignedPhaseStarted {
        type: "SignedPhaseStarted"
        round: u32
      }
      /** An account has been slashed for submitting an invalid signed submission. */
      export function Slashed(
        value: Omit<pallet_election_provider_multi_phase.pallet.Event.Slashed, "type">,
      ): pallet_election_provider_multi_phase.pallet.Event.Slashed {
        return { type: "Slashed", ...value }
      }
      /** An account has been slashed for submitting an invalid signed submission. */
      export interface Slashed {
        type: "Slashed"
        account: sp_core.crypto.AccountId32
        value: u128
      }
      /**
       * A solution was stored with the given compute.
       *
       * If the solution is signed, this means that it hasn't yet been processed. If the
       * solution is unsigned, this means that it has also been processed.
       *
       * The `bool` is `true` when a previous solution was ejected to make room for this one.
       */
      export function SolutionStored(
        value: Omit<pallet_election_provider_multi_phase.pallet.Event.SolutionStored, "type">,
      ): pallet_election_provider_multi_phase.pallet.Event.SolutionStored {
        return { type: "SolutionStored", ...value }
      }
      /**
       * A solution was stored with the given compute.
       *
       * If the solution is signed, this means that it hasn't yet been processed. If the
       * solution is unsigned, this means that it has also been processed.
       *
       * The `bool` is `true` when a previous solution was ejected to make room for this one.
       */
      export interface SolutionStored {
        type: "SolutionStored"
        compute: pallet_election_provider_multi_phase.ElectionCompute
        prev_ejected: boolean
      }
      /** The unsigned phase of the given round has started. */
      export function UnsignedPhaseStarted(
        value: Omit<pallet_election_provider_multi_phase.pallet.Event.UnsignedPhaseStarted, "type">,
      ): pallet_election_provider_multi_phase.pallet.Event.UnsignedPhaseStarted {
        return { type: "UnsignedPhaseStarted", ...value }
      }
      /** The unsigned phase of the given round has started. */
      export interface UnsignedPhaseStarted {
        type: "UnsignedPhaseStarted"
        round: u32
      }
    }
  }
  export namespace signed {
    export const $signedSubmission: $.Codec<
      pallet_election_provider_multi_phase.signed.SignedSubmission
    > = _codec.$610
    export interface SignedSubmission {
      who: sp_core.crypto.AccountId32
      deposit: u128
      raw_solution: pallet_election_provider_multi_phase.RawSolution
      call_fee: u128
    }
    export function SignedSubmission(
      value: pallet_election_provider_multi_phase.signed.SignedSubmission,
    ) {
      return value
    }
  }
}
export namespace pallet_elections_phragmen {
  export const $renouncing: $.Codec<pallet_elections_phragmen.Renouncing> = _codec.$242
  export const $seatHolder: $.Codec<pallet_elections_phragmen.SeatHolder> = _codec.$551
  export const $voter: $.Codec<pallet_elections_phragmen.Voter> = _codec.$552
  export type Renouncing =
    | pallet_elections_phragmen.Renouncing.Member
    | pallet_elections_phragmen.Renouncing.RunnerUp
    | pallet_elections_phragmen.Renouncing.Candidate
  export namespace Renouncing {
    export function Candidate(
      value: pallet_elections_phragmen.Renouncing.Candidate["value"],
    ): pallet_elections_phragmen.Renouncing.Candidate {
      return { type: "Candidate", value }
    }
    export interface Candidate {
      type: "Candidate"
      value: Compact<u32>
    }
    export function Member(): pallet_elections_phragmen.Renouncing.Member {
      return { type: "Member" }
    }
    export interface Member {
      type: "Member"
    }
    export function RunnerUp(): pallet_elections_phragmen.Renouncing.RunnerUp {
      return { type: "RunnerUp" }
    }
    export interface RunnerUp {
      type: "RunnerUp"
    }
  }
  export interface SeatHolder {
    who: sp_core.crypto.AccountId32
    stake: u128
    deposit: u128
  }
  export function SeatHolder(value: pallet_elections_phragmen.SeatHolder) {
    return value
  }
  export interface Voter {
    votes: Array<sp_core.crypto.AccountId32>
    stake: u128
    deposit: u128
  }
  export function Voter(value: pallet_elections_phragmen.Voter) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_elections_phragmen.pallet.Call> = _codec.$241
    export const $error: $.Codec<pallet_elections_phragmen.pallet.Error> = _codec.$553
    export const $event: $.Codec<pallet_elections_phragmen.pallet.Event> = _codec.$67
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_elections_phragmen.pallet.Call.vote
      | pallet_elections_phragmen.pallet.Call.remove_voter
      | pallet_elections_phragmen.pallet.Call.submit_candidacy
      | pallet_elections_phragmen.pallet.Call.renounce_candidacy
      | pallet_elections_phragmen.pallet.Call.remove_member
      | pallet_elections_phragmen.pallet.Call.clean_defunct_voters
    export namespace Call {
      /**
       * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
       * deposit of the removed voters are returned.
       *
       * This is an root function to be used only for cleaning the state.
       *
       * The dispatch origin of this call must be root.
       *
       * # <weight>
       * The total number of voters and those that are defunct must be provided as witness data.
       * # </weight>
       */
      export function clean_defunct_voters(
        value: Omit<pallet_elections_phragmen.pallet.Call.clean_defunct_voters, "type">,
      ): pallet_elections_phragmen.pallet.Call.clean_defunct_voters {
        return { type: "clean_defunct_voters", ...value }
      }
      /**
       * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
       * deposit of the removed voters are returned.
       *
       * This is an root function to be used only for cleaning the state.
       *
       * The dispatch origin of this call must be root.
       *
       * # <weight>
       * The total number of voters and those that are defunct must be provided as witness data.
       * # </weight>
       */
      export interface clean_defunct_voters {
        type: "clean_defunct_voters"
        num_voters: u32
        num_defunct: u32
      }
      /**
       * Remove a particular member from the set. This is effective immediately and the bond of
       * the outgoing member is slashed.
       *
       * If a runner-up is available, then the best runner-up will be removed and replaces the
       * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
       * started, else, nothing happens.
       *
       * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
       * it is returned.
       *
       * The dispatch origin of this call must be root.
       *
       * Note that this does not affect the designated block number of the next election.
       *
       * # <weight>
       * If we have a replacement, we use a small weight. Else, since this is a root call and
       * will go into phragmen, we assume full block for now.
       * # </weight>
       */
      export function remove_member(
        value: Omit<pallet_elections_phragmen.pallet.Call.remove_member, "type">,
      ): pallet_elections_phragmen.pallet.Call.remove_member {
        return { type: "remove_member", ...value }
      }
      /**
       * Remove a particular member from the set. This is effective immediately and the bond of
       * the outgoing member is slashed.
       *
       * If a runner-up is available, then the best runner-up will be removed and replaces the
       * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
       * started, else, nothing happens.
       *
       * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
       * it is returned.
       *
       * The dispatch origin of this call must be root.
       *
       * Note that this does not affect the designated block number of the next election.
       *
       * # <weight>
       * If we have a replacement, we use a small weight. Else, since this is a root call and
       * will go into phragmen, we assume full block for now.
       * # </weight>
       */
      export interface remove_member {
        type: "remove_member"
        who: sp_runtime.multiaddress.MultiAddress
        slash_bond: boolean
        rerun_election: boolean
      }
      /**
       * Remove `origin` as a voter.
       *
       * This removes the lock and returns the deposit.
       *
       * The dispatch origin of this call must be signed and be a voter.
       */
      export function remove_voter(): pallet_elections_phragmen.pallet.Call.remove_voter {
        return { type: "remove_voter" }
      }
      /**
       * Remove `origin` as a voter.
       *
       * This removes the lock and returns the deposit.
       *
       * The dispatch origin of this call must be signed and be a voter.
       */
      export interface remove_voter {
        type: "remove_voter"
      }
      /**
       * Renounce one's intention to be a candidate for the next election round. 3 potential
       * outcomes exist:
       *
       * - `origin` is a candidate and not elected in any set. In this case, the deposit is
       *   unreserved, returned and origin is removed as a candidate.
       * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
       *   origin is removed as a runner-up.
       * - `origin` is a current member. In this case, the deposit is unreserved and origin is
       *   removed as a member, consequently not being a candidate for the next round anymore.
       *   Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
       *   are immediately used. If the prime is renouncing, then no prime will exist until the
       *   next round.
       *
       * The dispatch origin of this call must be signed, and have one of the above roles.
       *
       * # <weight>
       * The type of renouncing must be provided as witness data.
       * # </weight>
       */
      export function renounce_candidacy(
        value: Omit<pallet_elections_phragmen.pallet.Call.renounce_candidacy, "type">,
      ): pallet_elections_phragmen.pallet.Call.renounce_candidacy {
        return { type: "renounce_candidacy", ...value }
      }
      /**
       * Renounce one's intention to be a candidate for the next election round. 3 potential
       * outcomes exist:
       *
       * - `origin` is a candidate and not elected in any set. In this case, the deposit is
       *   unreserved, returned and origin is removed as a candidate.
       * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
       *   origin is removed as a runner-up.
       * - `origin` is a current member. In this case, the deposit is unreserved and origin is
       *   removed as a member, consequently not being a candidate for the next round anymore.
       *   Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
       *   are immediately used. If the prime is renouncing, then no prime will exist until the
       *   next round.
       *
       * The dispatch origin of this call must be signed, and have one of the above roles.
       *
       * # <weight>
       * The type of renouncing must be provided as witness data.
       * # </weight>
       */
      export interface renounce_candidacy {
        type: "renounce_candidacy"
        renouncing: pallet_elections_phragmen.Renouncing
      }
      /**
       * Submit oneself for candidacy. A fixed amount of deposit is recorded.
       *
       * All candidates are wiped at the end of the term. They either become a member/runner-up,
       * or leave the system while their deposit is slashed.
       *
       * The dispatch origin of this call must be signed.
       *
       * ### Warning
       *
       * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
       * to get their deposit back. Losing the spot in an election will always lead to a slash.
       *
       * # <weight>
       * The number of current candidates must be provided as witness data.
       * # </weight>
       */
      export function submit_candidacy(
        value: Omit<pallet_elections_phragmen.pallet.Call.submit_candidacy, "type">,
      ): pallet_elections_phragmen.pallet.Call.submit_candidacy {
        return { type: "submit_candidacy", ...value }
      }
      /**
       * Submit oneself for candidacy. A fixed amount of deposit is recorded.
       *
       * All candidates are wiped at the end of the term. They either become a member/runner-up,
       * or leave the system while their deposit is slashed.
       *
       * The dispatch origin of this call must be signed.
       *
       * ### Warning
       *
       * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
       * to get their deposit back. Losing the spot in an election will always lead to a slash.
       *
       * # <weight>
       * The number of current candidates must be provided as witness data.
       * # </weight>
       */
      export interface submit_candidacy {
        type: "submit_candidacy"
        candidate_count: Compact<u32>
      }
      /**
       * Vote for a set of candidates for the upcoming round of election. This can be called to
       * set the initial votes, or update already existing votes.
       *
       * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
       * reserved. The deposit is based on the number of votes and can be updated over time.
       *
       * The `votes` should:
       *   - not be empty.
       *   - be less than the number of possible candidates. Note that all current members and
       *     runners-up are also automatically candidates for the next round.
       *
       * If `value` is more than `who`'s free balance, then the maximum of the two is used.
       *
       * The dispatch origin of this call must be signed.
       *
       * ### Warning
       *
       * It is the responsibility of the caller to **NOT** place all of their balance into the
       * lock and keep some for further operations.
       *
       * # <weight>
       * We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
       * # </weight>
       */
      export function vote(
        value: Omit<pallet_elections_phragmen.pallet.Call.vote, "type">,
      ): pallet_elections_phragmen.pallet.Call.vote {
        return { type: "vote", ...value }
      }
      /**
       * Vote for a set of candidates for the upcoming round of election. This can be called to
       * set the initial votes, or update already existing votes.
       *
       * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
       * reserved. The deposit is based on the number of votes and can be updated over time.
       *
       * The `votes` should:
       *   - not be empty.
       *   - be less than the number of possible candidates. Note that all current members and
       *     runners-up are also automatically candidates for the next round.
       *
       * If `value` is more than `who`'s free balance, then the maximum of the two is used.
       *
       * The dispatch origin of this call must be signed.
       *
       * ### Warning
       *
       * It is the responsibility of the caller to **NOT** place all of their balance into the
       * lock and keep some for further operations.
       *
       * # <weight>
       * We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
       * # </weight>
       */
      export interface vote {
        type: "vote"
        votes: Array<sp_core.crypto.AccountId32>
        value: Compact<u128>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "UnableToVote"
      | "NoVotes"
      | "TooManyVotes"
      | "MaximumVotesExceeded"
      | "LowBalance"
      | "UnableToPayBond"
      | "MustBeVoter"
      | "DuplicatedCandidate"
      | "TooManyCandidates"
      | "MemberSubmit"
      | "RunnerUpSubmit"
      | "InsufficientCandidateFunds"
      | "NotMember"
      | "InvalidWitnessData"
      | "InvalidVoteCount"
      | "InvalidRenouncing"
      | "InvalidReplacement"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_elections_phragmen.pallet.Event.NewTerm
      | pallet_elections_phragmen.pallet.Event.EmptyTerm
      | pallet_elections_phragmen.pallet.Event.ElectionError
      | pallet_elections_phragmen.pallet.Event.MemberKicked
      | pallet_elections_phragmen.pallet.Event.Renounced
      | pallet_elections_phragmen.pallet.Event.CandidateSlashed
      | pallet_elections_phragmen.pallet.Event.SeatHolderSlashed
    export namespace Event {
      /**
       * A candidate was slashed by amount due to failing to obtain a seat as member or
       * runner-up.
       *
       * Note that old members and runners-up are also candidates.
       */
      export function CandidateSlashed(
        value: Omit<pallet_elections_phragmen.pallet.Event.CandidateSlashed, "type">,
      ): pallet_elections_phragmen.pallet.Event.CandidateSlashed {
        return { type: "CandidateSlashed", ...value }
      }
      /**
       * A candidate was slashed by amount due to failing to obtain a seat as member or
       * runner-up.
       *
       * Note that old members and runners-up are also candidates.
       */
      export interface CandidateSlashed {
        type: "CandidateSlashed"
        candidate: sp_core.crypto.AccountId32
        amount: u128
      }
      /** Internal error happened while trying to perform election. */
      export function ElectionError(): pallet_elections_phragmen.pallet.Event.ElectionError {
        return { type: "ElectionError" }
      }
      /** Internal error happened while trying to perform election. */
      export interface ElectionError {
        type: "ElectionError"
      }
      /**
       * No (or not enough) candidates existed for this round. This is different from
       * `NewTerm(\[\])`. See the description of `NewTerm`.
       */
      export function EmptyTerm(): pallet_elections_phragmen.pallet.Event.EmptyTerm {
        return { type: "EmptyTerm" }
      }
      /**
       * No (or not enough) candidates existed for this round. This is different from
       * `NewTerm(\[\])`. See the description of `NewTerm`.
       */
      export interface EmptyTerm {
        type: "EmptyTerm"
      }
      /**
       * A member has been removed. This should always be followed by either `NewTerm` or
       * `EmptyTerm`.
       */
      export function MemberKicked(
        value: Omit<pallet_elections_phragmen.pallet.Event.MemberKicked, "type">,
      ): pallet_elections_phragmen.pallet.Event.MemberKicked {
        return { type: "MemberKicked", ...value }
      }
      /**
       * A member has been removed. This should always be followed by either `NewTerm` or
       * `EmptyTerm`.
       */
      export interface MemberKicked {
        type: "MemberKicked"
        member: sp_core.crypto.AccountId32
      }
      /**
       * A new term with new_members. This indicates that enough candidates existed to run
       * the election, not that enough have has been elected. The inner value must be examined
       * for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
       * slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
       * begin with.
       */
      export function NewTerm(
        value: Omit<pallet_elections_phragmen.pallet.Event.NewTerm, "type">,
      ): pallet_elections_phragmen.pallet.Event.NewTerm {
        return { type: "NewTerm", ...value }
      }
      /**
       * A new term with new_members. This indicates that enough candidates existed to run
       * the election, not that enough have has been elected. The inner value must be examined
       * for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
       * slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
       * begin with.
       */
      export interface NewTerm {
        type: "NewTerm"
        new_members: Array<[sp_core.crypto.AccountId32, u128]>
      }
      /** Someone has renounced their candidacy. */
      export function Renounced(
        value: Omit<pallet_elections_phragmen.pallet.Event.Renounced, "type">,
      ): pallet_elections_phragmen.pallet.Event.Renounced {
        return { type: "Renounced", ...value }
      }
      /** Someone has renounced their candidacy. */
      export interface Renounced {
        type: "Renounced"
        candidate: sp_core.crypto.AccountId32
      }
      /** A seat holder was slashed by amount by being forcefully removed from the set. */
      export function SeatHolderSlashed(
        value: Omit<pallet_elections_phragmen.pallet.Event.SeatHolderSlashed, "type">,
      ): pallet_elections_phragmen.pallet.Event.SeatHolderSlashed {
        return { type: "SeatHolderSlashed", ...value }
      }
      /** A seat holder was slashed by amount by being forcefully removed from the set. */
      export interface SeatHolderSlashed {
        type: "SeatHolderSlashed"
        seat_holder: sp_core.crypto.AccountId32
        amount: u128
      }
    }
  }
}
export namespace pallet_fast_unstake {
  export namespace pallet {
    export const $call: $.Codec<pallet_fast_unstake.pallet.Call> = _codec.$374
    export const $error: $.Codec<pallet_fast_unstake.pallet.Error> = _codec.$637
    export const $event: $.Codec<pallet_fast_unstake.pallet.Event> = _codec.$93
    export const $maxChecking: $.Codec<pallet_fast_unstake.pallet.MaxChecking> = _codec.$635
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_fast_unstake.pallet.Call.register_fast_unstake
      | pallet_fast_unstake.pallet.Call.deregister
      | pallet_fast_unstake.pallet.Call.control
    export namespace Call {
      /**
       * Control the operation of this pallet.
       *
       * Dispatch origin must be signed by the [`Config::ControlOrigin`].
       */
      export function control(
        value: Omit<pallet_fast_unstake.pallet.Call.control, "type">,
      ): pallet_fast_unstake.pallet.Call.control {
        return { type: "control", ...value }
      }
      /**
       * Control the operation of this pallet.
       *
       * Dispatch origin must be signed by the [`Config::ControlOrigin`].
       */
      export interface control {
        type: "control"
        unchecked_eras_to_check: u32
      }
      /**
       * Deregister oneself from the fast-unstake.
       *
       * This is useful if one is registered, they are still waiting, and they change their mind.
       *
       * Note that the associated stash is still fully unbonded and chilled as a consequence of
       * calling `register_fast_unstake`. This should probably be followed by a call to
       * `Staking::rebond`.
       */
      export function deregister(): pallet_fast_unstake.pallet.Call.deregister {
        return { type: "deregister" }
      }
      /**
       * Deregister oneself from the fast-unstake.
       *
       * This is useful if one is registered, they are still waiting, and they change their mind.
       *
       * Note that the associated stash is still fully unbonded and chilled as a consequence of
       * calling `register_fast_unstake`. This should probably be followed by a call to
       * `Staking::rebond`.
       */
      export interface deregister {
        type: "deregister"
      }
      /**
       * Register oneself for fast-unstake.
       *
       * The dispatch origin of this call must be signed by the controller account, similar to
       * `staking::unbond`.
       *
       * The stash associated with the origin must have no ongoing unlocking chunks. If
       * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
       * to be checked in further blocks.
       *
       * If by the time this is called, the stash is actually eligible for fast-unstake, then
       * they are guaranteed to remain eligible, because the call will chill them as well.
       *
       * If the check works, the entire staking data is removed, i.e. the stash is fully
       * unstaked.
       *
       * If the check fails, the stash remains chilled and waiting for being unbonded as in with
       * the normal staking system, but they lose part of their unbonding chunks due to consuming
       * the chain's resources.
       */
      export function register_fast_unstake(): pallet_fast_unstake.pallet.Call.register_fast_unstake {
        return { type: "register_fast_unstake" }
      }
      /**
       * Register oneself for fast-unstake.
       *
       * The dispatch origin of this call must be signed by the controller account, similar to
       * `staking::unbond`.
       *
       * The stash associated with the origin must have no ongoing unlocking chunks. If
       * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
       * to be checked in further blocks.
       *
       * If by the time this is called, the stash is actually eligible for fast-unstake, then
       * they are guaranteed to remain eligible, because the call will chill them as well.
       *
       * If the check works, the entire staking data is removed, i.e. the stash is fully
       * unstaked.
       *
       * If the check fails, the stash remains chilled and waiting for being unbonded as in with
       * the normal staking system, but they lose part of their unbonding chunks due to consuming
       * the chain's resources.
       */
      export interface register_fast_unstake {
        type: "register_fast_unstake"
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "NotController"
      | "AlreadyQueued"
      | "NotFullyBonded"
      | "NotQueued"
      | "AlreadyHead"
      | "CallNotAllowed"
    /** The events of this pallet. */
    export type Event =
      | pallet_fast_unstake.pallet.Event.Unstaked
      | pallet_fast_unstake.pallet.Event.Slashed
      | pallet_fast_unstake.pallet.Event.Checking
      | pallet_fast_unstake.pallet.Event.Errored
      | pallet_fast_unstake.pallet.Event.InternalError
    export namespace Event {
      /** A staker was partially checked for the given eras, but the process did not finish. */
      export function Checking(
        value: Omit<pallet_fast_unstake.pallet.Event.Checking, "type">,
      ): pallet_fast_unstake.pallet.Event.Checking {
        return { type: "Checking", ...value }
      }
      /** A staker was partially checked for the given eras, but the process did not finish. */
      export interface Checking {
        type: "Checking"
        stash: sp_core.crypto.AccountId32
        eras: Array<u32>
      }
      /**
       * Some internal error happened while migrating stash. They are removed as head as a
       * consequence.
       */
      export function Errored(
        value: Omit<pallet_fast_unstake.pallet.Event.Errored, "type">,
      ): pallet_fast_unstake.pallet.Event.Errored {
        return { type: "Errored", ...value }
      }
      /**
       * Some internal error happened while migrating stash. They are removed as head as a
       * consequence.
       */
      export interface Errored {
        type: "Errored"
        stash: sp_core.crypto.AccountId32
      }
      /** An internal error happened. Operations will be paused now. */
      export function InternalError(): pallet_fast_unstake.pallet.Event.InternalError {
        return { type: "InternalError" }
      }
      /** An internal error happened. Operations will be paused now. */
      export interface InternalError {
        type: "InternalError"
      }
      /** A staker was slashed for requesting fast-unstake whilst being exposed. */
      export function Slashed(
        value: Omit<pallet_fast_unstake.pallet.Event.Slashed, "type">,
      ): pallet_fast_unstake.pallet.Event.Slashed {
        return { type: "Slashed", ...value }
      }
      /** A staker was slashed for requesting fast-unstake whilst being exposed. */
      export interface Slashed {
        type: "Slashed"
        stash: sp_core.crypto.AccountId32
        amount: u128
      }
      /** A staker was unstaked. */
      export function Unstaked(
        value: Omit<pallet_fast_unstake.pallet.Event.Unstaked, "type">,
      ): pallet_fast_unstake.pallet.Event.Unstaked {
        return { type: "Unstaked", ...value }
      }
      /** A staker was unstaked. */
      export interface Unstaked {
        type: "Unstaked"
        stash: sp_core.crypto.AccountId32
        result: null | ChainError<sp_runtime.DispatchError>
      }
    }
    export function MaxChecking() {
      return null
    }
    export type MaxChecking = null
  }
  export namespace types {
    export const $unstakeRequest: $.Codec<pallet_fast_unstake.types.UnstakeRequest> = _codec.$634
    export interface UnstakeRequest {
      stash: sp_core.crypto.AccountId32
      checked: Array<u32>
      deposit: u128
    }
    export function UnstakeRequest(value: pallet_fast_unstake.types.UnstakeRequest) {
      return value
    }
  }
}
export namespace pallet_grandpa {
  export const $storedPendingChange: $.Codec<pallet_grandpa.StoredPendingChange> = _codec.$517
  export const $storedState: $.Codec<pallet_grandpa.StoredState> = _codec.$516
  export interface StoredPendingChange {
    scheduled_at: u32
    delay: u32
    next_authorities: Array<[sp_finality_grandpa.app.Public, u64]>
    forced: u32 | undefined
  }
  export function StoredPendingChange(value: pallet_grandpa.StoredPendingChange) {
    return value
  }
  export type StoredState =
    | pallet_grandpa.StoredState.Live
    | pallet_grandpa.StoredState.PendingPause
    | pallet_grandpa.StoredState.Paused
    | pallet_grandpa.StoredState.PendingResume
  export namespace StoredState {
    export function Live(): pallet_grandpa.StoredState.Live {
      return { type: "Live" }
    }
    export interface Live {
      type: "Live"
    }
    export function Paused(): pallet_grandpa.StoredState.Paused {
      return { type: "Paused" }
    }
    export interface Paused {
      type: "Paused"
    }
    export function PendingPause(
      value: Omit<pallet_grandpa.StoredState.PendingPause, "type">,
    ): pallet_grandpa.StoredState.PendingPause {
      return { type: "PendingPause", ...value }
    }
    export interface PendingPause {
      type: "PendingPause"
      scheduled_at: u32
      delay: u32
    }
    export function PendingResume(
      value: Omit<pallet_grandpa.StoredState.PendingResume, "type">,
    ): pallet_grandpa.StoredState.PendingResume {
      return { type: "PendingResume", ...value }
    }
    export interface PendingResume {
      type: "PendingResume"
      scheduled_at: u32
      delay: u32
    }
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_grandpa.pallet.Call> = _codec.$216
    export const $error: $.Codec<pallet_grandpa.pallet.Error> = _codec.$519
    export const $event: $.Codec<pallet_grandpa.pallet.Event> = _codec.$47
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_grandpa.pallet.Call.report_equivocation
      | pallet_grandpa.pallet.Call.report_equivocation_unsigned
      | pallet_grandpa.pallet.Call.note_stalled
    export namespace Call {
      /**
       * Note that the current authority set of the GRANDPA finality gadget has stalled.
       *
       * This will trigger a forced authority set change at the beginning of the next session, to
       * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
       * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
       * The block production rate (which may be slowed down because of finality lagging) should
       * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
       * authority will start voting on top of `best_finalized_block_number` for new finalized
       * blocks. `best_finalized_block_number` should be the highest of the latest finalized
       * block of all validators of the new authority set.
       *
       * Only callable by root.
       */
      export function note_stalled(
        value: Omit<pallet_grandpa.pallet.Call.note_stalled, "type">,
      ): pallet_grandpa.pallet.Call.note_stalled {
        return { type: "note_stalled", ...value }
      }
      /**
       * Note that the current authority set of the GRANDPA finality gadget has stalled.
       *
       * This will trigger a forced authority set change at the beginning of the next session, to
       * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
       * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
       * The block production rate (which may be slowed down because of finality lagging) should
       * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
       * authority will start voting on top of `best_finalized_block_number` for new finalized
       * blocks. `best_finalized_block_number` should be the highest of the latest finalized
       * block of all validators of the new authority set.
       *
       * Only callable by root.
       */
      export interface note_stalled {
        type: "note_stalled"
        delay: u32
        best_finalized_block_number: u32
      }
      /**
       * Report voter equivocation/misbehavior. This method will verify the
       * equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence
       * will be reported.
       */
      export function report_equivocation(
        value: Omit<pallet_grandpa.pallet.Call.report_equivocation, "type">,
      ): pallet_grandpa.pallet.Call.report_equivocation {
        return { type: "report_equivocation", ...value }
      }
      /**
       * Report voter equivocation/misbehavior. This method will verify the
       * equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence
       * will be reported.
       */
      export interface report_equivocation {
        type: "report_equivocation"
        equivocation_proof: sp_finality_grandpa.EquivocationProof
        key_owner_proof: sp_session.MembershipProof
      }
      /**
       * Report voter equivocation/misbehavior. This method will verify the
       * equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence
       * will be reported.
       *
       * This extrinsic must be called unsigned and it is expected that only
       * block authors will call it (validated in `ValidateUnsigned`), as such
       * if the block author is defined it will be defined as the equivocation
       * reporter.
       */
      export function report_equivocation_unsigned(
        value: Omit<pallet_grandpa.pallet.Call.report_equivocation_unsigned, "type">,
      ): pallet_grandpa.pallet.Call.report_equivocation_unsigned {
        return { type: "report_equivocation_unsigned", ...value }
      }
      /**
       * Report voter equivocation/misbehavior. This method will verify the
       * equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence
       * will be reported.
       *
       * This extrinsic must be called unsigned and it is expected that only
       * block authors will call it (validated in `ValidateUnsigned`), as such
       * if the block author is defined it will be defined as the equivocation
       * reporter.
       */
      export interface report_equivocation_unsigned {
        type: "report_equivocation_unsigned"
        equivocation_proof: sp_finality_grandpa.EquivocationProof
        key_owner_proof: sp_session.MembershipProof
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "PauseFailed"
      | "ResumeFailed"
      | "ChangePending"
      | "TooSoon"
      | "InvalidKeyOwnershipProof"
      | "InvalidEquivocationProof"
      | "DuplicateOffenceReport"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_grandpa.pallet.Event.NewAuthorities
      | pallet_grandpa.pallet.Event.Paused
      | pallet_grandpa.pallet.Event.Resumed
    export namespace Event {
      /** New authority set has been applied. */
      export function NewAuthorities(
        value: Omit<pallet_grandpa.pallet.Event.NewAuthorities, "type">,
      ): pallet_grandpa.pallet.Event.NewAuthorities {
        return { type: "NewAuthorities", ...value }
      }
      /** New authority set has been applied. */
      export interface NewAuthorities {
        type: "NewAuthorities"
        authority_set: Array<[sp_finality_grandpa.app.Public, u64]>
      }
      /** Current authority set has been paused. */
      export function Paused(): pallet_grandpa.pallet.Event.Paused {
        return { type: "Paused" }
      }
      /** Current authority set has been paused. */
      export interface Paused {
        type: "Paused"
      }
      /** Current authority set has been resumed. */
      export function Resumed(): pallet_grandpa.pallet.Event.Resumed {
        return { type: "Resumed" }
      }
      /** Current authority set has been resumed. */
      export interface Resumed {
        type: "Resumed"
      }
    }
  }
}
export namespace pallet_identity {
  export namespace pallet {
    export const $call: $.Codec<pallet_identity.pallet.Call> = _codec.$263
    export const $error: $.Codec<pallet_identity.pallet.Error> = _codec.$578
    export const $event: $.Codec<pallet_identity.pallet.Event> = _codec.$77
    /** Identity pallet declaration. */
    export type Call =
      | pallet_identity.pallet.Call.add_registrar
      | pallet_identity.pallet.Call.set_identity
      | pallet_identity.pallet.Call.set_subs
      | pallet_identity.pallet.Call.clear_identity
      | pallet_identity.pallet.Call.request_judgement
      | pallet_identity.pallet.Call.cancel_request
      | pallet_identity.pallet.Call.set_fee
      | pallet_identity.pallet.Call.set_account_id
      | pallet_identity.pallet.Call.set_fields
      | pallet_identity.pallet.Call.provide_judgement
      | pallet_identity.pallet.Call.kill_identity
      | pallet_identity.pallet.Call.add_sub
      | pallet_identity.pallet.Call.rename_sub
      | pallet_identity.pallet.Call.remove_sub
      | pallet_identity.pallet.Call.quit_sub
    export namespace Call {
      /**
       * Add a registrar to the system.
       *
       * The dispatch origin for this call must be `T::RegistrarOrigin`.
       *
       * - `account`: the account of the registrar.
       *
       * Emits `RegistrarAdded` if successful.
       *
       * # <weight>
       * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
       * - One storage mutation (codec `O(R)`).
       * - One event.
       * # </weight>
       */
      export function add_registrar(
        value: Omit<pallet_identity.pallet.Call.add_registrar, "type">,
      ): pallet_identity.pallet.Call.add_registrar {
        return { type: "add_registrar", ...value }
      }
      /**
       * Add a registrar to the system.
       *
       * The dispatch origin for this call must be `T::RegistrarOrigin`.
       *
       * - `account`: the account of the registrar.
       *
       * Emits `RegistrarAdded` if successful.
       *
       * # <weight>
       * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
       * - One storage mutation (codec `O(R)`).
       * - One event.
       * # </weight>
       */
      export interface add_registrar {
        type: "add_registrar"
        account: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Add the given account to the sender's subs.
       *
       * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
       * to the sender.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * sub identity of `sub`.
       */
      export function add_sub(
        value: Omit<pallet_identity.pallet.Call.add_sub, "type">,
      ): pallet_identity.pallet.Call.add_sub {
        return { type: "add_sub", ...value }
      }
      /**
       * Add the given account to the sender's subs.
       *
       * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
       * to the sender.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * sub identity of `sub`.
       */
      export interface add_sub {
        type: "add_sub"
        sub: sp_runtime.multiaddress.MultiAddress
        data: pallet_identity.types.Data
      }
      /**
       * Cancel a previous request.
       *
       * Payment: A previously reserved deposit is returned on success.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a
       * registered identity.
       *
       * - `reg_index`: The index of the registrar whose judgement is no longer requested.
       *
       * Emits `JudgementUnrequested` if successful.
       *
       * # <weight>
       * - `O(R + X)`.
       * - One balance-reserve operation.
       * - One storage mutation `O(R + X)`.
       * - One event
       * # </weight>
       */
      export function cancel_request(
        value: Omit<pallet_identity.pallet.Call.cancel_request, "type">,
      ): pallet_identity.pallet.Call.cancel_request {
        return { type: "cancel_request", ...value }
      }
      /**
       * Cancel a previous request.
       *
       * Payment: A previously reserved deposit is returned on success.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a
       * registered identity.
       *
       * - `reg_index`: The index of the registrar whose judgement is no longer requested.
       *
       * Emits `JudgementUnrequested` if successful.
       *
       * # <weight>
       * - `O(R + X)`.
       * - One balance-reserve operation.
       * - One storage mutation `O(R + X)`.
       * - One event
       * # </weight>
       */
      export interface cancel_request {
        type: "cancel_request"
        reg_index: u32
      }
      /**
       * Clear an account's identity info and all sub-accounts and return all deposits.
       *
       * Payment: All reserved balances on the account are returned.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * identity.
       *
       * Emits `IdentityCleared` if successful.
       *
       * # <weight>
       * - `O(R + S + X)`
       *   - where `R` registrar-count (governance-bounded).
       *   - where `S` subs-count (hard- and deposit-bounded).
       *   - where `X` additional-field-count (deposit-bounded and code-bounded).
       * - One balance-unreserve operation.
       * - `2` storage reads and `S + 2` storage deletions.
       * - One event.
       * # </weight>
       */
      export function clear_identity(): pallet_identity.pallet.Call.clear_identity {
        return { type: "clear_identity" }
      }
      /**
       * Clear an account's identity info and all sub-accounts and return all deposits.
       *
       * Payment: All reserved balances on the account are returned.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * identity.
       *
       * Emits `IdentityCleared` if successful.
       *
       * # <weight>
       * - `O(R + S + X)`
       *   - where `R` registrar-count (governance-bounded).
       *   - where `S` subs-count (hard- and deposit-bounded).
       *   - where `X` additional-field-count (deposit-bounded and code-bounded).
       * - One balance-unreserve operation.
       * - `2` storage reads and `S + 2` storage deletions.
       * - One event.
       * # </weight>
       */
      export interface clear_identity {
        type: "clear_identity"
      }
      /**
       * Remove an account's identity and sub-account information and slash the deposits.
       *
       * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
       * `Slash`. Verification request deposits are not returned; they should be cancelled
       * manually using `cancel_request`.
       *
       * The dispatch origin for this call must match `T::ForceOrigin`.
       *
       * - `target`: the account whose identity the judgement is upon. This must be an account
       *   with a registered identity.
       *
       * Emits `IdentityKilled` if successful.
       *
       * # <weight>
       * - `O(R + S + X)`.
       * - One balance-reserve operation.
       * - `S + 2` storage mutations.
       * - One event.
       * # </weight>
       */
      export function kill_identity(
        value: Omit<pallet_identity.pallet.Call.kill_identity, "type">,
      ): pallet_identity.pallet.Call.kill_identity {
        return { type: "kill_identity", ...value }
      }
      /**
       * Remove an account's identity and sub-account information and slash the deposits.
       *
       * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
       * `Slash`. Verification request deposits are not returned; they should be cancelled
       * manually using `cancel_request`.
       *
       * The dispatch origin for this call must match `T::ForceOrigin`.
       *
       * - `target`: the account whose identity the judgement is upon. This must be an account
       *   with a registered identity.
       *
       * Emits `IdentityKilled` if successful.
       *
       * # <weight>
       * - `O(R + S + X)`.
       * - One balance-reserve operation.
       * - `S + 2` storage mutations.
       * - One event.
       * # </weight>
       */
      export interface kill_identity {
        type: "kill_identity"
        target: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Provide a judgement for an account's identity.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `reg_index`.
       *
       * - `reg_index`: the index of the registrar whose judgement is being made.
       * - `target`: the account whose identity the judgement is upon. This must be an account
       *   with a registered identity.
       * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
       * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
       *
       * Emits `JudgementGiven` if successful.
       *
       * # <weight>
       * - `O(R + X)`.
       * - One balance-transfer operation.
       * - Up to one account-lookup operation.
       * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
       * - One event.
       * # </weight>
       */
      export function provide_judgement(
        value: Omit<pallet_identity.pallet.Call.provide_judgement, "type">,
      ): pallet_identity.pallet.Call.provide_judgement {
        return { type: "provide_judgement", ...value }
      }
      /**
       * Provide a judgement for an account's identity.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `reg_index`.
       *
       * - `reg_index`: the index of the registrar whose judgement is being made.
       * - `target`: the account whose identity the judgement is upon. This must be an account
       *   with a registered identity.
       * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
       * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
       *
       * Emits `JudgementGiven` if successful.
       *
       * # <weight>
       * - `O(R + X)`.
       * - One balance-transfer operation.
       * - Up to one account-lookup operation.
       * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
       * - One event.
       * # </weight>
       */
      export interface provide_judgement {
        type: "provide_judgement"
        reg_index: Compact<u32>
        target: sp_runtime.multiaddress.MultiAddress
        judgement: pallet_identity.types.Judgement
        identity: primitive_types.H256
      }
      /**
       * Remove the sender as a sub-account.
       *
       * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
       * to the sender (*not* the original depositor).
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * super-identity.
       *
       * NOTE: This should not normally be used, but is provided in the case that the non-
       * controller of an account is maliciously registered as a sub-account.
       */
      export function quit_sub(): pallet_identity.pallet.Call.quit_sub {
        return { type: "quit_sub" }
      }
      /**
       * Remove the sender as a sub-account.
       *
       * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
       * to the sender (*not* the original depositor).
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * super-identity.
       *
       * NOTE: This should not normally be used, but is provided in the case that the non-
       * controller of an account is maliciously registered as a sub-account.
       */
      export interface quit_sub {
        type: "quit_sub"
      }
      /**
       * Remove the given account from the sender's subs.
       *
       * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
       * to the sender.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * sub identity of `sub`.
       */
      export function remove_sub(
        value: Omit<pallet_identity.pallet.Call.remove_sub, "type">,
      ): pallet_identity.pallet.Call.remove_sub {
        return { type: "remove_sub", ...value }
      }
      /**
       * Remove the given account from the sender's subs.
       *
       * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
       * to the sender.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * sub identity of `sub`.
       */
      export interface remove_sub {
        type: "remove_sub"
        sub: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Alter the associated name of the given sub-account.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * sub identity of `sub`.
       */
      export function rename_sub(
        value: Omit<pallet_identity.pallet.Call.rename_sub, "type">,
      ): pallet_identity.pallet.Call.rename_sub {
        return { type: "rename_sub", ...value }
      }
      /**
       * Alter the associated name of the given sub-account.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * sub identity of `sub`.
       */
      export interface rename_sub {
        type: "rename_sub"
        sub: sp_runtime.multiaddress.MultiAddress
        data: pallet_identity.types.Data
      }
      /**
       * Request a judgement from a registrar.
       *
       * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
       * given.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a
       * registered identity.
       *
       * - `reg_index`: The index of the registrar whose judgement is requested.
       * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
       *
       * ```nocompile
       * Self::registrars().get(reg_index).unwrap().fee
       * ```
       *
       * Emits `JudgementRequested` if successful.
       *
       * # <weight>
       * - `O(R + X)`.
       * - One balance-reserve operation.
       * - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.
       * - One event.
       * # </weight>
       */
      export function request_judgement(
        value: Omit<pallet_identity.pallet.Call.request_judgement, "type">,
      ): pallet_identity.pallet.Call.request_judgement {
        return { type: "request_judgement", ...value }
      }
      /**
       * Request a judgement from a registrar.
       *
       * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
       * given.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a
       * registered identity.
       *
       * - `reg_index`: The index of the registrar whose judgement is requested.
       * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
       *
       * ```nocompile
       * Self::registrars().get(reg_index).unwrap().fee
       * ```
       *
       * Emits `JudgementRequested` if successful.
       *
       * # <weight>
       * - `O(R + X)`.
       * - One balance-reserve operation.
       * - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.
       * - One event.
       * # </weight>
       */
      export interface request_judgement {
        type: "request_judgement"
        reg_index: Compact<u32>
        max_fee: Compact<u128>
      }
      /**
       * Change the account associated with a registrar.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `index`.
       *
       * - `index`: the index of the registrar whose fee is to be set.
       * - `new`: the new account ID.
       *
       * # <weight>
       * - `O(R)`.
       * - One storage mutation `O(R)`.
       * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
       * # </weight>
       */
      export function set_account_id(
        value: Omit<pallet_identity.pallet.Call.set_account_id, "type">,
      ): pallet_identity.pallet.Call.set_account_id {
        return { type: "set_account_id", ...value }
      }
      /**
       * Change the account associated with a registrar.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `index`.
       *
       * - `index`: the index of the registrar whose fee is to be set.
       * - `new`: the new account ID.
       *
       * # <weight>
       * - `O(R)`.
       * - One storage mutation `O(R)`.
       * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
       * # </weight>
       */
      export interface set_account_id {
        type: "set_account_id"
        index: Compact<u32>
        new: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Set the fee required for a judgement to be requested from a registrar.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `index`.
       *
       * - `index`: the index of the registrar whose fee is to be set.
       * - `fee`: the new fee.
       *
       * # <weight>
       * - `O(R)`.
       * - One storage mutation `O(R)`.
       * - Benchmark: 7.315 + R * 0.329 µs (min squares analysis)
       * # </weight>
       */
      export function set_fee(
        value: Omit<pallet_identity.pallet.Call.set_fee, "type">,
      ): pallet_identity.pallet.Call.set_fee {
        return { type: "set_fee", ...value }
      }
      /**
       * Set the fee required for a judgement to be requested from a registrar.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `index`.
       *
       * - `index`: the index of the registrar whose fee is to be set.
       * - `fee`: the new fee.
       *
       * # <weight>
       * - `O(R)`.
       * - One storage mutation `O(R)`.
       * - Benchmark: 7.315 + R * 0.329 µs (min squares analysis)
       * # </weight>
       */
      export interface set_fee {
        type: "set_fee"
        index: Compact<u32>
        fee: Compact<u128>
      }
      /**
       * Set the field information for a registrar.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `index`.
       *
       * - `index`: the index of the registrar whose fee is to be set.
       * - `fields`: the fields that the registrar concerns themselves with.
       *
       * # <weight>
       * - `O(R)`.
       * - One storage mutation `O(R)`.
       * - Benchmark: 7.464 + R * 0.325 µs (min squares analysis)
       * # </weight>
       */
      export function set_fields(
        value: Omit<pallet_identity.pallet.Call.set_fields, "type">,
      ): pallet_identity.pallet.Call.set_fields {
        return { type: "set_fields", ...value }
      }
      /**
       * Set the field information for a registrar.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must be the account
       * of the registrar whose index is `index`.
       *
       * - `index`: the index of the registrar whose fee is to be set.
       * - `fields`: the fields that the registrar concerns themselves with.
       *
       * # <weight>
       * - `O(R)`.
       * - One storage mutation `O(R)`.
       * - Benchmark: 7.464 + R * 0.325 µs (min squares analysis)
       * # </weight>
       */
      export interface set_fields {
        type: "set_fields"
        index: Compact<u32>
        fields: u64
      }
      /**
       * Set an account's identity information and reserve the appropriate deposit.
       *
       * If the account already has identity information, the deposit is taken as part payment
       * for the new deposit.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `info`: The identity information.
       *
       * Emits `IdentitySet` if successful.
       *
       * # <weight>
       * - `O(X + X' + R)`
       *   - where `X` additional-field-count (deposit-bounded and code-bounded)
       *   - where `R` judgements-count (registrar-count-bounded)
       * - One balance reserve operation.
       * - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).
       * - One event.
       * # </weight>
       */
      export function set_identity(
        value: Omit<pallet_identity.pallet.Call.set_identity, "type">,
      ): pallet_identity.pallet.Call.set_identity {
        return { type: "set_identity", ...value }
      }
      /**
       * Set an account's identity information and reserve the appropriate deposit.
       *
       * If the account already has identity information, the deposit is taken as part payment
       * for the new deposit.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `info`: The identity information.
       *
       * Emits `IdentitySet` if successful.
       *
       * # <weight>
       * - `O(X + X' + R)`
       *   - where `X` additional-field-count (deposit-bounded and code-bounded)
       *   - where `R` judgements-count (registrar-count-bounded)
       * - One balance reserve operation.
       * - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).
       * - One event.
       * # </weight>
       */
      export interface set_identity {
        type: "set_identity"
        info: pallet_identity.types.IdentityInfo
      }
      /**
       * Set the sub-accounts of the sender.
       *
       * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
       * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * identity.
       *
       * - `subs`: The identity's (new) sub-accounts.
       *
       * # <weight>
       * - `O(P + S)`
       *   - where `P` old-subs-count (hard- and deposit-bounded).
       *   - where `S` subs-count (hard- and deposit-bounded).
       * - At most one balance operations.
       * - DB:
       *   - `P + S` storage mutations (codec complexity `O(1)`)
       *   - One storage read (codec complexity `O(P)`).
       *   - One storage write (codec complexity `O(S)`).
       *   - One storage-exists (`IdentityOf::contains_key`).
       * # </weight>
       */
      export function set_subs(
        value: Omit<pallet_identity.pallet.Call.set_subs, "type">,
      ): pallet_identity.pallet.Call.set_subs {
        return { type: "set_subs", ...value }
      }
      /**
       * Set the sub-accounts of the sender.
       *
       * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
       * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have a registered
       * identity.
       *
       * - `subs`: The identity's (new) sub-accounts.
       *
       * # <weight>
       * - `O(P + S)`
       *   - where `P` old-subs-count (hard- and deposit-bounded).
       *   - where `S` subs-count (hard- and deposit-bounded).
       * - At most one balance operations.
       * - DB:
       *   - `P + S` storage mutations (codec complexity `O(1)`)
       *   - One storage read (codec complexity `O(P)`).
       *   - One storage write (codec complexity `O(S)`).
       *   - One storage-exists (`IdentityOf::contains_key`).
       * # </weight>
       */
      export interface set_subs {
        type: "set_subs"
        subs: Array<[sp_core.crypto.AccountId32, pallet_identity.types.Data]>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "TooManySubAccounts"
      | "NotFound"
      | "NotNamed"
      | "EmptyIndex"
      | "FeeChanged"
      | "NoIdentity"
      | "StickyJudgement"
      | "JudgementGiven"
      | "InvalidJudgement"
      | "InvalidIndex"
      | "InvalidTarget"
      | "TooManyFields"
      | "TooManyRegistrars"
      | "AlreadyClaimed"
      | "NotSub"
      | "NotOwned"
      | "JudgementForDifferentIdentity"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_identity.pallet.Event.IdentitySet
      | pallet_identity.pallet.Event.IdentityCleared
      | pallet_identity.pallet.Event.IdentityKilled
      | pallet_identity.pallet.Event.JudgementRequested
      | pallet_identity.pallet.Event.JudgementUnrequested
      | pallet_identity.pallet.Event.JudgementGiven
      | pallet_identity.pallet.Event.RegistrarAdded
      | pallet_identity.pallet.Event.SubIdentityAdded
      | pallet_identity.pallet.Event.SubIdentityRemoved
      | pallet_identity.pallet.Event.SubIdentityRevoked
    export namespace Event {
      /** A name was cleared, and the given balance returned. */
      export function IdentityCleared(
        value: Omit<pallet_identity.pallet.Event.IdentityCleared, "type">,
      ): pallet_identity.pallet.Event.IdentityCleared {
        return { type: "IdentityCleared", ...value }
      }
      /** A name was cleared, and the given balance returned. */
      export interface IdentityCleared {
        type: "IdentityCleared"
        who: sp_core.crypto.AccountId32
        deposit: u128
      }
      /** A name was removed and the given balance slashed. */
      export function IdentityKilled(
        value: Omit<pallet_identity.pallet.Event.IdentityKilled, "type">,
      ): pallet_identity.pallet.Event.IdentityKilled {
        return { type: "IdentityKilled", ...value }
      }
      /** A name was removed and the given balance slashed. */
      export interface IdentityKilled {
        type: "IdentityKilled"
        who: sp_core.crypto.AccountId32
        deposit: u128
      }
      /** A name was set or reset (which will remove all judgements). */
      export function IdentitySet(
        value: Omit<pallet_identity.pallet.Event.IdentitySet, "type">,
      ): pallet_identity.pallet.Event.IdentitySet {
        return { type: "IdentitySet", ...value }
      }
      /** A name was set or reset (which will remove all judgements). */
      export interface IdentitySet {
        type: "IdentitySet"
        who: sp_core.crypto.AccountId32
      }
      /** A judgement was given by a registrar. */
      export function JudgementGiven(
        value: Omit<pallet_identity.pallet.Event.JudgementGiven, "type">,
      ): pallet_identity.pallet.Event.JudgementGiven {
        return { type: "JudgementGiven", ...value }
      }
      /** A judgement was given by a registrar. */
      export interface JudgementGiven {
        type: "JudgementGiven"
        target: sp_core.crypto.AccountId32
        registrar_index: u32
      }
      /** A judgement was asked from a registrar. */
      export function JudgementRequested(
        value: Omit<pallet_identity.pallet.Event.JudgementRequested, "type">,
      ): pallet_identity.pallet.Event.JudgementRequested {
        return { type: "JudgementRequested", ...value }
      }
      /** A judgement was asked from a registrar. */
      export interface JudgementRequested {
        type: "JudgementRequested"
        who: sp_core.crypto.AccountId32
        registrar_index: u32
      }
      /** A judgement request was retracted. */
      export function JudgementUnrequested(
        value: Omit<pallet_identity.pallet.Event.JudgementUnrequested, "type">,
      ): pallet_identity.pallet.Event.JudgementUnrequested {
        return { type: "JudgementUnrequested", ...value }
      }
      /** A judgement request was retracted. */
      export interface JudgementUnrequested {
        type: "JudgementUnrequested"
        who: sp_core.crypto.AccountId32
        registrar_index: u32
      }
      /** A registrar was added. */
      export function RegistrarAdded(
        value: Omit<pallet_identity.pallet.Event.RegistrarAdded, "type">,
      ): pallet_identity.pallet.Event.RegistrarAdded {
        return { type: "RegistrarAdded", ...value }
      }
      /** A registrar was added. */
      export interface RegistrarAdded {
        type: "RegistrarAdded"
        registrar_index: u32
      }
      /** A sub-identity was added to an identity and the deposit paid. */
      export function SubIdentityAdded(
        value: Omit<pallet_identity.pallet.Event.SubIdentityAdded, "type">,
      ): pallet_identity.pallet.Event.SubIdentityAdded {
        return { type: "SubIdentityAdded", ...value }
      }
      /** A sub-identity was added to an identity and the deposit paid. */
      export interface SubIdentityAdded {
        type: "SubIdentityAdded"
        sub: sp_core.crypto.AccountId32
        main: sp_core.crypto.AccountId32
        deposit: u128
      }
      /** A sub-identity was removed from an identity and the deposit freed. */
      export function SubIdentityRemoved(
        value: Omit<pallet_identity.pallet.Event.SubIdentityRemoved, "type">,
      ): pallet_identity.pallet.Event.SubIdentityRemoved {
        return { type: "SubIdentityRemoved", ...value }
      }
      /** A sub-identity was removed from an identity and the deposit freed. */
      export interface SubIdentityRemoved {
        type: "SubIdentityRemoved"
        sub: sp_core.crypto.AccountId32
        main: sp_core.crypto.AccountId32
        deposit: u128
      }
      /**
       * A sub-identity was cleared, and the given deposit repatriated from the
       * main identity account to the sub-identity account.
       */
      export function SubIdentityRevoked(
        value: Omit<pallet_identity.pallet.Event.SubIdentityRevoked, "type">,
      ): pallet_identity.pallet.Event.SubIdentityRevoked {
        return { type: "SubIdentityRevoked", ...value }
      }
      /**
       * A sub-identity was cleared, and the given deposit repatriated from the
       * main identity account to the sub-identity account.
       */
      export interface SubIdentityRevoked {
        type: "SubIdentityRevoked"
        sub: sp_core.crypto.AccountId32
        main: sp_core.crypto.AccountId32
        deposit: u128
      }
    }
  }
  export namespace types {
    export const $data: $.Codec<pallet_identity.types.Data> = _codec.$267
    export const $identityField: $.Codec<pallet_identity.types.IdentityField> = _codec.$301
    export const $identityInfo: $.Codec<pallet_identity.types.IdentityInfo> = _codec.$264
    export const $judgement: $.Codec<pallet_identity.types.Judgement> = _codec.$302
    export const $registrarInfo: $.Codec<pallet_identity.types.RegistrarInfo> = _codec.$576
    export const $registration: $.Codec<pallet_identity.types.Registration> = _codec.$568
    export type Data =
      | pallet_identity.types.Data.None
      | pallet_identity.types.Data.Raw0
      | pallet_identity.types.Data.Raw1
      | pallet_identity.types.Data.Raw2
      | pallet_identity.types.Data.Raw3
      | pallet_identity.types.Data.Raw4
      | pallet_identity.types.Data.Raw5
      | pallet_identity.types.Data.Raw6
      | pallet_identity.types.Data.Raw7
      | pallet_identity.types.Data.Raw8
      | pallet_identity.types.Data.Raw9
      | pallet_identity.types.Data.Raw10
      | pallet_identity.types.Data.Raw11
      | pallet_identity.types.Data.Raw12
      | pallet_identity.types.Data.Raw13
      | pallet_identity.types.Data.Raw14
      | pallet_identity.types.Data.Raw15
      | pallet_identity.types.Data.Raw16
      | pallet_identity.types.Data.Raw17
      | pallet_identity.types.Data.Raw18
      | pallet_identity.types.Data.Raw19
      | pallet_identity.types.Data.Raw20
      | pallet_identity.types.Data.Raw21
      | pallet_identity.types.Data.Raw22
      | pallet_identity.types.Data.Raw23
      | pallet_identity.types.Data.Raw24
      | pallet_identity.types.Data.Raw25
      | pallet_identity.types.Data.Raw26
      | pallet_identity.types.Data.Raw27
      | pallet_identity.types.Data.Raw28
      | pallet_identity.types.Data.Raw29
      | pallet_identity.types.Data.Raw30
      | pallet_identity.types.Data.Raw31
      | pallet_identity.types.Data.Raw32
      | pallet_identity.types.Data.BlakeTwo256
      | pallet_identity.types.Data.Sha256
      | pallet_identity.types.Data.Keccak256
      | pallet_identity.types.Data.ShaThree256
    export namespace Data {
      export function BlakeTwo256(
        value: pallet_identity.types.Data.BlakeTwo256["value"],
      ): pallet_identity.types.Data.BlakeTwo256 {
        return { type: "BlakeTwo256", value }
      }
      export interface BlakeTwo256 {
        type: "BlakeTwo256"
        value: Uint8Array
      }
      export function Keccak256(
        value: pallet_identity.types.Data.Keccak256["value"],
      ): pallet_identity.types.Data.Keccak256 {
        return { type: "Keccak256", value }
      }
      export interface Keccak256 {
        type: "Keccak256"
        value: Uint8Array
      }
      export function None(): pallet_identity.types.Data.None {
        return { type: "None" }
      }
      export interface None {
        type: "None"
      }
      export function Raw0(
        value: pallet_identity.types.Data.Raw0["value"],
      ): pallet_identity.types.Data.Raw0 {
        return { type: "Raw0", value }
      }
      export interface Raw0 {
        type: "Raw0"
        value: Uint8Array
      }
      export function Raw1(
        value: pallet_identity.types.Data.Raw1["value"],
      ): pallet_identity.types.Data.Raw1 {
        return { type: "Raw1", value }
      }
      export interface Raw1 {
        type: "Raw1"
        value: Uint8Array
      }
      export function Raw10(
        value: pallet_identity.types.Data.Raw10["value"],
      ): pallet_identity.types.Data.Raw10 {
        return { type: "Raw10", value }
      }
      export interface Raw10 {
        type: "Raw10"
        value: Uint8Array
      }
      export function Raw11(
        value: pallet_identity.types.Data.Raw11["value"],
      ): pallet_identity.types.Data.Raw11 {
        return { type: "Raw11", value }
      }
      export interface Raw11 {
        type: "Raw11"
        value: Uint8Array
      }
      export function Raw12(
        value: pallet_identity.types.Data.Raw12["value"],
      ): pallet_identity.types.Data.Raw12 {
        return { type: "Raw12", value }
      }
      export interface Raw12 {
        type: "Raw12"
        value: Uint8Array
      }
      export function Raw13(
        value: pallet_identity.types.Data.Raw13["value"],
      ): pallet_identity.types.Data.Raw13 {
        return { type: "Raw13", value }
      }
      export interface Raw13 {
        type: "Raw13"
        value: Uint8Array
      }
      export function Raw14(
        value: pallet_identity.types.Data.Raw14["value"],
      ): pallet_identity.types.Data.Raw14 {
        return { type: "Raw14", value }
      }
      export interface Raw14 {
        type: "Raw14"
        value: Uint8Array
      }
      export function Raw15(
        value: pallet_identity.types.Data.Raw15["value"],
      ): pallet_identity.types.Data.Raw15 {
        return { type: "Raw15", value }
      }
      export interface Raw15 {
        type: "Raw15"
        value: Uint8Array
      }
      export function Raw16(
        value: pallet_identity.types.Data.Raw16["value"],
      ): pallet_identity.types.Data.Raw16 {
        return { type: "Raw16", value }
      }
      export interface Raw16 {
        type: "Raw16"
        value: Uint8Array
      }
      export function Raw17(
        value: pallet_identity.types.Data.Raw17["value"],
      ): pallet_identity.types.Data.Raw17 {
        return { type: "Raw17", value }
      }
      export interface Raw17 {
        type: "Raw17"
        value: Uint8Array
      }
      export function Raw18(
        value: pallet_identity.types.Data.Raw18["value"],
      ): pallet_identity.types.Data.Raw18 {
        return { type: "Raw18", value }
      }
      export interface Raw18 {
        type: "Raw18"
        value: Uint8Array
      }
      export function Raw19(
        value: pallet_identity.types.Data.Raw19["value"],
      ): pallet_identity.types.Data.Raw19 {
        return { type: "Raw19", value }
      }
      export interface Raw19 {
        type: "Raw19"
        value: Uint8Array
      }
      export function Raw2(
        value: pallet_identity.types.Data.Raw2["value"],
      ): pallet_identity.types.Data.Raw2 {
        return { type: "Raw2", value }
      }
      export interface Raw2 {
        type: "Raw2"
        value: Uint8Array
      }
      export function Raw20(
        value: pallet_identity.types.Data.Raw20["value"],
      ): pallet_identity.types.Data.Raw20 {
        return { type: "Raw20", value }
      }
      export interface Raw20 {
        type: "Raw20"
        value: Uint8Array
      }
      export function Raw21(
        value: pallet_identity.types.Data.Raw21["value"],
      ): pallet_identity.types.Data.Raw21 {
        return { type: "Raw21", value }
      }
      export interface Raw21 {
        type: "Raw21"
        value: Uint8Array
      }
      export function Raw22(
        value: pallet_identity.types.Data.Raw22["value"],
      ): pallet_identity.types.Data.Raw22 {
        return { type: "Raw22", value }
      }
      export interface Raw22 {
        type: "Raw22"
        value: Uint8Array
      }
      export function Raw23(
        value: pallet_identity.types.Data.Raw23["value"],
      ): pallet_identity.types.Data.Raw23 {
        return { type: "Raw23", value }
      }
      export interface Raw23 {
        type: "Raw23"
        value: Uint8Array
      }
      export function Raw24(
        value: pallet_identity.types.Data.Raw24["value"],
      ): pallet_identity.types.Data.Raw24 {
        return { type: "Raw24", value }
      }
      export interface Raw24 {
        type: "Raw24"
        value: Uint8Array
      }
      export function Raw25(
        value: pallet_identity.types.Data.Raw25["value"],
      ): pallet_identity.types.Data.Raw25 {
        return { type: "Raw25", value }
      }
      export interface Raw25 {
        type: "Raw25"
        value: Uint8Array
      }
      export function Raw26(
        value: pallet_identity.types.Data.Raw26["value"],
      ): pallet_identity.types.Data.Raw26 {
        return { type: "Raw26", value }
      }
      export interface Raw26 {
        type: "Raw26"
        value: Uint8Array
      }
      export function Raw27(
        value: pallet_identity.types.Data.Raw27["value"],
      ): pallet_identity.types.Data.Raw27 {
        return { type: "Raw27", value }
      }
      export interface Raw27 {
        type: "Raw27"
        value: Uint8Array
      }
      export function Raw28(
        value: pallet_identity.types.Data.Raw28["value"],
      ): pallet_identity.types.Data.Raw28 {
        return { type: "Raw28", value }
      }
      export interface Raw28 {
        type: "Raw28"
        value: Uint8Array
      }
      export function Raw29(
        value: pallet_identity.types.Data.Raw29["value"],
      ): pallet_identity.types.Data.Raw29 {
        return { type: "Raw29", value }
      }
      export interface Raw29 {
        type: "Raw29"
        value: Uint8Array
      }
      export function Raw3(
        value: pallet_identity.types.Data.Raw3["value"],
      ): pallet_identity.types.Data.Raw3 {
        return { type: "Raw3", value }
      }
      export interface Raw3 {
        type: "Raw3"
        value: Uint8Array
      }
      export function Raw30(
        value: pallet_identity.types.Data.Raw30["value"],
      ): pallet_identity.types.Data.Raw30 {
        return { type: "Raw30", value }
      }
      export interface Raw30 {
        type: "Raw30"
        value: Uint8Array
      }
      export function Raw31(
        value: pallet_identity.types.Data.Raw31["value"],
      ): pallet_identity.types.Data.Raw31 {
        return { type: "Raw31", value }
      }
      export interface Raw31 {
        type: "Raw31"
        value: Uint8Array
      }
      export function Raw32(
        value: pallet_identity.types.Data.Raw32["value"],
      ): pallet_identity.types.Data.Raw32 {
        return { type: "Raw32", value }
      }
      export interface Raw32 {
        type: "Raw32"
        value: Uint8Array
      }
      export function Raw4(
        value: pallet_identity.types.Data.Raw4["value"],
      ): pallet_identity.types.Data.Raw4 {
        return { type: "Raw4", value }
      }
      export interface Raw4 {
        type: "Raw4"
        value: Uint8Array
      }
      export function Raw5(
        value: pallet_identity.types.Data.Raw5["value"],
      ): pallet_identity.types.Data.Raw5 {
        return { type: "Raw5", value }
      }
      export interface Raw5 {
        type: "Raw5"
        value: Uint8Array
      }
      export function Raw6(
        value: pallet_identity.types.Data.Raw6["value"],
      ): pallet_identity.types.Data.Raw6 {
        return { type: "Raw6", value }
      }
      export interface Raw6 {
        type: "Raw6"
        value: Uint8Array
      }
      export function Raw7(
        value: pallet_identity.types.Data.Raw7["value"],
      ): pallet_identity.types.Data.Raw7 {
        return { type: "Raw7", value }
      }
      export interface Raw7 {
        type: "Raw7"
        value: Uint8Array
      }
      export function Raw8(
        value: pallet_identity.types.Data.Raw8["value"],
      ): pallet_identity.types.Data.Raw8 {
        return { type: "Raw8", value }
      }
      export interface Raw8 {
        type: "Raw8"
        value: Uint8Array
      }
      export function Raw9(
        value: pallet_identity.types.Data.Raw9["value"],
      ): pallet_identity.types.Data.Raw9 {
        return { type: "Raw9", value }
      }
      export interface Raw9 {
        type: "Raw9"
        value: Uint8Array
      }
      export function Sha256(
        value: pallet_identity.types.Data.Sha256["value"],
      ): pallet_identity.types.Data.Sha256 {
        return { type: "Sha256", value }
      }
      export interface Sha256 {
        type: "Sha256"
        value: Uint8Array
      }
      export function ShaThree256(
        value: pallet_identity.types.Data.ShaThree256["value"],
      ): pallet_identity.types.Data.ShaThree256 {
        return { type: "ShaThree256", value }
      }
      export interface ShaThree256 {
        type: "ShaThree256"
        value: Uint8Array
      }
    }
    export type IdentityField =
      | "Display"
      | "Legal"
      | "Web"
      | "Riot"
      | "Email"
      | "PgpFingerprint"
      | "Image"
      | "Twitter"
    export interface IdentityInfo {
      additional: Array<[pallet_identity.types.Data, pallet_identity.types.Data]>
      display: pallet_identity.types.Data
      legal: pallet_identity.types.Data
      web: pallet_identity.types.Data
      riot: pallet_identity.types.Data
      email: pallet_identity.types.Data
      pgp_fingerprint: Uint8Array | undefined
      image: pallet_identity.types.Data
      twitter: pallet_identity.types.Data
    }
    export function IdentityInfo(value: pallet_identity.types.IdentityInfo) {
      return value
    }
    export type Judgement =
      | pallet_identity.types.Judgement.Unknown
      | pallet_identity.types.Judgement.FeePaid
      | pallet_identity.types.Judgement.Reasonable
      | pallet_identity.types.Judgement.KnownGood
      | pallet_identity.types.Judgement.OutOfDate
      | pallet_identity.types.Judgement.LowQuality
      | pallet_identity.types.Judgement.Erroneous
    export namespace Judgement {
      export function Erroneous(): pallet_identity.types.Judgement.Erroneous {
        return { type: "Erroneous" }
      }
      export interface Erroneous {
        type: "Erroneous"
      }
      export function FeePaid(
        value: pallet_identity.types.Judgement.FeePaid["value"],
      ): pallet_identity.types.Judgement.FeePaid {
        return { type: "FeePaid", value }
      }
      export interface FeePaid {
        type: "FeePaid"
        value: u128
      }
      export function KnownGood(): pallet_identity.types.Judgement.KnownGood {
        return { type: "KnownGood" }
      }
      export interface KnownGood {
        type: "KnownGood"
      }
      export function LowQuality(): pallet_identity.types.Judgement.LowQuality {
        return { type: "LowQuality" }
      }
      export interface LowQuality {
        type: "LowQuality"
      }
      export function OutOfDate(): pallet_identity.types.Judgement.OutOfDate {
        return { type: "OutOfDate" }
      }
      export interface OutOfDate {
        type: "OutOfDate"
      }
      export function Reasonable(): pallet_identity.types.Judgement.Reasonable {
        return { type: "Reasonable" }
      }
      export interface Reasonable {
        type: "Reasonable"
      }
      export function Unknown(): pallet_identity.types.Judgement.Unknown {
        return { type: "Unknown" }
      }
      export interface Unknown {
        type: "Unknown"
      }
    }
    export interface RegistrarInfo {
      account: sp_core.crypto.AccountId32
      fee: u128
      fields: u64
    }
    export function RegistrarInfo(value: pallet_identity.types.RegistrarInfo) {
      return value
    }
    export interface Registration {
      judgements: Array<[u32, pallet_identity.types.Judgement]>
      deposit: u128
      info: pallet_identity.types.IdentityInfo
    }
    export function Registration(value: pallet_identity.types.Registration) {
      return value
    }
  }
}
export namespace pallet_im_online {
  export const $boundedOpaqueNetworkState: $.Codec<pallet_im_online.BoundedOpaqueNetworkState> =
    _codec.$523
  export const $heartbeat: $.Codec<pallet_im_online.Heartbeat> = _codec.$228
  export interface BoundedOpaqueNetworkState {
    peer_id: Uint8Array
    external_addresses: Array<Uint8Array>
  }
  export function BoundedOpaqueNetworkState(value: pallet_im_online.BoundedOpaqueNetworkState) {
    return value
  }
  export interface Heartbeat {
    block_number: u32
    network_state: sp_core.offchain.OpaqueNetworkState
    session_index: u32
    authority_index: u32
    validators_len: u32
  }
  export function Heartbeat(value: pallet_im_online.Heartbeat) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_im_online.pallet.Call> = _codec.$227
    export const $error: $.Codec<pallet_im_online.pallet.Error> = _codec.$527
    export const $event: $.Codec<pallet_im_online.pallet.Event> = _codec.$52
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call = pallet_im_online.pallet.Call.heartbeat
    export namespace Call {
      /**
       * # <weight>
       * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is
       *   length of `heartbeat.network_state.external_address`
       *   - `O(K)`: decoding of length `K`
       *   - `O(E)`: decoding/encoding of length `E`
       * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
       *   `ReceivedHeartbeats`
       * - DbWrites: `ReceivedHeartbeats`
       * # </weight>
       */
      export function heartbeat(
        value: Omit<pallet_im_online.pallet.Call.heartbeat, "type">,
      ): pallet_im_online.pallet.Call.heartbeat {
        return { type: "heartbeat", ...value }
      }
      /**
       * # <weight>
       * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is
       *   length of `heartbeat.network_state.external_address`
       *   - `O(K)`: decoding of length `K`
       *   - `O(E)`: decoding/encoding of length `E`
       * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
       *   `ReceivedHeartbeats`
       * - DbWrites: `ReceivedHeartbeats`
       * # </weight>
       */
      export interface heartbeat {
        type: "heartbeat"
        heartbeat: pallet_im_online.Heartbeat
        signature: pallet_im_online.sr25519.app_sr25519.Signature
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error = "InvalidKey" | "DuplicatedHeartbeat"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_im_online.pallet.Event.HeartbeatReceived
      | pallet_im_online.pallet.Event.AllGood
      | pallet_im_online.pallet.Event.SomeOffline
    export namespace Event {
      /** At the end of the session, no offence was committed. */
      export function AllGood(): pallet_im_online.pallet.Event.AllGood {
        return { type: "AllGood" }
      }
      /** At the end of the session, no offence was committed. */
      export interface AllGood {
        type: "AllGood"
      }
      /** A new heartbeat was received from `AuthorityId`. */
      export function HeartbeatReceived(
        value: Omit<pallet_im_online.pallet.Event.HeartbeatReceived, "type">,
      ): pallet_im_online.pallet.Event.HeartbeatReceived {
        return { type: "HeartbeatReceived", ...value }
      }
      /** A new heartbeat was received from `AuthorityId`. */
      export interface HeartbeatReceived {
        type: "HeartbeatReceived"
        authority_id: pallet_im_online.sr25519.app_sr25519.Public
      }
      /** At the end of the session, at least one validator was found to be offline. */
      export function SomeOffline(
        value: Omit<pallet_im_online.pallet.Event.SomeOffline, "type">,
      ): pallet_im_online.pallet.Event.SomeOffline {
        return { type: "SomeOffline", ...value }
      }
      /** At the end of the session, at least one validator was found to be offline. */
      export interface SomeOffline {
        type: "SomeOffline"
        offline: Array<[sp_core.crypto.AccountId32, pallet_staking.Exposure]>
      }
    }
  }
  export namespace sr25519 {
    export namespace app_sr25519 {
      export const $public: $.Codec<pallet_im_online.sr25519.app_sr25519.Public> = _codec.$53
      export const $signature: $.Codec<pallet_im_online.sr25519.app_sr25519.Signature> = _codec.$233
      export type Public = sp_core.sr25519.Public
      export function Public(value: pallet_im_online.sr25519.app_sr25519.Public) {
        return value
      }
      export type Signature = sp_core.sr25519.Signature
      export function Signature(value: pallet_im_online.sr25519.app_sr25519.Signature) {
        return value
      }
    }
  }
}
export namespace pallet_indices {
  export namespace pallet {
    export const $call: $.Codec<pallet_indices.pallet.Call> = _codec.$196
    export const $error: $.Codec<pallet_indices.pallet.Error> = _codec.$469
    export const $event: $.Codec<pallet_indices.pallet.Event> = _codec.$35
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_indices.pallet.Call.claim
      | pallet_indices.pallet.Call.transfer
      | pallet_indices.pallet.Call.free
      | pallet_indices.pallet.Call.force_transfer
      | pallet_indices.pallet.Call.freeze
    export namespace Call {
      /**
       * Assign an previously unassigned index.
       *
       * Payment: `Deposit` is reserved from the sender account.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `index`: the index to be claimed. This must not be in use.
       *
       * Emits `IndexAssigned` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - One reserve operation.
       * - One event.
       * -------------------
       * - DB Weight: 1 Read/Write (Accounts)
       * # </weight>
       */
      export function claim(
        value: Omit<pallet_indices.pallet.Call.claim, "type">,
      ): pallet_indices.pallet.Call.claim {
        return { type: "claim", ...value }
      }
      /**
       * Assign an previously unassigned index.
       *
       * Payment: `Deposit` is reserved from the sender account.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `index`: the index to be claimed. This must not be in use.
       *
       * Emits `IndexAssigned` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - One reserve operation.
       * - One event.
       * -------------------
       * - DB Weight: 1 Read/Write (Accounts)
       * # </weight>
       */
      export interface claim {
        type: "claim"
        index: u32
      }
      /**
       * Force an index to an account. This doesn't require a deposit. If the index is already
       * held, then any deposit is reimbursed to its current owner.
       *
       * The dispatch origin for this call must be _Root_.
       *
       * - `index`: the index to be (re-)assigned.
       * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
       * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
       *
       * Emits `IndexAssigned` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - Up to one reserve operation.
       * - One event.
       * -------------------
       * - DB Weight:
       *    - Reads: Indices Accounts, System Account (original owner)
       *    - Writes: Indices Accounts, System Account (original owner)
       * # </weight>
       */
      export function force_transfer(
        value: Omit<pallet_indices.pallet.Call.force_transfer, "type">,
      ): pallet_indices.pallet.Call.force_transfer {
        return { type: "force_transfer", ...value }
      }
      /**
       * Force an index to an account. This doesn't require a deposit. If the index is already
       * held, then any deposit is reimbursed to its current owner.
       *
       * The dispatch origin for this call must be _Root_.
       *
       * - `index`: the index to be (re-)assigned.
       * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
       * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
       *
       * Emits `IndexAssigned` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - Up to one reserve operation.
       * - One event.
       * -------------------
       * - DB Weight:
       *    - Reads: Indices Accounts, System Account (original owner)
       *    - Writes: Indices Accounts, System Account (original owner)
       * # </weight>
       */
      export interface force_transfer {
        type: "force_transfer"
        new: sp_runtime.multiaddress.MultiAddress
        index: u32
        freeze: boolean
      }
      /**
       * Free up an index owned by the sender.
       *
       * Payment: Any previous deposit placed for the index is unreserved in the sender account.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must own the index.
       *
       * - `index`: the index to be freed. This must be owned by the sender.
       *
       * Emits `IndexFreed` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - One reserve operation.
       * - One event.
       * -------------------
       * - DB Weight: 1 Read/Write (Accounts)
       * # </weight>
       */
      export function free(
        value: Omit<pallet_indices.pallet.Call.free, "type">,
      ): pallet_indices.pallet.Call.free {
        return { type: "free", ...value }
      }
      /**
       * Free up an index owned by the sender.
       *
       * Payment: Any previous deposit placed for the index is unreserved in the sender account.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must own the index.
       *
       * - `index`: the index to be freed. This must be owned by the sender.
       *
       * Emits `IndexFreed` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - One reserve operation.
       * - One event.
       * -------------------
       * - DB Weight: 1 Read/Write (Accounts)
       * # </weight>
       */
      export interface free {
        type: "free"
        index: u32
      }
      /**
       * Freeze an index so it will always point to the sender account. This consumes the
       * deposit.
       *
       * The dispatch origin for this call must be _Signed_ and the signing account must have a
       * non-frozen account `index`.
       *
       * - `index`: the index to be frozen in place.
       *
       * Emits `IndexFrozen` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - Up to one slash operation.
       * - One event.
       * -------------------
       * - DB Weight: 1 Read/Write (Accounts)
       * # </weight>
       */
      export function freeze(
        value: Omit<pallet_indices.pallet.Call.freeze, "type">,
      ): pallet_indices.pallet.Call.freeze {
        return { type: "freeze", ...value }
      }
      /**
       * Freeze an index so it will always point to the sender account. This consumes the
       * deposit.
       *
       * The dispatch origin for this call must be _Signed_ and the signing account must have a
       * non-frozen account `index`.
       *
       * - `index`: the index to be frozen in place.
       *
       * Emits `IndexFrozen` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - Up to one slash operation.
       * - One event.
       * -------------------
       * - DB Weight: 1 Read/Write (Accounts)
       * # </weight>
       */
      export interface freeze {
        type: "freeze"
        index: u32
      }
      /**
       * Assign an index already owned by the sender to another account. The balance reservation
       * is effectively transferred to the new account.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `index`: the index to be re-assigned. This must be owned by the sender.
       * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
       *
       * Emits `IndexAssigned` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - One transfer operation.
       * - One event.
       * -------------------
       * - DB Weight:
       *    - Reads: Indices Accounts, System Account (recipient)
       *    - Writes: Indices Accounts, System Account (recipient)
       * # </weight>
       */
      export function transfer(
        value: Omit<pallet_indices.pallet.Call.transfer, "type">,
      ): pallet_indices.pallet.Call.transfer {
        return { type: "transfer", ...value }
      }
      /**
       * Assign an index already owned by the sender to another account. The balance reservation
       * is effectively transferred to the new account.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `index`: the index to be re-assigned. This must be owned by the sender.
       * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
       *
       * Emits `IndexAssigned` if successful.
       *
       * # <weight>
       * - `O(1)`.
       * - One storage mutation (codec `O(1)`).
       * - One transfer operation.
       * - One event.
       * -------------------
       * - DB Weight:
       *    - Reads: Indices Accounts, System Account (recipient)
       *    - Writes: Indices Accounts, System Account (recipient)
       * # </weight>
       */
      export interface transfer {
        type: "transfer"
        new: sp_runtime.multiaddress.MultiAddress
        index: u32
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error = "NotAssigned" | "NotOwner" | "InUse" | "NotTransfer" | "Permanent"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_indices.pallet.Event.IndexAssigned
      | pallet_indices.pallet.Event.IndexFreed
      | pallet_indices.pallet.Event.IndexFrozen
    export namespace Event {
      /** A account index was assigned. */
      export function IndexAssigned(
        value: Omit<pallet_indices.pallet.Event.IndexAssigned, "type">,
      ): pallet_indices.pallet.Event.IndexAssigned {
        return { type: "IndexAssigned", ...value }
      }
      /** A account index was assigned. */
      export interface IndexAssigned {
        type: "IndexAssigned"
        who: sp_core.crypto.AccountId32
        index: u32
      }
      /** A account index has been freed up (unassigned). */
      export function IndexFreed(
        value: Omit<pallet_indices.pallet.Event.IndexFreed, "type">,
      ): pallet_indices.pallet.Event.IndexFreed {
        return { type: "IndexFreed", ...value }
      }
      /** A account index has been freed up (unassigned). */
      export interface IndexFreed {
        type: "IndexFreed"
        index: u32
      }
      /** A account index has been frozen to its current account ID. */
      export function IndexFrozen(
        value: Omit<pallet_indices.pallet.Event.IndexFrozen, "type">,
      ): pallet_indices.pallet.Event.IndexFrozen {
        return { type: "IndexFrozen", ...value }
      }
      /** A account index has been frozen to its current account ID. */
      export interface IndexFrozen {
        type: "IndexFrozen"
        index: u32
        who: sp_core.crypto.AccountId32
      }
    }
  }
}
export namespace pallet_membership {
  export namespace pallet {
    export const $call: $.Codec<pallet_membership.pallet.Call> = _codec.$243
    export const $error: $.Codec<pallet_membership.pallet.Error> = _codec.$555
    export const $event: $.Codec<pallet_membership.pallet.Event> = _codec.$70
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_membership.pallet.Call.add_member
      | pallet_membership.pallet.Call.remove_member
      | pallet_membership.pallet.Call.swap_member
      | pallet_membership.pallet.Call.reset_members
      | pallet_membership.pallet.Call.change_key
      | pallet_membership.pallet.Call.set_prime
      | pallet_membership.pallet.Call.clear_prime
    export namespace Call {
      /**
       * Add a member `who` to the set.
       *
       * May only be called from `T::AddOrigin`.
       */
      export function add_member(
        value: Omit<pallet_membership.pallet.Call.add_member, "type">,
      ): pallet_membership.pallet.Call.add_member {
        return { type: "add_member", ...value }
      }
      /**
       * Add a member `who` to the set.
       *
       * May only be called from `T::AddOrigin`.
       */
      export interface add_member {
        type: "add_member"
        who: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Swap out the sending member for some other key `new`.
       *
       * May only be called from `Signed` origin of a current member.
       *
       * Prime membership is passed from the origin account to `new`, if extant.
       */
      export function change_key(
        value: Omit<pallet_membership.pallet.Call.change_key, "type">,
      ): pallet_membership.pallet.Call.change_key {
        return { type: "change_key", ...value }
      }
      /**
       * Swap out the sending member for some other key `new`.
       *
       * May only be called from `Signed` origin of a current member.
       *
       * Prime membership is passed from the origin account to `new`, if extant.
       */
      export interface change_key {
        type: "change_key"
        new: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Remove the prime member if it exists.
       *
       * May only be called from `T::PrimeOrigin`.
       */
      export function clear_prime(): pallet_membership.pallet.Call.clear_prime {
        return { type: "clear_prime" }
      }
      /**
       * Remove the prime member if it exists.
       *
       * May only be called from `T::PrimeOrigin`.
       */
      export interface clear_prime {
        type: "clear_prime"
      }
      /**
       * Remove a member `who` from the set.
       *
       * May only be called from `T::RemoveOrigin`.
       */
      export function remove_member(
        value: Omit<pallet_membership.pallet.Call.remove_member, "type">,
      ): pallet_membership.pallet.Call.remove_member {
        return { type: "remove_member", ...value }
      }
      /**
       * Remove a member `who` from the set.
       *
       * May only be called from `T::RemoveOrigin`.
       */
      export interface remove_member {
        type: "remove_member"
        who: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Change the membership to a new set, disregarding the existing membership. Be nice and
       * pass `members` pre-sorted.
       *
       * May only be called from `T::ResetOrigin`.
       */
      export function reset_members(
        value: Omit<pallet_membership.pallet.Call.reset_members, "type">,
      ): pallet_membership.pallet.Call.reset_members {
        return { type: "reset_members", ...value }
      }
      /**
       * Change the membership to a new set, disregarding the existing membership. Be nice and
       * pass `members` pre-sorted.
       *
       * May only be called from `T::ResetOrigin`.
       */
      export interface reset_members {
        type: "reset_members"
        members: Array<sp_core.crypto.AccountId32>
      }
      /**
       * Set the prime member. Must be a current member.
       *
       * May only be called from `T::PrimeOrigin`.
       */
      export function set_prime(
        value: Omit<pallet_membership.pallet.Call.set_prime, "type">,
      ): pallet_membership.pallet.Call.set_prime {
        return { type: "set_prime", ...value }
      }
      /**
       * Set the prime member. Must be a current member.
       *
       * May only be called from `T::PrimeOrigin`.
       */
      export interface set_prime {
        type: "set_prime"
        who: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Swap out one member `remove` for another `add`.
       *
       * May only be called from `T::SwapOrigin`.
       *
       * Prime membership is *not* passed from `remove` to `add`, if extant.
       */
      export function swap_member(
        value: Omit<pallet_membership.pallet.Call.swap_member, "type">,
      ): pallet_membership.pallet.Call.swap_member {
        return { type: "swap_member", ...value }
      }
      /**
       * Swap out one member `remove` for another `add`.
       *
       * May only be called from `T::SwapOrigin`.
       *
       * Prime membership is *not* passed from `remove` to `add`, if extant.
       */
      export interface swap_member {
        type: "swap_member"
        remove: sp_runtime.multiaddress.MultiAddress
        add: sp_runtime.multiaddress.MultiAddress
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error = "AlreadyMember" | "NotMember" | "TooManyMembers"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | "MemberAdded"
      | "MemberRemoved"
      | "MembersSwapped"
      | "MembersReset"
      | "KeyChanged"
      | "Dummy"
  }
}
export namespace pallet_multisig {
  export const $multisig: $.Codec<pallet_multisig.Multisig> = _codec.$589
  export const $timepoint: $.Codec<pallet_multisig.Timepoint> = _codec.$82
  export interface Multisig {
    when: pallet_multisig.Timepoint
    deposit: u128
    depositor: sp_core.crypto.AccountId32
    approvals: Array<sp_core.crypto.AccountId32>
  }
  export function Multisig(value: pallet_multisig.Multisig) {
    return value
  }
  export interface Timepoint {
    height: u32
    index: u32
  }
  export function Timepoint(value: pallet_multisig.Timepoint) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_multisig.pallet.Call> = _codec.$305
    export const $error: $.Codec<pallet_multisig.pallet.Error> = _codec.$590
    export const $event: $.Codec<pallet_multisig.pallet.Event> = _codec.$81
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_multisig.pallet.Call.as_multi_threshold_1
      | pallet_multisig.pallet.Call.as_multi
      | pallet_multisig.pallet.Call.approve_as_multi
      | pallet_multisig.pallet.Call.cancel_as_multi
    export namespace Call {
      /**
       * Register approval for a dispatch to be made from a deterministic composite account if
       * approved by a total of `threshold - 1` of `other_signatories`.
       *
       * Payment: `DepositBase` will be reserved if this is the first approval, plus
       * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
       * is cancelled.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `threshold`: The total number of approvals for this dispatch before it is executed.
       * - `other_signatories`: The accounts (other than the sender) who can approve this
       * dispatch. May not be empty.
       * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
       * not the first approval, then it must be `Some`, with the timepoint (block number and
       * transaction index) of the first approval transaction.
       * - `call_hash`: The hash of the call to be executed.
       *
       * NOTE: If this is the final approval, you will want to use `as_multi` instead.
       *
       * # <weight>
       * - `O(S)`.
       * - Up to one balance-reserve or unreserve operation.
       * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
       *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
       * - One encode & hash, both of complexity `O(S)`.
       * - Up to one binary search and insert (`O(logS + S)`).
       * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
       * - One event.
       * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
       *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
       * ----------------------------------
       * - DB Weight:
       *     - Read: Multisig Storage, [Caller Account]
       *     - Write: Multisig Storage, [Caller Account]
       * # </weight>
       */
      export function approve_as_multi(
        value: Omit<pallet_multisig.pallet.Call.approve_as_multi, "type">,
      ): pallet_multisig.pallet.Call.approve_as_multi {
        return { type: "approve_as_multi", ...value }
      }
      /**
       * Register approval for a dispatch to be made from a deterministic composite account if
       * approved by a total of `threshold - 1` of `other_signatories`.
       *
       * Payment: `DepositBase` will be reserved if this is the first approval, plus
       * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
       * is cancelled.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `threshold`: The total number of approvals for this dispatch before it is executed.
       * - `other_signatories`: The accounts (other than the sender) who can approve this
       * dispatch. May not be empty.
       * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
       * not the first approval, then it must be `Some`, with the timepoint (block number and
       * transaction index) of the first approval transaction.
       * - `call_hash`: The hash of the call to be executed.
       *
       * NOTE: If this is the final approval, you will want to use `as_multi` instead.
       *
       * # <weight>
       * - `O(S)`.
       * - Up to one balance-reserve or unreserve operation.
       * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
       *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
       * - One encode & hash, both of complexity `O(S)`.
       * - Up to one binary search and insert (`O(logS + S)`).
       * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
       * - One event.
       * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
       *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
       * ----------------------------------
       * - DB Weight:
       *     - Read: Multisig Storage, [Caller Account]
       *     - Write: Multisig Storage, [Caller Account]
       * # </weight>
       */
      export interface approve_as_multi {
        type: "approve_as_multi"
        threshold: u16
        other_signatories: Array<sp_core.crypto.AccountId32>
        maybe_timepoint: pallet_multisig.Timepoint | undefined
        call_hash: Uint8Array
        max_weight: sp_weights.weight_v2.Weight
      }
      /**
       * Register approval for a dispatch to be made from a deterministic composite account if
       * approved by a total of `threshold - 1` of `other_signatories`.
       *
       * If there are enough, then dispatch the call.
       *
       * Payment: `DepositBase` will be reserved if this is the first approval, plus
       * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
       * is cancelled.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `threshold`: The total number of approvals for this dispatch before it is executed.
       * - `other_signatories`: The accounts (other than the sender) who can approve this
       * dispatch. May not be empty.
       * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
       * not the first approval, then it must be `Some`, with the timepoint (block number and
       * transaction index) of the first approval transaction.
       * - `call`: The call to be executed.
       *
       * NOTE: Unless this is the final approval, you will generally want to use
       * `approve_as_multi` instead, since it only requires a hash of the call.
       *
       * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
       * on success, result is `Ok` and the result from the interior call, if it was executed,
       * may be found in the deposited `MultisigExecuted` event.
       *
       * # <weight>
       * - `O(S + Z + Call)`.
       * - Up to one balance-reserve or unreserve operation.
       * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
       *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
       * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
       * - One encode & hash, both of complexity `O(S)`.
       * - Up to one binary search and insert (`O(logS + S)`).
       * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
       * - One event.
       * - The weight of the `call`.
       * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
       *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
       * -------------------------------
       * - DB Weight:
       *     - Reads: Multisig Storage, [Caller Account]
       *     - Writes: Multisig Storage, [Caller Account]
       * - Plus Call Weight
       * # </weight>
       */
      export function as_multi(
        value: Omit<pallet_multisig.pallet.Call.as_multi, "type">,
      ): pallet_multisig.pallet.Call.as_multi {
        return { type: "as_multi", ...value }
      }
      /**
       * Register approval for a dispatch to be made from a deterministic composite account if
       * approved by a total of `threshold - 1` of `other_signatories`.
       *
       * If there are enough, then dispatch the call.
       *
       * Payment: `DepositBase` will be reserved if this is the first approval, plus
       * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
       * is cancelled.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `threshold`: The total number of approvals for this dispatch before it is executed.
       * - `other_signatories`: The accounts (other than the sender) who can approve this
       * dispatch. May not be empty.
       * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
       * not the first approval, then it must be `Some`, with the timepoint (block number and
       * transaction index) of the first approval transaction.
       * - `call`: The call to be executed.
       *
       * NOTE: Unless this is the final approval, you will generally want to use
       * `approve_as_multi` instead, since it only requires a hash of the call.
       *
       * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
       * on success, result is `Ok` and the result from the interior call, if it was executed,
       * may be found in the deposited `MultisigExecuted` event.
       *
       * # <weight>
       * - `O(S + Z + Call)`.
       * - Up to one balance-reserve or unreserve operation.
       * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
       *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
       * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
       * - One encode & hash, both of complexity `O(S)`.
       * - Up to one binary search and insert (`O(logS + S)`).
       * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
       * - One event.
       * - The weight of the `call`.
       * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
       *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
       * -------------------------------
       * - DB Weight:
       *     - Reads: Multisig Storage, [Caller Account]
       *     - Writes: Multisig Storage, [Caller Account]
       * - Plus Call Weight
       * # </weight>
       */
      export interface as_multi {
        type: "as_multi"
        threshold: u16
        other_signatories: Array<sp_core.crypto.AccountId32>
        maybe_timepoint: pallet_multisig.Timepoint | undefined
        call: polkadot_runtime.RuntimeCall
        max_weight: sp_weights.weight_v2.Weight
      }
      /**
       * Immediately dispatch a multi-signature call using a single approval from the caller.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `other_signatories`: The accounts (other than the sender) who are part of the
       * multi-signature, but do not participate in the approval process.
       * - `call`: The call to be executed.
       *
       * Result is equivalent to the dispatched result.
       *
       * # <weight>
       * O(Z + C) where Z is the length of the call and C its execution weight.
       * -------------------------------
       * - DB Weight: None
       * - Plus Call Weight
       * # </weight>
       */
      export function as_multi_threshold_1(
        value: Omit<pallet_multisig.pallet.Call.as_multi_threshold_1, "type">,
      ): pallet_multisig.pallet.Call.as_multi_threshold_1 {
        return { type: "as_multi_threshold_1", ...value }
      }
      /**
       * Immediately dispatch a multi-signature call using a single approval from the caller.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `other_signatories`: The accounts (other than the sender) who are part of the
       * multi-signature, but do not participate in the approval process.
       * - `call`: The call to be executed.
       *
       * Result is equivalent to the dispatched result.
       *
       * # <weight>
       * O(Z + C) where Z is the length of the call and C its execution weight.
       * -------------------------------
       * - DB Weight: None
       * - Plus Call Weight
       * # </weight>
       */
      export interface as_multi_threshold_1 {
        type: "as_multi_threshold_1"
        other_signatories: Array<sp_core.crypto.AccountId32>
        call: polkadot_runtime.RuntimeCall
      }
      /**
       * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
       * for this operation will be unreserved on success.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `threshold`: The total number of approvals for this dispatch before it is executed.
       * - `other_signatories`: The accounts (other than the sender) who can approve this
       * dispatch. May not be empty.
       * - `timepoint`: The timepoint (block number and transaction index) of the first approval
       * transaction for this dispatch.
       * - `call_hash`: The hash of the call to be executed.
       *
       * # <weight>
       * - `O(S)`.
       * - Up to one balance-reserve or unreserve operation.
       * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
       *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
       * - One encode & hash, both of complexity `O(S)`.
       * - One event.
       * - I/O: 1 read `O(S)`, one remove.
       * - Storage: removes one item.
       * ----------------------------------
       * - DB Weight:
       *     - Read: Multisig Storage, [Caller Account], Refund Account
       *     - Write: Multisig Storage, [Caller Account], Refund Account
       * # </weight>
       */
      export function cancel_as_multi(
        value: Omit<pallet_multisig.pallet.Call.cancel_as_multi, "type">,
      ): pallet_multisig.pallet.Call.cancel_as_multi {
        return { type: "cancel_as_multi", ...value }
      }
      /**
       * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
       * for this operation will be unreserved on success.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `threshold`: The total number of approvals for this dispatch before it is executed.
       * - `other_signatories`: The accounts (other than the sender) who can approve this
       * dispatch. May not be empty.
       * - `timepoint`: The timepoint (block number and transaction index) of the first approval
       * transaction for this dispatch.
       * - `call_hash`: The hash of the call to be executed.
       *
       * # <weight>
       * - `O(S)`.
       * - Up to one balance-reserve or unreserve operation.
       * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
       *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
       * - One encode & hash, both of complexity `O(S)`.
       * - One event.
       * - I/O: 1 read `O(S)`, one remove.
       * - Storage: removes one item.
       * ----------------------------------
       * - DB Weight:
       *     - Read: Multisig Storage, [Caller Account], Refund Account
       *     - Write: Multisig Storage, [Caller Account], Refund Account
       * # </weight>
       */
      export interface cancel_as_multi {
        type: "cancel_as_multi"
        threshold: u16
        other_signatories: Array<sp_core.crypto.AccountId32>
        timepoint: pallet_multisig.Timepoint
        call_hash: Uint8Array
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "MinimumThreshold"
      | "AlreadyApproved"
      | "NoApprovalsNeeded"
      | "TooFewSignatories"
      | "TooManySignatories"
      | "SignatoriesOutOfOrder"
      | "SenderInSignatories"
      | "NotFound"
      | "NotOwner"
      | "NoTimepoint"
      | "WrongTimepoint"
      | "UnexpectedTimepoint"
      | "MaxWeightTooLow"
      | "AlreadyStored"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_multisig.pallet.Event.NewMultisig
      | pallet_multisig.pallet.Event.MultisigApproval
      | pallet_multisig.pallet.Event.MultisigExecuted
      | pallet_multisig.pallet.Event.MultisigCancelled
    export namespace Event {
      /** A multisig operation has been approved by someone. */
      export function MultisigApproval(
        value: Omit<pallet_multisig.pallet.Event.MultisigApproval, "type">,
      ): pallet_multisig.pallet.Event.MultisigApproval {
        return { type: "MultisigApproval", ...value }
      }
      /** A multisig operation has been approved by someone. */
      export interface MultisigApproval {
        type: "MultisigApproval"
        approving: sp_core.crypto.AccountId32
        timepoint: pallet_multisig.Timepoint
        multisig: sp_core.crypto.AccountId32
        call_hash: Uint8Array
      }
      /** A multisig operation has been cancelled. */
      export function MultisigCancelled(
        value: Omit<pallet_multisig.pallet.Event.MultisigCancelled, "type">,
      ): pallet_multisig.pallet.Event.MultisigCancelled {
        return { type: "MultisigCancelled", ...value }
      }
      /** A multisig operation has been cancelled. */
      export interface MultisigCancelled {
        type: "MultisigCancelled"
        cancelling: sp_core.crypto.AccountId32
        timepoint: pallet_multisig.Timepoint
        multisig: sp_core.crypto.AccountId32
        call_hash: Uint8Array
      }
      /** A multisig operation has been executed. */
      export function MultisigExecuted(
        value: Omit<pallet_multisig.pallet.Event.MultisigExecuted, "type">,
      ): pallet_multisig.pallet.Event.MultisigExecuted {
        return { type: "MultisigExecuted", ...value }
      }
      /** A multisig operation has been executed. */
      export interface MultisigExecuted {
        type: "MultisigExecuted"
        approving: sp_core.crypto.AccountId32
        timepoint: pallet_multisig.Timepoint
        multisig: sp_core.crypto.AccountId32
        call_hash: Uint8Array
        result: null | ChainError<sp_runtime.DispatchError>
      }
      /** A new multisig operation has begun. */
      export function NewMultisig(
        value: Omit<pallet_multisig.pallet.Event.NewMultisig, "type">,
      ): pallet_multisig.pallet.Event.NewMultisig {
        return { type: "NewMultisig", ...value }
      }
      /** A new multisig operation has begun. */
      export interface NewMultisig {
        type: "NewMultisig"
        approving: sp_core.crypto.AccountId32
        multisig: sp_core.crypto.AccountId32
        call_hash: Uint8Array
      }
    }
  }
}
export namespace pallet_nomination_pools {
  export const $bondExtra: $.Codec<pallet_nomination_pools.BondExtra> = _codec.$370
  export const $bondedPoolInner: $.Codec<pallet_nomination_pools.BondedPoolInner> = _codec.$622
  export const $poolMember: $.Codec<pallet_nomination_pools.PoolMember> = _codec.$617
  export const $poolRoles: $.Codec<pallet_nomination_pools.PoolRoles> = _codec.$623
  export const $poolState: $.Codec<pallet_nomination_pools.PoolState> = _codec.$91
  export const $rewardPool: $.Codec<pallet_nomination_pools.RewardPool> = _codec.$624
  export const $subPools: $.Codec<pallet_nomination_pools.SubPools> = _codec.$625
  export const $unbondPool: $.Codec<pallet_nomination_pools.UnbondPool> = _codec.$626
  export type BondExtra =
    | pallet_nomination_pools.BondExtra.FreeBalance
    | pallet_nomination_pools.BondExtra.Rewards
  export namespace BondExtra {
    export function FreeBalance(
      value: pallet_nomination_pools.BondExtra.FreeBalance["value"],
    ): pallet_nomination_pools.BondExtra.FreeBalance {
      return { type: "FreeBalance", value }
    }
    export interface FreeBalance {
      type: "FreeBalance"
      value: u128
    }
    export function Rewards(): pallet_nomination_pools.BondExtra.Rewards {
      return { type: "Rewards" }
    }
    export interface Rewards {
      type: "Rewards"
    }
  }
  export interface BondedPoolInner {
    points: u128
    state: pallet_nomination_pools.PoolState
    member_counter: u32
    roles: pallet_nomination_pools.PoolRoles
  }
  export function BondedPoolInner(value: pallet_nomination_pools.BondedPoolInner) {
    return value
  }
  export namespace ConfigOp {
    export const $$$u128: $.Codec<pallet_nomination_pools.ConfigOp.$$u128> = _codec.$371
    export const $$$u32: $.Codec<pallet_nomination_pools.ConfigOp.$$u32> = _codec.$372
    export namespace $$sp_core {
      export namespace crypto {
        export const $accountId32: $.Codec<
          pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32
        > = _codec.$373
        export type AccountId32 =
          | pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32.Noop
          | pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32.Set
          | pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32.Remove
        export namespace AccountId32 {
          export function Noop(): pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32.Noop {
            return { type: "Noop" }
          }
          export interface Noop {
            type: "Noop"
          }
          export function Remove(): pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32.Remove {
            return { type: "Remove" }
          }
          export interface Remove {
            type: "Remove"
          }
          export function Set(
            value: pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32.Set["value"],
          ): pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32.Set {
            return { type: "Set", value }
          }
          export interface Set {
            type: "Set"
            value: sp_core.crypto.AccountId32
          }
        }
      }
    }
    export type $$u128 =
      | pallet_nomination_pools.ConfigOp.$$u128.Noop
      | pallet_nomination_pools.ConfigOp.$$u128.Set
      | pallet_nomination_pools.ConfigOp.$$u128.Remove
    export namespace $$u128 {
      export function Noop(): pallet_nomination_pools.ConfigOp.$$u128.Noop {
        return { type: "Noop" }
      }
      export interface Noop {
        type: "Noop"
      }
      export function Remove(): pallet_nomination_pools.ConfigOp.$$u128.Remove {
        return { type: "Remove" }
      }
      export interface Remove {
        type: "Remove"
      }
      export function Set(
        value: pallet_nomination_pools.ConfigOp.$$u128.Set["value"],
      ): pallet_nomination_pools.ConfigOp.$$u128.Set {
        return { type: "Set", value }
      }
      export interface Set {
        type: "Set"
        value: u128
      }
    }
    export type $$u32 =
      | pallet_nomination_pools.ConfigOp.$$u32.Noop
      | pallet_nomination_pools.ConfigOp.$$u32.Set
      | pallet_nomination_pools.ConfigOp.$$u32.Remove
    export namespace $$u32 {
      export function Noop(): pallet_nomination_pools.ConfigOp.$$u32.Noop {
        return { type: "Noop" }
      }
      export interface Noop {
        type: "Noop"
      }
      export function Remove(): pallet_nomination_pools.ConfigOp.$$u32.Remove {
        return { type: "Remove" }
      }
      export interface Remove {
        type: "Remove"
      }
      export function Set(
        value: pallet_nomination_pools.ConfigOp.$$u32.Set["value"],
      ): pallet_nomination_pools.ConfigOp.$$u32.Set {
        return { type: "Set", value }
      }
      export interface Set {
        type: "Set"
        value: u32
      }
    }
  }
  export interface PoolMember {
    pool_id: u32
    points: u128
    last_recorded_reward_counter: sp_arithmetic.fixed_point.FixedU128
    unbonding_eras: Map<u32, u128>
  }
  export function PoolMember(value: pallet_nomination_pools.PoolMember) {
    return value
  }
  export interface PoolRoles {
    depositor: sp_core.crypto.AccountId32
    root: sp_core.crypto.AccountId32 | undefined
    nominator: sp_core.crypto.AccountId32 | undefined
    state_toggler: sp_core.crypto.AccountId32 | undefined
  }
  export function PoolRoles(value: pallet_nomination_pools.PoolRoles) {
    return value
  }
  export type PoolState = "Open" | "Blocked" | "Destroying"
  export interface RewardPool {
    last_recorded_reward_counter: sp_arithmetic.fixed_point.FixedU128
    last_recorded_total_payouts: u128
    total_rewards_claimed: u128
  }
  export function RewardPool(value: pallet_nomination_pools.RewardPool) {
    return value
  }
  export interface SubPools {
    no_era: pallet_nomination_pools.UnbondPool
    with_era: Map<u32, pallet_nomination_pools.UnbondPool>
  }
  export function SubPools(value: pallet_nomination_pools.SubPools) {
    return value
  }
  export interface UnbondPool {
    points: u128
    balance: u128
  }
  export function UnbondPool(value: pallet_nomination_pools.UnbondPool) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_nomination_pools.pallet.Call> = _codec.$369
    export const $defensiveError: $.Codec<pallet_nomination_pools.pallet.DefensiveError> =
      _codec.$633
    export const $error: $.Codec<pallet_nomination_pools.pallet.Error> = _codec.$632
    export const $event: $.Codec<pallet_nomination_pools.pallet.Event> = _codec.$90
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_nomination_pools.pallet.Call.join
      | pallet_nomination_pools.pallet.Call.bond_extra
      | pallet_nomination_pools.pallet.Call.claim_payout
      | pallet_nomination_pools.pallet.Call.unbond
      | pallet_nomination_pools.pallet.Call.pool_withdraw_unbonded
      | pallet_nomination_pools.pallet.Call.withdraw_unbonded
      | pallet_nomination_pools.pallet.Call.create
      | pallet_nomination_pools.pallet.Call.nominate
      | pallet_nomination_pools.pallet.Call.set_state
      | pallet_nomination_pools.pallet.Call.set_metadata
      | pallet_nomination_pools.pallet.Call.set_configs
      | pallet_nomination_pools.pallet.Call.update_roles
      | pallet_nomination_pools.pallet.Call.chill
    export namespace Call {
      /**
       * Bond `extra` more funds from `origin` into the pool to which they already belong.
       *
       * Additional funds can come from either the free balance of the account, of from the
       * accumulated rewards, see [`BondExtra`].
       *
       * Bonding extra funds implies an automatic payout of all pending rewards as well.
       */
      export function bond_extra(
        value: Omit<pallet_nomination_pools.pallet.Call.bond_extra, "type">,
      ): pallet_nomination_pools.pallet.Call.bond_extra {
        return { type: "bond_extra", ...value }
      }
      /**
       * Bond `extra` more funds from `origin` into the pool to which they already belong.
       *
       * Additional funds can come from either the free balance of the account, of from the
       * accumulated rewards, see [`BondExtra`].
       *
       * Bonding extra funds implies an automatic payout of all pending rewards as well.
       */
      export interface bond_extra {
        type: "bond_extra"
        extra: pallet_nomination_pools.BondExtra
      }
      /**
       * Chill on behalf of the pool.
       *
       * The dispatch origin of this call must be signed by the pool nominator or the pool
       * root role, same as [`Pallet::nominate`].
       *
       * This directly forward the call to the staking pallet, on behalf of the pool bonded
       * account.
       */
      export function chill(
        value: Omit<pallet_nomination_pools.pallet.Call.chill, "type">,
      ): pallet_nomination_pools.pallet.Call.chill {
        return { type: "chill", ...value }
      }
      /**
       * Chill on behalf of the pool.
       *
       * The dispatch origin of this call must be signed by the pool nominator or the pool
       * root role, same as [`Pallet::nominate`].
       *
       * This directly forward the call to the staking pallet, on behalf of the pool bonded
       * account.
       */
      export interface chill {
        type: "chill"
        pool_id: u32
      }
      /**
       * A bonded member can use this to claim their payout based on the rewards that the pool
       * has accumulated since their last claimed payout (OR since joining if this is there first
       * time claiming rewards). The payout will be transferred to the member's account.
       *
       * The member will earn rewards pro rata based on the members stake vs the sum of the
       * members in the pools stake. Rewards do not "expire".
       */
      export function claim_payout(): pallet_nomination_pools.pallet.Call.claim_payout {
        return { type: "claim_payout" }
      }
      /**
       * A bonded member can use this to claim their payout based on the rewards that the pool
       * has accumulated since their last claimed payout (OR since joining if this is there first
       * time claiming rewards). The payout will be transferred to the member's account.
       *
       * The member will earn rewards pro rata based on the members stake vs the sum of the
       * members in the pools stake. Rewards do not "expire".
       */
      export interface claim_payout {
        type: "claim_payout"
      }
      /**
       * Create a new delegation pool.
       *
       * # Arguments
       *
       * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
       *   deposit since the pools creator cannot fully unbond funds until the pool is being
       *   destroyed.
       * * `index` - A disambiguation index for creating the account. Likely only useful when
       *   creating multiple pools in the same extrinsic.
       * * `root` - The account to set as [`PoolRoles::root`].
       * * `nominator` - The account to set as the [`PoolRoles::nominator`].
       * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
       *
       * # Note
       *
       * In addition to `amount`, the caller will transfer the existential deposit; so the caller
       * needs at have at least `amount + existential_deposit` transferrable.
       */
      export function create(
        value: Omit<pallet_nomination_pools.pallet.Call.create, "type">,
      ): pallet_nomination_pools.pallet.Call.create {
        return { type: "create", ...value }
      }
      /**
       * Create a new delegation pool.
       *
       * # Arguments
       *
       * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
       *   deposit since the pools creator cannot fully unbond funds until the pool is being
       *   destroyed.
       * * `index` - A disambiguation index for creating the account. Likely only useful when
       *   creating multiple pools in the same extrinsic.
       * * `root` - The account to set as [`PoolRoles::root`].
       * * `nominator` - The account to set as the [`PoolRoles::nominator`].
       * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
       *
       * # Note
       *
       * In addition to `amount`, the caller will transfer the existential deposit; so the caller
       * needs at have at least `amount + existential_deposit` transferrable.
       */
      export interface create {
        type: "create"
        amount: Compact<u128>
        root: sp_runtime.multiaddress.MultiAddress
        nominator: sp_runtime.multiaddress.MultiAddress
        state_toggler: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Stake funds with a pool. The amount to bond is transferred from the member to the
       * pools account and immediately increases the pools bond.
       *
       * # Note
       *
       * * An account can only be a member of a single pool.
       * * An account cannot join the same pool multiple times.
       * * This call will *not* dust the member account, so the member must have at least
       *   `existential deposit + amount` in their account.
       * * Only a pool with [`PoolState::Open`] can be joined
       */
      export function join(
        value: Omit<pallet_nomination_pools.pallet.Call.join, "type">,
      ): pallet_nomination_pools.pallet.Call.join {
        return { type: "join", ...value }
      }
      /**
       * Stake funds with a pool. The amount to bond is transferred from the member to the
       * pools account and immediately increases the pools bond.
       *
       * # Note
       *
       * * An account can only be a member of a single pool.
       * * An account cannot join the same pool multiple times.
       * * This call will *not* dust the member account, so the member must have at least
       *   `existential deposit + amount` in their account.
       * * Only a pool with [`PoolState::Open`] can be joined
       */
      export interface join {
        type: "join"
        amount: Compact<u128>
        pool_id: u32
      }
      /**
       * Nominate on behalf of the pool.
       *
       * The dispatch origin of this call must be signed by the pool nominator or the pool
       * root role.
       *
       * This directly forward the call to the staking pallet, on behalf of the pool bonded
       * account.
       */
      export function nominate(
        value: Omit<pallet_nomination_pools.pallet.Call.nominate, "type">,
      ): pallet_nomination_pools.pallet.Call.nominate {
        return { type: "nominate", ...value }
      }
      /**
       * Nominate on behalf of the pool.
       *
       * The dispatch origin of this call must be signed by the pool nominator or the pool
       * root role.
       *
       * This directly forward the call to the staking pallet, on behalf of the pool bonded
       * account.
       */
      export interface nominate {
        type: "nominate"
        pool_id: u32
        validators: Array<sp_core.crypto.AccountId32>
      }
      /**
       * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
       *
       * This is useful if their are too many unlocking chunks to call `unbond`, and some
       * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
       * would probably see an error like `NoMoreChunks` emitted from the staking system when
       * they attempt to unbond.
       */
      export function pool_withdraw_unbonded(
        value: Omit<pallet_nomination_pools.pallet.Call.pool_withdraw_unbonded, "type">,
      ): pallet_nomination_pools.pallet.Call.pool_withdraw_unbonded {
        return { type: "pool_withdraw_unbonded", ...value }
      }
      /**
       * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
       *
       * This is useful if their are too many unlocking chunks to call `unbond`, and some
       * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
       * would probably see an error like `NoMoreChunks` emitted from the staking system when
       * they attempt to unbond.
       */
      export interface pool_withdraw_unbonded {
        type: "pool_withdraw_unbonded"
        pool_id: u32
        num_slashing_spans: u32
      }
      /**
       * Update configurations for the nomination pools. The origin for this call must be
       * Root.
       *
       * # Arguments
       *
       * * `min_join_bond` - Set [`MinJoinBond`].
       * * `min_create_bond` - Set [`MinCreateBond`].
       * * `max_pools` - Set [`MaxPools`].
       * * `max_members` - Set [`MaxPoolMembers`].
       * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
       */
      export function set_configs(
        value: Omit<pallet_nomination_pools.pallet.Call.set_configs, "type">,
      ): pallet_nomination_pools.pallet.Call.set_configs {
        return { type: "set_configs", ...value }
      }
      /**
       * Update configurations for the nomination pools. The origin for this call must be
       * Root.
       *
       * # Arguments
       *
       * * `min_join_bond` - Set [`MinJoinBond`].
       * * `min_create_bond` - Set [`MinCreateBond`].
       * * `max_pools` - Set [`MaxPools`].
       * * `max_members` - Set [`MaxPoolMembers`].
       * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
       */
      export interface set_configs {
        type: "set_configs"
        min_join_bond: pallet_nomination_pools.ConfigOp.$$u128
        min_create_bond: pallet_nomination_pools.ConfigOp.$$u128
        max_pools: pallet_nomination_pools.ConfigOp.$$u32
        max_members: pallet_nomination_pools.ConfigOp.$$u32
        max_members_per_pool: pallet_nomination_pools.ConfigOp.$$u32
      }
      /**
       * Set a new metadata for the pool.
       *
       * The dispatch origin of this call must be signed by the state toggler, or the root role
       * of the pool.
       */
      export function set_metadata(
        value: Omit<pallet_nomination_pools.pallet.Call.set_metadata, "type">,
      ): pallet_nomination_pools.pallet.Call.set_metadata {
        return { type: "set_metadata", ...value }
      }
      /**
       * Set a new metadata for the pool.
       *
       * The dispatch origin of this call must be signed by the state toggler, or the root role
       * of the pool.
       */
      export interface set_metadata {
        type: "set_metadata"
        pool_id: u32
        metadata: Uint8Array
      }
      /**
       * Set a new state for the pool.
       *
       * If a pool is already in the `Destroying` state, then under no condition can its state
       * change again.
       *
       * The dispatch origin of this call must be either:
       *
       * 1. signed by the state toggler, or the root role of the pool,
       * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
       *    then the state of the pool can be permissionlessly changed to `Destroying`.
       */
      export function set_state(
        value: Omit<pallet_nomination_pools.pallet.Call.set_state, "type">,
      ): pallet_nomination_pools.pallet.Call.set_state {
        return { type: "set_state", ...value }
      }
      /**
       * Set a new state for the pool.
       *
       * If a pool is already in the `Destroying` state, then under no condition can its state
       * change again.
       *
       * The dispatch origin of this call must be either:
       *
       * 1. signed by the state toggler, or the root role of the pool,
       * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
       *    then the state of the pool can be permissionlessly changed to `Destroying`.
       */
      export interface set_state {
        type: "set_state"
        pool_id: u32
        state: pallet_nomination_pools.PoolState
      }
      /**
       * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
       * implicitly collects the rewards one last time, since not doing so would mean some
       * rewards would be forfeited.
       *
       * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
       * account).
       *
       * # Conditions for a permissionless dispatch.
       *
       * * The pool is blocked and the caller is either the root or state-toggler. This is
       *   refereed to as a kick.
       * * The pool is destroying and the member is not the depositor.
       * * The pool is destroying, the member is the depositor and no other members are in the
       *   pool.
       *
       * ## Conditions for permissioned dispatch (i.e. the caller is also the
       * `member_account`):
       *
       * * The caller is not the depositor.
       * * The caller is the depositor, the pool is destroying and no other members are in the
       *   pool.
       *
       * # Note
       *
       * If there are too many unlocking chunks to unbond with the pool account,
       * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If
       * there are too many unlocking chunks, the result of this call will likely be the
       * `NoMoreChunks` error from the staking system.
       */
      export function unbond(
        value: Omit<pallet_nomination_pools.pallet.Call.unbond, "type">,
      ): pallet_nomination_pools.pallet.Call.unbond {
        return { type: "unbond", ...value }
      }
      /**
       * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
       * implicitly collects the rewards one last time, since not doing so would mean some
       * rewards would be forfeited.
       *
       * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
       * account).
       *
       * # Conditions for a permissionless dispatch.
       *
       * * The pool is blocked and the caller is either the root or state-toggler. This is
       *   refereed to as a kick.
       * * The pool is destroying and the member is not the depositor.
       * * The pool is destroying, the member is the depositor and no other members are in the
       *   pool.
       *
       * ## Conditions for permissioned dispatch (i.e. the caller is also the
       * `member_account`):
       *
       * * The caller is not the depositor.
       * * The caller is the depositor, the pool is destroying and no other members are in the
       *   pool.
       *
       * # Note
       *
       * If there are too many unlocking chunks to unbond with the pool account,
       * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If
       * there are too many unlocking chunks, the result of this call will likely be the
       * `NoMoreChunks` error from the staking system.
       */
      export interface unbond {
        type: "unbond"
        member_account: sp_runtime.multiaddress.MultiAddress
        unbonding_points: Compact<u128>
      }
      /**
       * Update the roles of the pool.
       *
       * The root is the only entity that can change any of the roles, including itself,
       * excluding the depositor, who can never change.
       *
       * It emits an event, notifying UIs of the role change. This event is quite relevant to
       * most pool members and they should be informed of changes to pool roles.
       */
      export function update_roles(
        value: Omit<pallet_nomination_pools.pallet.Call.update_roles, "type">,
      ): pallet_nomination_pools.pallet.Call.update_roles {
        return { type: "update_roles", ...value }
      }
      /**
       * Update the roles of the pool.
       *
       * The root is the only entity that can change any of the roles, including itself,
       * excluding the depositor, who can never change.
       *
       * It emits an event, notifying UIs of the role change. This event is quite relevant to
       * most pool members and they should be informed of changes to pool roles.
       */
      export interface update_roles {
        type: "update_roles"
        pool_id: u32
        new_root: pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32
        new_nominator: pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32
        new_state_toggler: pallet_nomination_pools.ConfigOp.$$sp_core.crypto.AccountId32
      }
      /**
       * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
       * error is returned.
       *
       * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
       * account).
       *
       * # Conditions for a permissionless dispatch
       *
       * * The pool is in destroy mode and the target is not the depositor.
       * * The target is the depositor and they are the only member in the sub pools.
       * * The pool is blocked and the caller is either the root or state-toggler.
       *
       * # Conditions for permissioned dispatch
       *
       * * The caller is the target and they are not the depositor.
       *
       * # Note
       *
       * If the target is the depositor, the pool will be destroyed.
       */
      export function withdraw_unbonded(
        value: Omit<pallet_nomination_pools.pallet.Call.withdraw_unbonded, "type">,
      ): pallet_nomination_pools.pallet.Call.withdraw_unbonded {
        return { type: "withdraw_unbonded", ...value }
      }
      /**
       * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
       * error is returned.
       *
       * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
       * account).
       *
       * # Conditions for a permissionless dispatch
       *
       * * The pool is in destroy mode and the target is not the depositor.
       * * The target is the depositor and they are the only member in the sub pools.
       * * The pool is blocked and the caller is either the root or state-toggler.
       *
       * # Conditions for permissioned dispatch
       *
       * * The caller is the target and they are not the depositor.
       *
       * # Note
       *
       * If the target is the depositor, the pool will be destroyed.
       */
      export interface withdraw_unbonded {
        type: "withdraw_unbonded"
        member_account: sp_runtime.multiaddress.MultiAddress
        num_slashing_spans: u32
      }
    }
    export type DefensiveError =
      | "NotEnoughSpaceInUnbondPool"
      | "PoolNotFound"
      | "RewardPoolNotFound"
      | "SubPoolsNotFound"
      | "BondedStashKilledPrematurely"
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | pallet_nomination_pools.pallet.Error.PoolNotFound
      | pallet_nomination_pools.pallet.Error.PoolMemberNotFound
      | pallet_nomination_pools.pallet.Error.RewardPoolNotFound
      | pallet_nomination_pools.pallet.Error.SubPoolsNotFound
      | pallet_nomination_pools.pallet.Error.AccountBelongsToOtherPool
      | pallet_nomination_pools.pallet.Error.FullyUnbonding
      | pallet_nomination_pools.pallet.Error.MaxUnbondingLimit
      | pallet_nomination_pools.pallet.Error.CannotWithdrawAny
      | pallet_nomination_pools.pallet.Error.MinimumBondNotMet
      | pallet_nomination_pools.pallet.Error.OverflowRisk
      | pallet_nomination_pools.pallet.Error.NotDestroying
      | pallet_nomination_pools.pallet.Error.NotNominator
      | pallet_nomination_pools.pallet.Error.NotKickerOrDestroying
      | pallet_nomination_pools.pallet.Error.NotOpen
      | pallet_nomination_pools.pallet.Error.MaxPools
      | pallet_nomination_pools.pallet.Error.MaxPoolMembers
      | pallet_nomination_pools.pallet.Error.CanNotChangeState
      | pallet_nomination_pools.pallet.Error.DoesNotHavePermission
      | pallet_nomination_pools.pallet.Error.MetadataExceedsMaxLen
      | pallet_nomination_pools.pallet.Error.Defensive
      | pallet_nomination_pools.pallet.Error.PartialUnbondNotAllowedPermissionlessly
    export namespace Error {
      /**
       * An account is already delegating in another pool. An account may only belong to one
       * pool at a time.
       */
      export function AccountBelongsToOtherPool(): pallet_nomination_pools.pallet.Error.AccountBelongsToOtherPool {
        return { type: "AccountBelongsToOtherPool" }
      }
      /**
       * An account is already delegating in another pool. An account may only belong to one
       * pool at a time.
       */
      export interface AccountBelongsToOtherPool {
        type: "AccountBelongsToOtherPool"
      }
      /** The pools state cannot be changed. */
      export function CanNotChangeState(): pallet_nomination_pools.pallet.Error.CanNotChangeState {
        return { type: "CanNotChangeState" }
      }
      /** The pools state cannot be changed. */
      export interface CanNotChangeState {
        type: "CanNotChangeState"
      }
      /** None of the funds can be withdrawn yet because the bonding duration has not passed. */
      export function CannotWithdrawAny(): pallet_nomination_pools.pallet.Error.CannotWithdrawAny {
        return { type: "CannotWithdrawAny" }
      }
      /** None of the funds can be withdrawn yet because the bonding duration has not passed. */
      export interface CannotWithdrawAny {
        type: "CannotWithdrawAny"
      }
      /**
       * Some error occurred that should never happen. This should be reported to the
       * maintainers.
       */
      export function Defensive(
        value: pallet_nomination_pools.pallet.Error.Defensive["value"],
      ): pallet_nomination_pools.pallet.Error.Defensive {
        return { type: "Defensive", value }
      }
      /**
       * Some error occurred that should never happen. This should be reported to the
       * maintainers.
       */
      export interface Defensive {
        type: "Defensive"
        value: pallet_nomination_pools.pallet.DefensiveError
      }
      /** The caller does not have adequate permissions. */
      export function DoesNotHavePermission(): pallet_nomination_pools.pallet.Error.DoesNotHavePermission {
        return { type: "DoesNotHavePermission" }
      }
      /** The caller does not have adequate permissions. */
      export interface DoesNotHavePermission {
        type: "DoesNotHavePermission"
      }
      /**
       * The member is fully unbonded (and thus cannot access the bonded and reward pool
       * anymore to, for example, collect rewards).
       */
      export function FullyUnbonding(): pallet_nomination_pools.pallet.Error.FullyUnbonding {
        return { type: "FullyUnbonding" }
      }
      /**
       * The member is fully unbonded (and thus cannot access the bonded and reward pool
       * anymore to, for example, collect rewards).
       */
      export interface FullyUnbonding {
        type: "FullyUnbonding"
      }
      /** Too many members in the pool or system. */
      export function MaxPoolMembers(): pallet_nomination_pools.pallet.Error.MaxPoolMembers {
        return { type: "MaxPoolMembers" }
      }
      /** Too many members in the pool or system. */
      export interface MaxPoolMembers {
        type: "MaxPoolMembers"
      }
      /** The system is maxed out on pools. */
      export function MaxPools(): pallet_nomination_pools.pallet.Error.MaxPools {
        return { type: "MaxPools" }
      }
      /** The system is maxed out on pools. */
      export interface MaxPools {
        type: "MaxPools"
      }
      /** The member cannot unbond further chunks due to reaching the limit. */
      export function MaxUnbondingLimit(): pallet_nomination_pools.pallet.Error.MaxUnbondingLimit {
        return { type: "MaxUnbondingLimit" }
      }
      /** The member cannot unbond further chunks due to reaching the limit. */
      export interface MaxUnbondingLimit {
        type: "MaxUnbondingLimit"
      }
      /** Metadata exceeds [`Config::MaxMetadataLen`] */
      export function MetadataExceedsMaxLen(): pallet_nomination_pools.pallet.Error.MetadataExceedsMaxLen {
        return { type: "MetadataExceedsMaxLen" }
      }
      /** Metadata exceeds [`Config::MaxMetadataLen`] */
      export interface MetadataExceedsMaxLen {
        type: "MetadataExceedsMaxLen"
      }
      /**
       * The amount does not meet the minimum bond to either join or create a pool.
       *
       * The depositor can never unbond to a value less than
       * `Pallet::depositor_min_bond`. The caller does not have nominating
       * permissions for the pool. Members can never unbond to a value below `MinJoinBond`.
       */
      export function MinimumBondNotMet(): pallet_nomination_pools.pallet.Error.MinimumBondNotMet {
        return { type: "MinimumBondNotMet" }
      }
      /**
       * The amount does not meet the minimum bond to either join or create a pool.
       *
       * The depositor can never unbond to a value less than
       * `Pallet::depositor_min_bond`. The caller does not have nominating
       * permissions for the pool. Members can never unbond to a value below `MinJoinBond`.
       */
      export interface MinimumBondNotMet {
        type: "MinimumBondNotMet"
      }
      /**
       * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
       * other members to be permissionlessly unbonded.
       */
      export function NotDestroying(): pallet_nomination_pools.pallet.Error.NotDestroying {
        return { type: "NotDestroying" }
      }
      /**
       * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
       * other members to be permissionlessly unbonded.
       */
      export interface NotDestroying {
        type: "NotDestroying"
      }
      /** Either a) the caller cannot make a valid kick or b) the pool is not destroying. */
      export function NotKickerOrDestroying(): pallet_nomination_pools.pallet.Error.NotKickerOrDestroying {
        return { type: "NotKickerOrDestroying" }
      }
      /** Either a) the caller cannot make a valid kick or b) the pool is not destroying. */
      export interface NotKickerOrDestroying {
        type: "NotKickerOrDestroying"
      }
      /** The caller does not have nominating permissions for the pool. */
      export function NotNominator(): pallet_nomination_pools.pallet.Error.NotNominator {
        return { type: "NotNominator" }
      }
      /** The caller does not have nominating permissions for the pool. */
      export interface NotNominator {
        type: "NotNominator"
      }
      /** The pool is not open to join */
      export function NotOpen(): pallet_nomination_pools.pallet.Error.NotOpen {
        return { type: "NotOpen" }
      }
      /** The pool is not open to join */
      export interface NotOpen {
        type: "NotOpen"
      }
      /** The transaction could not be executed due to overflow risk for the pool. */
      export function OverflowRisk(): pallet_nomination_pools.pallet.Error.OverflowRisk {
        return { type: "OverflowRisk" }
      }
      /** The transaction could not be executed due to overflow risk for the pool. */
      export interface OverflowRisk {
        type: "OverflowRisk"
      }
      /** Partial unbonding now allowed permissionlessly. */
      export function PartialUnbondNotAllowedPermissionlessly(): pallet_nomination_pools.pallet.Error.PartialUnbondNotAllowedPermissionlessly {
        return { type: "PartialUnbondNotAllowedPermissionlessly" }
      }
      /** Partial unbonding now allowed permissionlessly. */
      export interface PartialUnbondNotAllowedPermissionlessly {
        type: "PartialUnbondNotAllowedPermissionlessly"
      }
      /** An account is not a member. */
      export function PoolMemberNotFound(): pallet_nomination_pools.pallet.Error.PoolMemberNotFound {
        return { type: "PoolMemberNotFound" }
      }
      /** An account is not a member. */
      export interface PoolMemberNotFound {
        type: "PoolMemberNotFound"
      }
      /** A (bonded) pool id does not exist. */
      export function PoolNotFound(): pallet_nomination_pools.pallet.Error.PoolNotFound {
        return { type: "PoolNotFound" }
      }
      /** A (bonded) pool id does not exist. */
      export interface PoolNotFound {
        type: "PoolNotFound"
      }
      /** A reward pool does not exist. In all cases this is a system logic error. */
      export function RewardPoolNotFound(): pallet_nomination_pools.pallet.Error.RewardPoolNotFound {
        return { type: "RewardPoolNotFound" }
      }
      /** A reward pool does not exist. In all cases this is a system logic error. */
      export interface RewardPoolNotFound {
        type: "RewardPoolNotFound"
      }
      /** A sub pool does not exist. */
      export function SubPoolsNotFound(): pallet_nomination_pools.pallet.Error.SubPoolsNotFound {
        return { type: "SubPoolsNotFound" }
      }
      /** A sub pool does not exist. */
      export interface SubPoolsNotFound {
        type: "SubPoolsNotFound"
      }
    }
    /** Events of this pallet. */
    export type Event =
      | pallet_nomination_pools.pallet.Event.Created
      | pallet_nomination_pools.pallet.Event.Bonded
      | pallet_nomination_pools.pallet.Event.PaidOut
      | pallet_nomination_pools.pallet.Event.Unbonded
      | pallet_nomination_pools.pallet.Event.Withdrawn
      | pallet_nomination_pools.pallet.Event.Destroyed
      | pallet_nomination_pools.pallet.Event.StateChanged
      | pallet_nomination_pools.pallet.Event.MemberRemoved
      | pallet_nomination_pools.pallet.Event.RolesUpdated
      | pallet_nomination_pools.pallet.Event.PoolSlashed
      | pallet_nomination_pools.pallet.Event.UnbondingPoolSlashed
    export namespace Event {
      /** A member has became bonded in a pool. */
      export function Bonded(
        value: Omit<pallet_nomination_pools.pallet.Event.Bonded, "type">,
      ): pallet_nomination_pools.pallet.Event.Bonded {
        return { type: "Bonded", ...value }
      }
      /** A member has became bonded in a pool. */
      export interface Bonded {
        type: "Bonded"
        member: sp_core.crypto.AccountId32
        pool_id: u32
        bonded: u128
        joined: boolean
      }
      /** A pool has been created. */
      export function Created(
        value: Omit<pallet_nomination_pools.pallet.Event.Created, "type">,
      ): pallet_nomination_pools.pallet.Event.Created {
        return { type: "Created", ...value }
      }
      /** A pool has been created. */
      export interface Created {
        type: "Created"
        depositor: sp_core.crypto.AccountId32
        pool_id: u32
      }
      /** A pool has been destroyed. */
      export function Destroyed(
        value: Omit<pallet_nomination_pools.pallet.Event.Destroyed, "type">,
      ): pallet_nomination_pools.pallet.Event.Destroyed {
        return { type: "Destroyed", ...value }
      }
      /** A pool has been destroyed. */
      export interface Destroyed {
        type: "Destroyed"
        pool_id: u32
      }
      /**
       * A member has been removed from a pool.
       *
       * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
       */
      export function MemberRemoved(
        value: Omit<pallet_nomination_pools.pallet.Event.MemberRemoved, "type">,
      ): pallet_nomination_pools.pallet.Event.MemberRemoved {
        return { type: "MemberRemoved", ...value }
      }
      /**
       * A member has been removed from a pool.
       *
       * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
       */
      export interface MemberRemoved {
        type: "MemberRemoved"
        pool_id: u32
        member: sp_core.crypto.AccountId32
      }
      /** A payout has been made to a member. */
      export function PaidOut(
        value: Omit<pallet_nomination_pools.pallet.Event.PaidOut, "type">,
      ): pallet_nomination_pools.pallet.Event.PaidOut {
        return { type: "PaidOut", ...value }
      }
      /** A payout has been made to a member. */
      export interface PaidOut {
        type: "PaidOut"
        member: sp_core.crypto.AccountId32
        pool_id: u32
        payout: u128
      }
      /** The active balance of pool `pool_id` has been slashed to `balance`. */
      export function PoolSlashed(
        value: Omit<pallet_nomination_pools.pallet.Event.PoolSlashed, "type">,
      ): pallet_nomination_pools.pallet.Event.PoolSlashed {
        return { type: "PoolSlashed", ...value }
      }
      /** The active balance of pool `pool_id` has been slashed to `balance`. */
      export interface PoolSlashed {
        type: "PoolSlashed"
        pool_id: u32
        balance: u128
      }
      /**
       * The roles of a pool have been updated to the given new roles. Note that the depositor
       * can never change.
       */
      export function RolesUpdated(
        value: Omit<pallet_nomination_pools.pallet.Event.RolesUpdated, "type">,
      ): pallet_nomination_pools.pallet.Event.RolesUpdated {
        return { type: "RolesUpdated", ...value }
      }
      /**
       * The roles of a pool have been updated to the given new roles. Note that the depositor
       * can never change.
       */
      export interface RolesUpdated {
        type: "RolesUpdated"
        root: sp_core.crypto.AccountId32 | undefined
        state_toggler: sp_core.crypto.AccountId32 | undefined
        nominator: sp_core.crypto.AccountId32 | undefined
      }
      /** The state of a pool has changed */
      export function StateChanged(
        value: Omit<pallet_nomination_pools.pallet.Event.StateChanged, "type">,
      ): pallet_nomination_pools.pallet.Event.StateChanged {
        return { type: "StateChanged", ...value }
      }
      /** The state of a pool has changed */
      export interface StateChanged {
        type: "StateChanged"
        pool_id: u32
        new_state: pallet_nomination_pools.PoolState
      }
      /**
       * A member has unbonded from their pool.
       *
       * - `balance` is the corresponding balance of the number of points that has been
       *   requested to be unbonded (the argument of the `unbond` transaction) from the bonded
       *   pool.
       * - `points` is the number of points that are issued as a result of `balance` being
       * dissolved into the corresponding unbonding pool.
       * - `era` is the era in which the balance will be unbonded.
       * In the absence of slashing, these values will match. In the presence of slashing, the
       * number of points that are issued in the unbonding pool will be less than the amount
       * requested to be unbonded.
       */
      export function Unbonded(
        value: Omit<pallet_nomination_pools.pallet.Event.Unbonded, "type">,
      ): pallet_nomination_pools.pallet.Event.Unbonded {
        return { type: "Unbonded", ...value }
      }
      /**
       * A member has unbonded from their pool.
       *
       * - `balance` is the corresponding balance of the number of points that has been
       *   requested to be unbonded (the argument of the `unbond` transaction) from the bonded
       *   pool.
       * - `points` is the number of points that are issued as a result of `balance` being
       * dissolved into the corresponding unbonding pool.
       * - `era` is the era in which the balance will be unbonded.
       * In the absence of slashing, these values will match. In the presence of slashing, the
       * number of points that are issued in the unbonding pool will be less than the amount
       * requested to be unbonded.
       */
      export interface Unbonded {
        type: "Unbonded"
        member: sp_core.crypto.AccountId32
        pool_id: u32
        balance: u128
        points: u128
        era: u32
      }
      /** The unbond pool at `era` of pool `pool_id` has been slashed to `balance`. */
      export function UnbondingPoolSlashed(
        value: Omit<pallet_nomination_pools.pallet.Event.UnbondingPoolSlashed, "type">,
      ): pallet_nomination_pools.pallet.Event.UnbondingPoolSlashed {
        return { type: "UnbondingPoolSlashed", ...value }
      }
      /** The unbond pool at `era` of pool `pool_id` has been slashed to `balance`. */
      export interface UnbondingPoolSlashed {
        type: "UnbondingPoolSlashed"
        pool_id: u32
        era: u32
        balance: u128
      }
      /**
       * A member has withdrawn from their pool.
       *
       * The given number of `points` have been dissolved in return of `balance`.
       *
       * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
       * will be 1.
       */
      export function Withdrawn(
        value: Omit<pallet_nomination_pools.pallet.Event.Withdrawn, "type">,
      ): pallet_nomination_pools.pallet.Event.Withdrawn {
        return { type: "Withdrawn", ...value }
      }
      /**
       * A member has withdrawn from their pool.
       *
       * The given number of `points` have been dissolved in return of `balance`.
       *
       * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
       * will be 1.
       */
      export interface Withdrawn {
        type: "Withdrawn"
        member: sp_core.crypto.AccountId32
        pool_id: u32
        balance: u128
        points: u128
      }
    }
  }
}
export namespace pallet_offences {
  export namespace pallet {
    export const $event: $.Codec<pallet_offences.pallet.Event> = _codec.$44
    /** Events type. */
    export type Event = pallet_offences.pallet.Event.Offence
    export namespace Event {
      /**
       * There is an offence reported of the given `kind` happened at the `session_index` and
       * (kind-specific) time slot. This event is not deposited for duplicate slashes.
       * \[kind, timeslot\].
       */
      export function Offence(
        value: Omit<pallet_offences.pallet.Event.Offence, "type">,
      ): pallet_offences.pallet.Event.Offence {
        return { type: "Offence", ...value }
      }
      /**
       * There is an offence reported of the given `kind` happened at the `session_index` and
       * (kind-specific) time slot. This event is not deposited for duplicate slashes.
       * \[kind, timeslot\].
       */
      export interface Offence {
        type: "Offence"
        kind: Uint8Array
        timeslot: Uint8Array
      }
    }
  }
}
export namespace pallet_preimage {
  export const $requestStatus: $.Codec<pallet_preimage.RequestStatus> = _codec.$451
  export type RequestStatus =
    | pallet_preimage.RequestStatus.Unrequested
    | pallet_preimage.RequestStatus.Requested
  export namespace RequestStatus {
    export function Requested(
      value: Omit<pallet_preimage.RequestStatus.Requested, "type">,
    ): pallet_preimage.RequestStatus.Requested {
      return { type: "Requested", ...value }
    }
    export interface Requested {
      type: "Requested"
      deposit: [sp_core.crypto.AccountId32, u128] | undefined
      count: u32
      len: u32 | undefined
    }
    export function Unrequested(
      value: Omit<pallet_preimage.RequestStatus.Unrequested, "type">,
    ): pallet_preimage.RequestStatus.Unrequested {
      return { type: "Unrequested", ...value }
    }
    export interface Unrequested {
      type: "Unrequested"
      deposit: [sp_core.crypto.AccountId32, u128]
      len: u32
    }
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_preimage.pallet.Call> = _codec.$184
    export const $error: $.Codec<pallet_preimage.pallet.Error> = _codec.$455
    export const $event: $.Codec<pallet_preimage.pallet.Event> = _codec.$34
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_preimage.pallet.Call.note_preimage
      | pallet_preimage.pallet.Call.unnote_preimage
      | pallet_preimage.pallet.Call.request_preimage
      | pallet_preimage.pallet.Call.unrequest_preimage
    export namespace Call {
      /**
       * Register a preimage on-chain.
       *
       * If the preimage was previously requested, no fees or deposits are taken for providing
       * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
       */
      export function note_preimage(
        value: Omit<pallet_preimage.pallet.Call.note_preimage, "type">,
      ): pallet_preimage.pallet.Call.note_preimage {
        return { type: "note_preimage", ...value }
      }
      /**
       * Register a preimage on-chain.
       *
       * If the preimage was previously requested, no fees or deposits are taken for providing
       * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
       */
      export interface note_preimage {
        type: "note_preimage"
        bytes: Uint8Array
      }
      /**
       * Request a preimage be uploaded to the chain without paying any fees or deposits.
       *
       * If the preimage requests has already been provided on-chain, we unreserve any deposit
       * a user may have paid, and take the control of the preimage out of their hands.
       */
      export function request_preimage(
        value: Omit<pallet_preimage.pallet.Call.request_preimage, "type">,
      ): pallet_preimage.pallet.Call.request_preimage {
        return { type: "request_preimage", ...value }
      }
      /**
       * Request a preimage be uploaded to the chain without paying any fees or deposits.
       *
       * If the preimage requests has already been provided on-chain, we unreserve any deposit
       * a user may have paid, and take the control of the preimage out of their hands.
       */
      export interface request_preimage {
        type: "request_preimage"
        hash: primitive_types.H256
      }
      /**
       * Clear an unrequested preimage from the runtime storage.
       *
       * If `len` is provided, then it will be a much cheaper operation.
       *
       * - `hash`: The hash of the preimage to be removed from the store.
       * - `len`: The length of the preimage of `hash`.
       */
      export function unnote_preimage(
        value: Omit<pallet_preimage.pallet.Call.unnote_preimage, "type">,
      ): pallet_preimage.pallet.Call.unnote_preimage {
        return { type: "unnote_preimage", ...value }
      }
      /**
       * Clear an unrequested preimage from the runtime storage.
       *
       * If `len` is provided, then it will be a much cheaper operation.
       *
       * - `hash`: The hash of the preimage to be removed from the store.
       * - `len`: The length of the preimage of `hash`.
       */
      export interface unnote_preimage {
        type: "unnote_preimage"
        hash: primitive_types.H256
      }
      /**
       * Clear a previously made request for a preimage.
       *
       * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
       */
      export function unrequest_preimage(
        value: Omit<pallet_preimage.pallet.Call.unrequest_preimage, "type">,
      ): pallet_preimage.pallet.Call.unrequest_preimage {
        return { type: "unrequest_preimage", ...value }
      }
      /**
       * Clear a previously made request for a preimage.
       *
       * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
       */
      export interface unrequest_preimage {
        type: "unrequest_preimage"
        hash: primitive_types.H256
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "TooBig"
      | "AlreadyNoted"
      | "NotAuthorized"
      | "NotNoted"
      | "Requested"
      | "NotRequested"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_preimage.pallet.Event.Noted
      | pallet_preimage.pallet.Event.Requested
      | pallet_preimage.pallet.Event.Cleared
    export namespace Event {
      /** A preimage has ben cleared. */
      export function Cleared(
        value: Omit<pallet_preimage.pallet.Event.Cleared, "type">,
      ): pallet_preimage.pallet.Event.Cleared {
        return { type: "Cleared", ...value }
      }
      /** A preimage has ben cleared. */
      export interface Cleared {
        type: "Cleared"
        hash: primitive_types.H256
      }
      /** A preimage has been noted. */
      export function Noted(
        value: Omit<pallet_preimage.pallet.Event.Noted, "type">,
      ): pallet_preimage.pallet.Event.Noted {
        return { type: "Noted", ...value }
      }
      /** A preimage has been noted. */
      export interface Noted {
        type: "Noted"
        hash: primitive_types.H256
      }
      /** A preimage has been requested. */
      export function Requested(
        value: Omit<pallet_preimage.pallet.Event.Requested, "type">,
      ): pallet_preimage.pallet.Event.Requested {
        return { type: "Requested", ...value }
      }
      /** A preimage has been requested. */
      export interface Requested {
        type: "Requested"
        hash: primitive_types.H256
      }
    }
  }
}
export namespace pallet_proxy {
  export const $announcement: $.Codec<pallet_proxy.Announcement> = _codec.$585
  export const $proxyDefinition: $.Codec<pallet_proxy.ProxyDefinition> = _codec.$581
  export interface Announcement {
    real: sp_core.crypto.AccountId32
    call_hash: primitive_types.H256
    height: u32
  }
  export function Announcement(value: pallet_proxy.Announcement) {
    return value
  }
  export interface ProxyDefinition {
    delegate: sp_core.crypto.AccountId32
    proxy_type: polkadot_runtime.ProxyType
    delay: u32
  }
  export function ProxyDefinition(value: pallet_proxy.ProxyDefinition) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_proxy.pallet.Call> = _codec.$303
    export const $error: $.Codec<pallet_proxy.pallet.Error> = _codec.$587
    export const $event: $.Codec<pallet_proxy.pallet.Event> = _codec.$78
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_proxy.pallet.Call.proxy
      | pallet_proxy.pallet.Call.add_proxy
      | pallet_proxy.pallet.Call.remove_proxy
      | pallet_proxy.pallet.Call.remove_proxies
      | pallet_proxy.pallet.Call.create_pure
      | pallet_proxy.pallet.Call.kill_pure
      | pallet_proxy.pallet.Call.announce
      | pallet_proxy.pallet.Call.remove_announcement
      | pallet_proxy.pallet.Call.reject_announcement
      | pallet_proxy.pallet.Call.proxy_announced
    export namespace Call {
      /**
       * Register a proxy account for the sender that is able to make calls on its behalf.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `proxy`: The account that the `caller` would like to make a proxy.
       * - `proxy_type`: The permissions allowed for this proxy account.
       * - `delay`: The announcement period required of the initial proxy. Will generally be
       * zero.
       */
      export function add_proxy(
        value: Omit<pallet_proxy.pallet.Call.add_proxy, "type">,
      ): pallet_proxy.pallet.Call.add_proxy {
        return { type: "add_proxy", ...value }
      }
      /**
       * Register a proxy account for the sender that is able to make calls on its behalf.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `proxy`: The account that the `caller` would like to make a proxy.
       * - `proxy_type`: The permissions allowed for this proxy account.
       * - `delay`: The announcement period required of the initial proxy. Will generally be
       * zero.
       */
      export interface add_proxy {
        type: "add_proxy"
        delegate: sp_runtime.multiaddress.MultiAddress
        proxy_type: polkadot_runtime.ProxyType
        delay: u32
      }
      /**
       * Publish the hash of a proxy-call that will be made in the future.
       *
       * This must be called some number of blocks before the corresponding `proxy` is attempted
       * if the delay associated with the proxy relationship is greater than zero.
       *
       * No more than `MaxPending` announcements may be made at any one time.
       *
       * This will take a deposit of `AnnouncementDepositFactor` as well as
       * `AnnouncementDepositBase` if there are no other pending announcements.
       *
       * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `call_hash`: The hash of the call to be made by the `real` account.
       */
      export function announce(
        value: Omit<pallet_proxy.pallet.Call.announce, "type">,
      ): pallet_proxy.pallet.Call.announce {
        return { type: "announce", ...value }
      }
      /**
       * Publish the hash of a proxy-call that will be made in the future.
       *
       * This must be called some number of blocks before the corresponding `proxy` is attempted
       * if the delay associated with the proxy relationship is greater than zero.
       *
       * No more than `MaxPending` announcements may be made at any one time.
       *
       * This will take a deposit of `AnnouncementDepositFactor` as well as
       * `AnnouncementDepositBase` if there are no other pending announcements.
       *
       * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `call_hash`: The hash of the call to be made by the `real` account.
       */
      export interface announce {
        type: "announce"
        real: sp_runtime.multiaddress.MultiAddress
        call_hash: primitive_types.H256
      }
      /**
       * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
       * initialize it with a proxy of `proxy_type` for `origin` sender.
       *
       * Requires a `Signed` origin.
       *
       * - `proxy_type`: The type of the proxy that the sender will be registered as over the
       * new account. This will almost always be the most permissive `ProxyType` possible to
       * allow for maximum flexibility.
       * - `index`: A disambiguation index, in case this is called multiple times in the same
       * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
       * want to use `0`.
       * - `delay`: The announcement period required of the initial proxy. Will generally be
       * zero.
       *
       * Fails with `Duplicate` if this has already been called in this transaction, from the
       * same sender, with the same parameters.
       *
       * Fails if there are insufficient funds to pay for deposit.
       */
      export function create_pure(
        value: Omit<pallet_proxy.pallet.Call.create_pure, "type">,
      ): pallet_proxy.pallet.Call.create_pure {
        return { type: "create_pure", ...value }
      }
      /**
       * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
       * initialize it with a proxy of `proxy_type` for `origin` sender.
       *
       * Requires a `Signed` origin.
       *
       * - `proxy_type`: The type of the proxy that the sender will be registered as over the
       * new account. This will almost always be the most permissive `ProxyType` possible to
       * allow for maximum flexibility.
       * - `index`: A disambiguation index, in case this is called multiple times in the same
       * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
       * want to use `0`.
       * - `delay`: The announcement period required of the initial proxy. Will generally be
       * zero.
       *
       * Fails with `Duplicate` if this has already been called in this transaction, from the
       * same sender, with the same parameters.
       *
       * Fails if there are insufficient funds to pay for deposit.
       */
      export interface create_pure {
        type: "create_pure"
        proxy_type: polkadot_runtime.ProxyType
        delay: u32
        index: u16
      }
      /**
       * Removes a previously spawned pure proxy.
       *
       * WARNING: **All access to this account will be lost.** Any funds held in it will be
       * inaccessible.
       *
       * Requires a `Signed` origin, and the sender account must have been created by a call to
       * `pure` with corresponding parameters.
       *
       * - `spawner`: The account that originally called `pure` to create this account.
       * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
       * - `proxy_type`: The proxy type originally passed to `pure`.
       * - `height`: The height of the chain when the call to `pure` was processed.
       * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
       *
       * Fails with `NoPermission` in case the caller is not a previously created pure
       * account whose `pure` call has corresponding parameters.
       */
      export function kill_pure(
        value: Omit<pallet_proxy.pallet.Call.kill_pure, "type">,
      ): pallet_proxy.pallet.Call.kill_pure {
        return { type: "kill_pure", ...value }
      }
      /**
       * Removes a previously spawned pure proxy.
       *
       * WARNING: **All access to this account will be lost.** Any funds held in it will be
       * inaccessible.
       *
       * Requires a `Signed` origin, and the sender account must have been created by a call to
       * `pure` with corresponding parameters.
       *
       * - `spawner`: The account that originally called `pure` to create this account.
       * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
       * - `proxy_type`: The proxy type originally passed to `pure`.
       * - `height`: The height of the chain when the call to `pure` was processed.
       * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
       *
       * Fails with `NoPermission` in case the caller is not a previously created pure
       * account whose `pure` call has corresponding parameters.
       */
      export interface kill_pure {
        type: "kill_pure"
        spawner: sp_runtime.multiaddress.MultiAddress
        proxy_type: polkadot_runtime.ProxyType
        index: u16
        height: Compact<u32>
        ext_index: Compact<u32>
      }
      /**
       * Dispatch the given `call` from an account that the sender is authorised for through
       * `add_proxy`.
       *
       * Removes any corresponding announcement(s).
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
       * - `call`: The call to be made by the `real` account.
       */
      export function proxy(
        value: Omit<pallet_proxy.pallet.Call.proxy, "type">,
      ): pallet_proxy.pallet.Call.proxy {
        return { type: "proxy", ...value }
      }
      /**
       * Dispatch the given `call` from an account that the sender is authorised for through
       * `add_proxy`.
       *
       * Removes any corresponding announcement(s).
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
       * - `call`: The call to be made by the `real` account.
       */
      export interface proxy {
        type: "proxy"
        real: sp_runtime.multiaddress.MultiAddress
        force_proxy_type: polkadot_runtime.ProxyType | undefined
        call: polkadot_runtime.RuntimeCall
      }
      /**
       * Dispatch the given `call` from an account that the sender is authorized for through
       * `add_proxy`.
       *
       * Removes any corresponding announcement(s).
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
       * - `call`: The call to be made by the `real` account.
       */
      export function proxy_announced(
        value: Omit<pallet_proxy.pallet.Call.proxy_announced, "type">,
      ): pallet_proxy.pallet.Call.proxy_announced {
        return { type: "proxy_announced", ...value }
      }
      /**
       * Dispatch the given `call` from an account that the sender is authorized for through
       * `add_proxy`.
       *
       * Removes any corresponding announcement(s).
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
       * - `call`: The call to be made by the `real` account.
       */
      export interface proxy_announced {
        type: "proxy_announced"
        delegate: sp_runtime.multiaddress.MultiAddress
        real: sp_runtime.multiaddress.MultiAddress
        force_proxy_type: polkadot_runtime.ProxyType | undefined
        call: polkadot_runtime.RuntimeCall
      }
      /**
       * Remove the given announcement of a delegate.
       *
       * May be called by a target (proxied) account to remove a call that one of their delegates
       * (`delegate`) has announced they want to execute. The deposit is returned.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `delegate`: The account that previously announced the call.
       * - `call_hash`: The hash of the call to be made.
       */
      export function reject_announcement(
        value: Omit<pallet_proxy.pallet.Call.reject_announcement, "type">,
      ): pallet_proxy.pallet.Call.reject_announcement {
        return { type: "reject_announcement", ...value }
      }
      /**
       * Remove the given announcement of a delegate.
       *
       * May be called by a target (proxied) account to remove a call that one of their delegates
       * (`delegate`) has announced they want to execute. The deposit is returned.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `delegate`: The account that previously announced the call.
       * - `call_hash`: The hash of the call to be made.
       */
      export interface reject_announcement {
        type: "reject_announcement"
        delegate: sp_runtime.multiaddress.MultiAddress
        call_hash: primitive_types.H256
      }
      /**
       * Remove a given announcement.
       *
       * May be called by a proxy account to remove a call they previously announced and return
       * the deposit.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `call_hash`: The hash of the call to be made by the `real` account.
       */
      export function remove_announcement(
        value: Omit<pallet_proxy.pallet.Call.remove_announcement, "type">,
      ): pallet_proxy.pallet.Call.remove_announcement {
        return { type: "remove_announcement", ...value }
      }
      /**
       * Remove a given announcement.
       *
       * May be called by a proxy account to remove a call they previously announced and return
       * the deposit.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `real`: The account that the proxy will make a call on behalf of.
       * - `call_hash`: The hash of the call to be made by the `real` account.
       */
      export interface remove_announcement {
        type: "remove_announcement"
        real: sp_runtime.multiaddress.MultiAddress
        call_hash: primitive_types.H256
      }
      /**
       * Unregister all proxy accounts for the sender.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * WARNING: This may be called on accounts created by `pure`, however if done, then
       * the unreserved fees will be inaccessible. **All access to this account will be lost.**
       */
      export function remove_proxies(): pallet_proxy.pallet.Call.remove_proxies {
        return { type: "remove_proxies" }
      }
      /**
       * Unregister all proxy accounts for the sender.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * WARNING: This may be called on accounts created by `pure`, however if done, then
       * the unreserved fees will be inaccessible. **All access to this account will be lost.**
       */
      export interface remove_proxies {
        type: "remove_proxies"
      }
      /**
       * Unregister a proxy account for the sender.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `proxy`: The account that the `caller` would like to remove as a proxy.
       * - `proxy_type`: The permissions currently enabled for the removed proxy account.
       */
      export function remove_proxy(
        value: Omit<pallet_proxy.pallet.Call.remove_proxy, "type">,
      ): pallet_proxy.pallet.Call.remove_proxy {
        return { type: "remove_proxy", ...value }
      }
      /**
       * Unregister a proxy account for the sender.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Parameters:
       * - `proxy`: The account that the `caller` would like to remove as a proxy.
       * - `proxy_type`: The permissions currently enabled for the removed proxy account.
       */
      export interface remove_proxy {
        type: "remove_proxy"
        delegate: sp_runtime.multiaddress.MultiAddress
        proxy_type: polkadot_runtime.ProxyType
        delay: u32
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "TooMany"
      | "NotFound"
      | "NotProxy"
      | "Unproxyable"
      | "Duplicate"
      | "NoPermission"
      | "Unannounced"
      | "NoSelfProxy"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_proxy.pallet.Event.ProxyExecuted
      | pallet_proxy.pallet.Event.PureCreated
      | pallet_proxy.pallet.Event.Announced
      | pallet_proxy.pallet.Event.ProxyAdded
      | pallet_proxy.pallet.Event.ProxyRemoved
    export namespace Event {
      /** An announcement was placed to make a call in the future. */
      export function Announced(
        value: Omit<pallet_proxy.pallet.Event.Announced, "type">,
      ): pallet_proxy.pallet.Event.Announced {
        return { type: "Announced", ...value }
      }
      /** An announcement was placed to make a call in the future. */
      export interface Announced {
        type: "Announced"
        real: sp_core.crypto.AccountId32
        proxy: sp_core.crypto.AccountId32
        call_hash: primitive_types.H256
      }
      /** A proxy was added. */
      export function ProxyAdded(
        value: Omit<pallet_proxy.pallet.Event.ProxyAdded, "type">,
      ): pallet_proxy.pallet.Event.ProxyAdded {
        return { type: "ProxyAdded", ...value }
      }
      /** A proxy was added. */
      export interface ProxyAdded {
        type: "ProxyAdded"
        delegator: sp_core.crypto.AccountId32
        delegatee: sp_core.crypto.AccountId32
        proxy_type: polkadot_runtime.ProxyType
        delay: u32
      }
      /** A proxy was executed correctly, with the given. */
      export function ProxyExecuted(
        value: Omit<pallet_proxy.pallet.Event.ProxyExecuted, "type">,
      ): pallet_proxy.pallet.Event.ProxyExecuted {
        return { type: "ProxyExecuted", ...value }
      }
      /** A proxy was executed correctly, with the given. */
      export interface ProxyExecuted {
        type: "ProxyExecuted"
        result: null | ChainError<sp_runtime.DispatchError>
      }
      /** A proxy was removed. */
      export function ProxyRemoved(
        value: Omit<pallet_proxy.pallet.Event.ProxyRemoved, "type">,
      ): pallet_proxy.pallet.Event.ProxyRemoved {
        return { type: "ProxyRemoved", ...value }
      }
      /** A proxy was removed. */
      export interface ProxyRemoved {
        type: "ProxyRemoved"
        delegator: sp_core.crypto.AccountId32
        delegatee: sp_core.crypto.AccountId32
        proxy_type: polkadot_runtime.ProxyType
        delay: u32
      }
      /**
       * A pure account has been created by new proxy with given
       * disambiguation index and proxy type.
       */
      export function PureCreated(
        value: Omit<pallet_proxy.pallet.Event.PureCreated, "type">,
      ): pallet_proxy.pallet.Event.PureCreated {
        return { type: "PureCreated", ...value }
      }
      /**
       * A pure account has been created by new proxy with given
       * disambiguation index and proxy type.
       */
      export interface PureCreated {
        type: "PureCreated"
        pure: sp_core.crypto.AccountId32
        who: sp_core.crypto.AccountId32
        proxy_type: polkadot_runtime.ProxyType
        disambiguation_index: u16
      }
    }
  }
}
export namespace pallet_scheduler {
  export const $scheduled: $.Codec<pallet_scheduler.Scheduled> = _codec.$179
  export interface Scheduled {
    maybe_id: Uint8Array | undefined
    priority: u8
    call: frame_support.traits.preimages.Bounded
    maybe_periodic: [u32, u32] | undefined
    origin: polkadot_runtime.OriginCaller
  }
  export function Scheduled(value: pallet_scheduler.Scheduled) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_scheduler.pallet.Call> = _codec.$182
    export const $error: $.Codec<pallet_scheduler.pallet.Error> = _codec.$450
    export const $event: $.Codec<pallet_scheduler.pallet.Event> = _codec.$29
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_scheduler.pallet.Call.schedule
      | pallet_scheduler.pallet.Call.cancel
      | pallet_scheduler.pallet.Call.schedule_named
      | pallet_scheduler.pallet.Call.cancel_named
      | pallet_scheduler.pallet.Call.schedule_after
      | pallet_scheduler.pallet.Call.schedule_named_after
    export namespace Call {
      /** Cancel an anonymously scheduled task. */
      export function cancel(
        value: Omit<pallet_scheduler.pallet.Call.cancel, "type">,
      ): pallet_scheduler.pallet.Call.cancel {
        return { type: "cancel", ...value }
      }
      /** Cancel an anonymously scheduled task. */
      export interface cancel {
        type: "cancel"
        when: u32
        index: u32
      }
      /** Cancel a named scheduled task. */
      export function cancel_named(
        value: Omit<pallet_scheduler.pallet.Call.cancel_named, "type">,
      ): pallet_scheduler.pallet.Call.cancel_named {
        return { type: "cancel_named", ...value }
      }
      /** Cancel a named scheduled task. */
      export interface cancel_named {
        type: "cancel_named"
        id: Uint8Array
      }
      /** Anonymously schedule a task. */
      export function schedule(
        value: Omit<pallet_scheduler.pallet.Call.schedule, "type">,
      ): pallet_scheduler.pallet.Call.schedule {
        return { type: "schedule", ...value }
      }
      /** Anonymously schedule a task. */
      export interface schedule {
        type: "schedule"
        when: u32
        maybe_periodic: [u32, u32] | undefined
        priority: u8
        call: polkadot_runtime.RuntimeCall
      }
      /**
       * Anonymously schedule a task after a delay.
       *
       * # <weight>
       * Same as [`schedule`].
       * # </weight>
       */
      export function schedule_after(
        value: Omit<pallet_scheduler.pallet.Call.schedule_after, "type">,
      ): pallet_scheduler.pallet.Call.schedule_after {
        return { type: "schedule_after", ...value }
      }
      /**
       * Anonymously schedule a task after a delay.
       *
       * # <weight>
       * Same as [`schedule`].
       * # </weight>
       */
      export interface schedule_after {
        type: "schedule_after"
        after: u32
        maybe_periodic: [u32, u32] | undefined
        priority: u8
        call: polkadot_runtime.RuntimeCall
      }
      /** Schedule a named task. */
      export function schedule_named(
        value: Omit<pallet_scheduler.pallet.Call.schedule_named, "type">,
      ): pallet_scheduler.pallet.Call.schedule_named {
        return { type: "schedule_named", ...value }
      }
      /** Schedule a named task. */
      export interface schedule_named {
        type: "schedule_named"
        id: Uint8Array
        when: u32
        maybe_periodic: [u32, u32] | undefined
        priority: u8
        call: polkadot_runtime.RuntimeCall
      }
      /**
       * Schedule a named task after a delay.
       *
       * # <weight>
       * Same as [`schedule_named`](Self::schedule_named).
       * # </weight>
       */
      export function schedule_named_after(
        value: Omit<pallet_scheduler.pallet.Call.schedule_named_after, "type">,
      ): pallet_scheduler.pallet.Call.schedule_named_after {
        return { type: "schedule_named_after", ...value }
      }
      /**
       * Schedule a named task after a delay.
       *
       * # <weight>
       * Same as [`schedule_named`](Self::schedule_named).
       * # </weight>
       */
      export interface schedule_named_after {
        type: "schedule_named_after"
        id: Uint8Array
        after: u32
        maybe_periodic: [u32, u32] | undefined
        priority: u8
        call: polkadot_runtime.RuntimeCall
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "FailedToSchedule"
      | "NotFound"
      | "TargetBlockNumberInPast"
      | "RescheduleNoChange"
      | "Named"
    /** Events type. */
    export type Event =
      | pallet_scheduler.pallet.Event.Scheduled
      | pallet_scheduler.pallet.Event.Canceled
      | pallet_scheduler.pallet.Event.Dispatched
      | pallet_scheduler.pallet.Event.CallUnavailable
      | pallet_scheduler.pallet.Event.PeriodicFailed
      | pallet_scheduler.pallet.Event.PermanentlyOverweight
    export namespace Event {
      /** The call for the provided hash was not found so the task has been aborted. */
      export function CallUnavailable(
        value: Omit<pallet_scheduler.pallet.Event.CallUnavailable, "type">,
      ): pallet_scheduler.pallet.Event.CallUnavailable {
        return { type: "CallUnavailable", ...value }
      }
      /** The call for the provided hash was not found so the task has been aborted. */
      export interface CallUnavailable {
        type: "CallUnavailable"
        task: [u32, u32]
        id: Uint8Array | undefined
      }
      /** Canceled some task. */
      export function Canceled(
        value: Omit<pallet_scheduler.pallet.Event.Canceled, "type">,
      ): pallet_scheduler.pallet.Event.Canceled {
        return { type: "Canceled", ...value }
      }
      /** Canceled some task. */
      export interface Canceled {
        type: "Canceled"
        when: u32
        index: u32
      }
      /** Dispatched some task. */
      export function Dispatched(
        value: Omit<pallet_scheduler.pallet.Event.Dispatched, "type">,
      ): pallet_scheduler.pallet.Event.Dispatched {
        return { type: "Dispatched", ...value }
      }
      /** Dispatched some task. */
      export interface Dispatched {
        type: "Dispatched"
        task: [u32, u32]
        id: Uint8Array | undefined
        result: null | ChainError<sp_runtime.DispatchError>
      }
      /** The given task was unable to be renewed since the agenda is full at that block. */
      export function PeriodicFailed(
        value: Omit<pallet_scheduler.pallet.Event.PeriodicFailed, "type">,
      ): pallet_scheduler.pallet.Event.PeriodicFailed {
        return { type: "PeriodicFailed", ...value }
      }
      /** The given task was unable to be renewed since the agenda is full at that block. */
      export interface PeriodicFailed {
        type: "PeriodicFailed"
        task: [u32, u32]
        id: Uint8Array | undefined
      }
      /** The given task can never be executed since it is overweight. */
      export function PermanentlyOverweight(
        value: Omit<pallet_scheduler.pallet.Event.PermanentlyOverweight, "type">,
      ): pallet_scheduler.pallet.Event.PermanentlyOverweight {
        return { type: "PermanentlyOverweight", ...value }
      }
      /** The given task can never be executed since it is overweight. */
      export interface PermanentlyOverweight {
        type: "PermanentlyOverweight"
        task: [u32, u32]
        id: Uint8Array | undefined
      }
      /** Scheduled some task. */
      export function Scheduled(
        value: Omit<pallet_scheduler.pallet.Event.Scheduled, "type">,
      ): pallet_scheduler.pallet.Event.Scheduled {
        return { type: "Scheduled", ...value }
      }
      /** Scheduled some task. */
      export interface Scheduled {
        type: "Scheduled"
        when: u32
        index: u32
      }
    }
  }
}
export namespace pallet_session {
  export namespace pallet {
    export const $call: $.Codec<pallet_session.pallet.Call> = _codec.$211
    export const $error: $.Codec<pallet_session.pallet.Error> = _codec.$515
    export const $event: $.Codec<pallet_session.pallet.Event> = _codec.$46
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call = pallet_session.pallet.Call.set_keys | pallet_session.pallet.Call.purge_keys
    export namespace Call {
      /**
       * Removes any session key(s) of the function caller.
       *
       * This doesn't take effect until the next session.
       *
       * The dispatch origin of this function must be Signed and the account must be either be
       * convertible to a validator ID using the chain's typical addressing system (this usually
       * means being a controller account) or directly convertible into a validator ID (which
       * usually means being a stash account).
       *
       * # <weight>
       * - Complexity: `O(1)` in number of key types. Actual cost depends on the number of length
       *   of `T::Keys::key_ids()` which is fixed.
       * - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`
       * - DbWrites: `NextKeys`, `origin account`
       * - DbWrites per key id: `KeyOwner`
       * # </weight>
       */
      export function purge_keys(): pallet_session.pallet.Call.purge_keys {
        return { type: "purge_keys" }
      }
      /**
       * Removes any session key(s) of the function caller.
       *
       * This doesn't take effect until the next session.
       *
       * The dispatch origin of this function must be Signed and the account must be either be
       * convertible to a validator ID using the chain's typical addressing system (this usually
       * means being a controller account) or directly convertible into a validator ID (which
       * usually means being a stash account).
       *
       * # <weight>
       * - Complexity: `O(1)` in number of key types. Actual cost depends on the number of length
       *   of `T::Keys::key_ids()` which is fixed.
       * - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`
       * - DbWrites: `NextKeys`, `origin account`
       * - DbWrites per key id: `KeyOwner`
       * # </weight>
       */
      export interface purge_keys {
        type: "purge_keys"
      }
      /**
       * Sets the session key(s) of the function caller to `keys`.
       * Allows an account to set its session key prior to becoming a validator.
       * This doesn't take effect until the next session.
       *
       * The dispatch origin of this function must be signed.
       *
       * # <weight>
       * - Complexity: `O(1)`. Actual cost depends on the number of length of
       *   `T::Keys::key_ids()` which is fixed.
       * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
       * - DbWrites: `origin account`, `NextKeys`
       * - DbReads per key id: `KeyOwner`
       * - DbWrites per key id: `KeyOwner`
       * # </weight>
       */
      export function set_keys(
        value: Omit<pallet_session.pallet.Call.set_keys, "type">,
      ): pallet_session.pallet.Call.set_keys {
        return { type: "set_keys", ...value }
      }
      /**
       * Sets the session key(s) of the function caller to `keys`.
       * Allows an account to set its session key prior to becoming a validator.
       * This doesn't take effect until the next session.
       *
       * The dispatch origin of this function must be signed.
       *
       * # <weight>
       * - Complexity: `O(1)`. Actual cost depends on the number of length of
       *   `T::Keys::key_ids()` which is fixed.
       * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
       * - DbWrites: `origin account`, `NextKeys`
       * - DbReads per key id: `KeyOwner`
       * - DbWrites per key id: `KeyOwner`
       * # </weight>
       */
      export interface set_keys {
        type: "set_keys"
        keys: polkadot_runtime.SessionKeys
        proof: Uint8Array
      }
    }
    /** Error for the session pallet. */
    export type Error =
      | "InvalidProof"
      | "NoAssociatedValidatorId"
      | "DuplicatedKey"
      | "NoKeys"
      | "NoAccount"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event = pallet_session.pallet.Event.NewSession
    export namespace Event {
      /**
       * New session has happened. Note that the argument is the session index, not the
       * block number as the type might suggest.
       */
      export function NewSession(
        value: Omit<pallet_session.pallet.Event.NewSession, "type">,
      ): pallet_session.pallet.Event.NewSession {
        return { type: "NewSession", ...value }
      }
      /**
       * New session has happened. Note that the argument is the session index, not the
       * block number as the type might suggest.
       */
      export interface NewSession {
        type: "NewSession"
        session_index: u32
      }
    }
  }
}
export namespace pallet_staking {
  export const $activeEraInfo: $.Codec<pallet_staking.ActiveEraInfo> = _codec.$492
  export const $eraRewardPoints: $.Codec<pallet_staking.EraRewardPoints> = _codec.$495
  export const $exposure: $.Codec<pallet_staking.Exposure> = _codec.$57
  export const $forcing: $.Codec<pallet_staking.Forcing> = _codec.$499
  export const $individualExposure: $.Codec<pallet_staking.IndividualExposure> = _codec.$60
  export const $nominations: $.Codec<pallet_staking.Nominations> = _codec.$490
  export const $releases: $.Codec<pallet_staking.Releases> = _codec.$507
  export const $rewardDestination: $.Codec<pallet_staking.RewardDestination> = _codec.$203
  export const $stakingLedger: $.Codec<pallet_staking.StakingLedger> = _codec.$485
  export const $unappliedSlash: $.Codec<pallet_staking.UnappliedSlash> = _codec.$501
  export const $unlockChunk: $.Codec<pallet_staking.UnlockChunk> = _codec.$487
  export const $validatorPrefs: $.Codec<pallet_staking.ValidatorPrefs> = _codec.$40
  export interface ActiveEraInfo {
    index: u32
    start: u64 | undefined
  }
  export function ActiveEraInfo(value: pallet_staking.ActiveEraInfo) {
    return value
  }
  export interface EraRewardPoints {
    total: u32
    individual: Map<sp_core.crypto.AccountId32, u32>
  }
  export function EraRewardPoints(value: pallet_staking.EraRewardPoints) {
    return value
  }
  export interface Exposure {
    total: Compact<u128>
    own: Compact<u128>
    others: Array<pallet_staking.IndividualExposure>
  }
  export function Exposure(value: pallet_staking.Exposure) {
    return value
  }
  export type Forcing = "NotForcing" | "ForceNew" | "ForceNone" | "ForceAlways"
  export interface IndividualExposure {
    who: sp_core.crypto.AccountId32
    value: Compact<u128>
  }
  export function IndividualExposure(value: pallet_staking.IndividualExposure) {
    return value
  }
  export interface Nominations {
    targets: Array<sp_core.crypto.AccountId32>
    submitted_in: u32
    suppressed: boolean
  }
  export function Nominations(value: pallet_staking.Nominations) {
    return value
  }
  export type Releases =
    | "V1_0_0Ancient"
    | "V2_0_0"
    | "V3_0_0"
    | "V4_0_0"
    | "V5_0_0"
    | "V6_0_0"
    | "V7_0_0"
    | "V8_0_0"
    | "V9_0_0"
    | "V10_0_0"
    | "V11_0_0"
    | "V12_0_0"
  export type RewardDestination =
    | pallet_staking.RewardDestination.Staked
    | pallet_staking.RewardDestination.Stash
    | pallet_staking.RewardDestination.Controller
    | pallet_staking.RewardDestination.Account
    | pallet_staking.RewardDestination.None
  export namespace RewardDestination {
    export function Account(
      value: pallet_staking.RewardDestination.Account["value"],
    ): pallet_staking.RewardDestination.Account {
      return { type: "Account", value }
    }
    export interface Account {
      type: "Account"
      value: sp_core.crypto.AccountId32
    }
    export function Controller(): pallet_staking.RewardDestination.Controller {
      return { type: "Controller" }
    }
    export interface Controller {
      type: "Controller"
    }
    export function None(): pallet_staking.RewardDestination.None {
      return { type: "None" }
    }
    export interface None {
      type: "None"
    }
    export function Staked(): pallet_staking.RewardDestination.Staked {
      return { type: "Staked" }
    }
    export interface Staked {
      type: "Staked"
    }
    export function Stash(): pallet_staking.RewardDestination.Stash {
      return { type: "Stash" }
    }
    export interface Stash {
      type: "Stash"
    }
  }
  export interface StakingLedger {
    stash: sp_core.crypto.AccountId32
    total: Compact<u128>
    active: Compact<u128>
    unlocking: Array<pallet_staking.UnlockChunk>
    claimed_rewards: Array<u32>
  }
  export function StakingLedger(value: pallet_staking.StakingLedger) {
    return value
  }
  export interface UnappliedSlash {
    validator: sp_core.crypto.AccountId32
    own: u128
    others: Array<[sp_core.crypto.AccountId32, u128]>
    reporters: Array<sp_core.crypto.AccountId32>
    payout: u128
  }
  export function UnappliedSlash(value: pallet_staking.UnappliedSlash) {
    return value
  }
  export interface UnlockChunk {
    value: Compact<u128>
    era: Compact<u32>
  }
  export function UnlockChunk(value: pallet_staking.UnlockChunk) {
    return value
  }
  export interface ValidatorPrefs {
    commission: Compact<sp_arithmetic.per_things.Perbill>
    blocked: boolean
  }
  export function ValidatorPrefs(value: pallet_staking.ValidatorPrefs) {
    return value
  }
  export namespace pallet {
    export namespace pallet {
      export const $call: $.Codec<pallet_staking.pallet.pallet.Call> = _codec.$202
      export const $error: $.Codec<pallet_staking.pallet.pallet.Error> = _codec.$508
      export const $event: $.Codec<pallet_staking.pallet.pallet.Event> = _codec.$39
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | pallet_staking.pallet.pallet.Call.bond
        | pallet_staking.pallet.pallet.Call.bond_extra
        | pallet_staking.pallet.pallet.Call.unbond
        | pallet_staking.pallet.pallet.Call.withdraw_unbonded
        | pallet_staking.pallet.pallet.Call.validate
        | pallet_staking.pallet.pallet.Call.nominate
        | pallet_staking.pallet.pallet.Call.chill
        | pallet_staking.pallet.pallet.Call.set_payee
        | pallet_staking.pallet.pallet.Call.set_controller
        | pallet_staking.pallet.pallet.Call.set_validator_count
        | pallet_staking.pallet.pallet.Call.increase_validator_count
        | pallet_staking.pallet.pallet.Call.scale_validator_count
        | pallet_staking.pallet.pallet.Call.force_no_eras
        | pallet_staking.pallet.pallet.Call.force_new_era
        | pallet_staking.pallet.pallet.Call.set_invulnerables
        | pallet_staking.pallet.pallet.Call.force_unstake
        | pallet_staking.pallet.pallet.Call.force_new_era_always
        | pallet_staking.pallet.pallet.Call.cancel_deferred_slash
        | pallet_staking.pallet.pallet.Call.payout_stakers
        | pallet_staking.pallet.pallet.Call.rebond
        | pallet_staking.pallet.pallet.Call.reap_stash
        | pallet_staking.pallet.pallet.Call.kick
        | pallet_staking.pallet.pallet.Call.set_staking_configs
        | pallet_staking.pallet.pallet.Call.chill_other
        | pallet_staking.pallet.pallet.Call.force_apply_min_commission
      export namespace Call {
        /**
         * Take the origin account as a stash and lock up `value` of its balance. `controller` will
         * be the account that controls it.
         *
         * `value` must be more than the `minimum_balance` specified by `T::Currency`.
         *
         * The dispatch origin for this call must be _Signed_ by the stash account.
         *
         * Emits `Bonded`.
         * # <weight>
         * - Independent of the arguments. Moderate complexity.
         * - O(1).
         * - Three extra DB entries.
         *
         * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
         * unless the `origin` falls below _existential deposit_ and gets removed as dust.
         * ------------------
         * # </weight>
         */
        export function bond(
          value: Omit<pallet_staking.pallet.pallet.Call.bond, "type">,
        ): pallet_staking.pallet.pallet.Call.bond {
          return { type: "bond", ...value }
        }
        /**
         * Take the origin account as a stash and lock up `value` of its balance. `controller` will
         * be the account that controls it.
         *
         * `value` must be more than the `minimum_balance` specified by `T::Currency`.
         *
         * The dispatch origin for this call must be _Signed_ by the stash account.
         *
         * Emits `Bonded`.
         * # <weight>
         * - Independent of the arguments. Moderate complexity.
         * - O(1).
         * - Three extra DB entries.
         *
         * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
         * unless the `origin` falls below _existential deposit_ and gets removed as dust.
         * ------------------
         * # </weight>
         */
        export interface bond {
          type: "bond"
          controller: sp_runtime.multiaddress.MultiAddress
          value: Compact<u128>
          payee: pallet_staking.RewardDestination
        }
        /**
         * Add some extra amount that have appeared in the stash `free_balance` into the balance up
         * for staking.
         *
         * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
         *
         * Use this if there are additional funds in your stash account that you wish to bond.
         * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
         * any limitation on the amount that can be added.
         *
         * Emits `Bonded`.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - O(1).
         * # </weight>
         */
        export function bond_extra(
          value: Omit<pallet_staking.pallet.pallet.Call.bond_extra, "type">,
        ): pallet_staking.pallet.pallet.Call.bond_extra {
          return { type: "bond_extra", ...value }
        }
        /**
         * Add some extra amount that have appeared in the stash `free_balance` into the balance up
         * for staking.
         *
         * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
         *
         * Use this if there are additional funds in your stash account that you wish to bond.
         * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
         * any limitation on the amount that can be added.
         *
         * Emits `Bonded`.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - O(1).
         * # </weight>
         */
        export interface bond_extra {
          type: "bond_extra"
          max_additional: Compact<u128>
        }
        /**
         * Cancel enactment of a deferred slash.
         *
         * Can be called by the `T::SlashCancelOrigin`.
         *
         * Parameters: era and indices of the slashes for that era to kill.
         */
        export function cancel_deferred_slash(
          value: Omit<pallet_staking.pallet.pallet.Call.cancel_deferred_slash, "type">,
        ): pallet_staking.pallet.pallet.Call.cancel_deferred_slash {
          return { type: "cancel_deferred_slash", ...value }
        }
        /**
         * Cancel enactment of a deferred slash.
         *
         * Can be called by the `T::SlashCancelOrigin`.
         *
         * Parameters: era and indices of the slashes for that era to kill.
         */
        export interface cancel_deferred_slash {
          type: "cancel_deferred_slash"
          era: u32
          slash_indices: Array<u32>
        }
        /**
         * Declare no desire to either validate or nominate.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - Contains one read.
         * - Writes are limited to the `origin` account key.
         * # </weight>
         */
        export function chill(): pallet_staking.pallet.pallet.Call.chill {
          return { type: "chill" }
        }
        /**
         * Declare no desire to either validate or nominate.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - Contains one read.
         * - Writes are limited to the `origin` account key.
         * # </weight>
         */
        export interface chill {
          type: "chill"
        }
        /**
         * Declare a `controller` to stop participating as either a validator or nominator.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_, but can be called by anyone.
         *
         * If the caller is the same as the controller being targeted, then no further checks are
         * enforced, and this function behaves just like `chill`.
         *
         * If the caller is different than the controller being targeted, the following conditions
         * must be met:
         *
         * * `controller` must belong to a nominator who has become non-decodable,
         *
         * Or:
         *
         * * A `ChillThreshold` must be set and checked which defines how close to the max
         *   nominators or validators we must reach before users can start chilling one-another.
         * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
         *   how close we are to the threshold.
         * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
         *   if this is a person that should be chilled because they have not met the threshold
         *   bond required.
         *
         * This can be helpful if bond requirements are updated, and we need to remove old users
         * who do not satisfy these requirements.
         */
        export function chill_other(
          value: Omit<pallet_staking.pallet.pallet.Call.chill_other, "type">,
        ): pallet_staking.pallet.pallet.Call.chill_other {
          return { type: "chill_other", ...value }
        }
        /**
         * Declare a `controller` to stop participating as either a validator or nominator.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_, but can be called by anyone.
         *
         * If the caller is the same as the controller being targeted, then no further checks are
         * enforced, and this function behaves just like `chill`.
         *
         * If the caller is different than the controller being targeted, the following conditions
         * must be met:
         *
         * * `controller` must belong to a nominator who has become non-decodable,
         *
         * Or:
         *
         * * A `ChillThreshold` must be set and checked which defines how close to the max
         *   nominators or validators we must reach before users can start chilling one-another.
         * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
         *   how close we are to the threshold.
         * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
         *   if this is a person that should be chilled because they have not met the threshold
         *   bond required.
         *
         * This can be helpful if bond requirements are updated, and we need to remove old users
         * who do not satisfy these requirements.
         */
        export interface chill_other {
          type: "chill_other"
          controller: sp_core.crypto.AccountId32
        }
        /**
         * Force a validator to have at least the minimum commission. This will not affect a
         * validator who already has a commission greater than or equal to the minimum. Any account
         * can call this.
         */
        export function force_apply_min_commission(
          value: Omit<pallet_staking.pallet.pallet.Call.force_apply_min_commission, "type">,
        ): pallet_staking.pallet.pallet.Call.force_apply_min_commission {
          return { type: "force_apply_min_commission", ...value }
        }
        /**
         * Force a validator to have at least the minimum commission. This will not affect a
         * validator who already has a commission greater than or equal to the minimum. Any account
         * can call this.
         */
        export interface force_apply_min_commission {
          type: "force_apply_min_commission"
          validator_stash: sp_core.crypto.AccountId32
        }
        /**
         * Force there to be a new era at the end of the next session. After this, it will be
         * reset to normal (non-forced) behaviour.
         *
         * The dispatch origin must be Root.
         *
         * # Warning
         *
         * The election process starts multiple blocks before the end of the era.
         * If this is called just before a new era is triggered, the election process may not
         * have enough blocks to get a result.
         *
         * # <weight>
         * - No arguments.
         * - Weight: O(1)
         * - Write ForceEra
         * # </weight>
         */
        export function force_new_era(): pallet_staking.pallet.pallet.Call.force_new_era {
          return { type: "force_new_era" }
        }
        /**
         * Force there to be a new era at the end of the next session. After this, it will be
         * reset to normal (non-forced) behaviour.
         *
         * The dispatch origin must be Root.
         *
         * # Warning
         *
         * The election process starts multiple blocks before the end of the era.
         * If this is called just before a new era is triggered, the election process may not
         * have enough blocks to get a result.
         *
         * # <weight>
         * - No arguments.
         * - Weight: O(1)
         * - Write ForceEra
         * # </weight>
         */
        export interface force_new_era {
          type: "force_new_era"
        }
        /**
         * Force there to be a new era at the end of sessions indefinitely.
         *
         * The dispatch origin must be Root.
         *
         * # Warning
         *
         * The election process starts multiple blocks before the end of the era.
         * If this is called just before a new era is triggered, the election process may not
         * have enough blocks to get a result.
         */
        export function force_new_era_always(): pallet_staking.pallet.pallet.Call.force_new_era_always {
          return { type: "force_new_era_always" }
        }
        /**
         * Force there to be a new era at the end of sessions indefinitely.
         *
         * The dispatch origin must be Root.
         *
         * # Warning
         *
         * The election process starts multiple blocks before the end of the era.
         * If this is called just before a new era is triggered, the election process may not
         * have enough blocks to get a result.
         */
        export interface force_new_era_always {
          type: "force_new_era_always"
        }
        /**
         * Force there to be no new eras indefinitely.
         *
         * The dispatch origin must be Root.
         *
         * # Warning
         *
         * The election process starts multiple blocks before the end of the era.
         * Thus the election process may be ongoing when this is called. In this case the
         * election will continue until the next era is triggered.
         *
         * # <weight>
         * - No arguments.
         * - Weight: O(1)
         * - Write: ForceEra
         * # </weight>
         */
        export function force_no_eras(): pallet_staking.pallet.pallet.Call.force_no_eras {
          return { type: "force_no_eras" }
        }
        /**
         * Force there to be no new eras indefinitely.
         *
         * The dispatch origin must be Root.
         *
         * # Warning
         *
         * The election process starts multiple blocks before the end of the era.
         * Thus the election process may be ongoing when this is called. In this case the
         * election will continue until the next era is triggered.
         *
         * # <weight>
         * - No arguments.
         * - Weight: O(1)
         * - Write: ForceEra
         * # </weight>
         */
        export interface force_no_eras {
          type: "force_no_eras"
        }
        /**
         * Force a current staker to become completely unstaked, immediately.
         *
         * The dispatch origin must be Root.
         */
        export function force_unstake(
          value: Omit<pallet_staking.pallet.pallet.Call.force_unstake, "type">,
        ): pallet_staking.pallet.pallet.Call.force_unstake {
          return { type: "force_unstake", ...value }
        }
        /**
         * Force a current staker to become completely unstaked, immediately.
         *
         * The dispatch origin must be Root.
         */
        export interface force_unstake {
          type: "force_unstake"
          stash: sp_core.crypto.AccountId32
          num_slashing_spans: u32
        }
        /**
         * Increments the ideal number of validators.
         *
         * The dispatch origin must be Root.
         *
         * # <weight>
         * Same as [`Self::set_validator_count`].
         * # </weight>
         */
        export function increase_validator_count(
          value: Omit<pallet_staking.pallet.pallet.Call.increase_validator_count, "type">,
        ): pallet_staking.pallet.pallet.Call.increase_validator_count {
          return { type: "increase_validator_count", ...value }
        }
        /**
         * Increments the ideal number of validators.
         *
         * The dispatch origin must be Root.
         *
         * # <weight>
         * Same as [`Self::set_validator_count`].
         * # </weight>
         */
        export interface increase_validator_count {
          type: "increase_validator_count"
          additional: Compact<u32>
        }
        /**
         * Remove the given nominations from the calling validator.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * - `who`: A list of nominator stash accounts who are nominating this validator which
         *   should no longer be nominating this validator.
         *
         * Note: Making this call only makes sense if you first set the validator preferences to
         * block any further nominations.
         */
        export function kick(
          value: Omit<pallet_staking.pallet.pallet.Call.kick, "type">,
        ): pallet_staking.pallet.pallet.Call.kick {
          return { type: "kick", ...value }
        }
        /**
         * Remove the given nominations from the calling validator.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * - `who`: A list of nominator stash accounts who are nominating this validator which
         *   should no longer be nominating this validator.
         *
         * Note: Making this call only makes sense if you first set the validator preferences to
         * block any further nominations.
         */
        export interface kick {
          type: "kick"
          who: Array<sp_runtime.multiaddress.MultiAddress>
        }
        /**
         * Declare the desire to nominate `targets` for the origin controller.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * # <weight>
         * - The transaction's complexity is proportional to the size of `targets` (N)
         * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
         * - Both the reads and writes follow a similar pattern.
         * # </weight>
         */
        export function nominate(
          value: Omit<pallet_staking.pallet.pallet.Call.nominate, "type">,
        ): pallet_staking.pallet.pallet.Call.nominate {
          return { type: "nominate", ...value }
        }
        /**
         * Declare the desire to nominate `targets` for the origin controller.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * # <weight>
         * - The transaction's complexity is proportional to the size of `targets` (N)
         * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
         * - Both the reads and writes follow a similar pattern.
         * # </weight>
         */
        export interface nominate {
          type: "nominate"
          targets: Array<sp_runtime.multiaddress.MultiAddress>
        }
        /**
         * Pay out all the stakers behind a single validator for a single era.
         *
         * - `validator_stash` is the stash account of the validator. Their nominators, up to
         *   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
         * - `era` may be any era between `[current_era - history_depth; current_era]`.
         *
         * The origin of this call must be _Signed_. Any account can call this function, even if
         * it is not one of the stakers.
         *
         * # <weight>
         * - Time complexity: at most O(MaxNominatorRewardedPerValidator).
         * - Contains a limited number of reads and writes.
         * -----------
         * N is the Number of payouts for the validator (including the validator)
         * Weight:
         * - Reward Destination Staked: O(N)
         * - Reward Destination Controller (Creating): O(N)
         *
         *   NOTE: weights are assuming that payouts are made to alive stash account (Staked).
         *   Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.
         * # </weight>
         */
        export function payout_stakers(
          value: Omit<pallet_staking.pallet.pallet.Call.payout_stakers, "type">,
        ): pallet_staking.pallet.pallet.Call.payout_stakers {
          return { type: "payout_stakers", ...value }
        }
        /**
         * Pay out all the stakers behind a single validator for a single era.
         *
         * - `validator_stash` is the stash account of the validator. Their nominators, up to
         *   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
         * - `era` may be any era between `[current_era - history_depth; current_era]`.
         *
         * The origin of this call must be _Signed_. Any account can call this function, even if
         * it is not one of the stakers.
         *
         * # <weight>
         * - Time complexity: at most O(MaxNominatorRewardedPerValidator).
         * - Contains a limited number of reads and writes.
         * -----------
         * N is the Number of payouts for the validator (including the validator)
         * Weight:
         * - Reward Destination Staked: O(N)
         * - Reward Destination Controller (Creating): O(N)
         *
         *   NOTE: weights are assuming that payouts are made to alive stash account (Staked).
         *   Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.
         * # </weight>
         */
        export interface payout_stakers {
          type: "payout_stakers"
          validator_stash: sp_core.crypto.AccountId32
          era: u32
        }
        /**
         * Remove all data structures concerning a staker/stash once it is at a state where it can
         * be considered `dust` in the staking system. The requirements are:
         *
         * 1. the `total_balance` of the stash is below existential deposit.
         * 2. or, the `ledger.total` of the stash is below existential deposit.
         *
         * The former can happen in cases like a slash; the latter when a fully unbonded account
         * is still receiving staking rewards in `RewardDestination::Staked`.
         *
         * It can be called by anyone, as long as `stash` meets the above requirements.
         *
         * Refunds the transaction fees upon successful execution.
         */
        export function reap_stash(
          value: Omit<pallet_staking.pallet.pallet.Call.reap_stash, "type">,
        ): pallet_staking.pallet.pallet.Call.reap_stash {
          return { type: "reap_stash", ...value }
        }
        /**
         * Remove all data structures concerning a staker/stash once it is at a state where it can
         * be considered `dust` in the staking system. The requirements are:
         *
         * 1. the `total_balance` of the stash is below existential deposit.
         * 2. or, the `ledger.total` of the stash is below existential deposit.
         *
         * The former can happen in cases like a slash; the latter when a fully unbonded account
         * is still receiving staking rewards in `RewardDestination::Staked`.
         *
         * It can be called by anyone, as long as `stash` meets the above requirements.
         *
         * Refunds the transaction fees upon successful execution.
         */
        export interface reap_stash {
          type: "reap_stash"
          stash: sp_core.crypto.AccountId32
          num_slashing_spans: u32
        }
        /**
         * Rebond a portion of the stash scheduled to be unlocked.
         *
         * The dispatch origin must be signed by the controller.
         *
         * # <weight>
         * - Time complexity: O(L), where L is unlocking chunks
         * - Bounded by `MaxUnlockingChunks`.
         * - Storage changes: Can't increase storage, only decrease it.
         * # </weight>
         */
        export function rebond(
          value: Omit<pallet_staking.pallet.pallet.Call.rebond, "type">,
        ): pallet_staking.pallet.pallet.Call.rebond {
          return { type: "rebond", ...value }
        }
        /**
         * Rebond a portion of the stash scheduled to be unlocked.
         *
         * The dispatch origin must be signed by the controller.
         *
         * # <weight>
         * - Time complexity: O(L), where L is unlocking chunks
         * - Bounded by `MaxUnlockingChunks`.
         * - Storage changes: Can't increase storage, only decrease it.
         * # </weight>
         */
        export interface rebond {
          type: "rebond"
          value: Compact<u128>
        }
        /**
         * Scale up the ideal number of validators by a factor.
         *
         * The dispatch origin must be Root.
         *
         * # <weight>
         * Same as [`Self::set_validator_count`].
         * # </weight>
         */
        export function scale_validator_count(
          value: Omit<pallet_staking.pallet.pallet.Call.scale_validator_count, "type">,
        ): pallet_staking.pallet.pallet.Call.scale_validator_count {
          return { type: "scale_validator_count", ...value }
        }
        /**
         * Scale up the ideal number of validators by a factor.
         *
         * The dispatch origin must be Root.
         *
         * # <weight>
         * Same as [`Self::set_validator_count`].
         * # </weight>
         */
        export interface scale_validator_count {
          type: "scale_validator_count"
          factor: sp_arithmetic.per_things.Percent
        }
        /**
         * (Re-)set the controller of a stash.
         *
         * Effects will be felt instantly (as soon as this function is completed successfully).
         *
         * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - Contains a limited number of reads.
         * - Writes are limited to the `origin` account key.
         * ----------
         * Weight: O(1)
         * DB Weight:
         * - Read: Bonded, Ledger New Controller, Ledger Old Controller
         * - Write: Bonded, Ledger New Controller, Ledger Old Controller
         * # </weight>
         */
        export function set_controller(
          value: Omit<pallet_staking.pallet.pallet.Call.set_controller, "type">,
        ): pallet_staking.pallet.pallet.Call.set_controller {
          return { type: "set_controller", ...value }
        }
        /**
         * (Re-)set the controller of a stash.
         *
         * Effects will be felt instantly (as soon as this function is completed successfully).
         *
         * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - Contains a limited number of reads.
         * - Writes are limited to the `origin` account key.
         * ----------
         * Weight: O(1)
         * DB Weight:
         * - Read: Bonded, Ledger New Controller, Ledger Old Controller
         * - Write: Bonded, Ledger New Controller, Ledger Old Controller
         * # </weight>
         */
        export interface set_controller {
          type: "set_controller"
          controller: sp_runtime.multiaddress.MultiAddress
        }
        /**
         * Set the validators who cannot be slashed (if any).
         *
         * The dispatch origin must be Root.
         */
        export function set_invulnerables(
          value: Omit<pallet_staking.pallet.pallet.Call.set_invulnerables, "type">,
        ): pallet_staking.pallet.pallet.Call.set_invulnerables {
          return { type: "set_invulnerables", ...value }
        }
        /**
         * Set the validators who cannot be slashed (if any).
         *
         * The dispatch origin must be Root.
         */
        export interface set_invulnerables {
          type: "set_invulnerables"
          invulnerables: Array<sp_core.crypto.AccountId32>
        }
        /**
         * (Re-)set the payment target for a controller.
         *
         * Effects will be felt instantly (as soon as this function is completed successfully).
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - Contains a limited number of reads.
         * - Writes are limited to the `origin` account key.
         * ---------
         * - Weight: O(1)
         * - DB Weight:
         *     - Read: Ledger
         *     - Write: Payee
         * # </weight>
         */
        export function set_payee(
          value: Omit<pallet_staking.pallet.pallet.Call.set_payee, "type">,
        ): pallet_staking.pallet.pallet.Call.set_payee {
          return { type: "set_payee", ...value }
        }
        /**
         * (Re-)set the payment target for a controller.
         *
         * Effects will be felt instantly (as soon as this function is completed successfully).
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * # <weight>
         * - Independent of the arguments. Insignificant complexity.
         * - Contains a limited number of reads.
         * - Writes are limited to the `origin` account key.
         * ---------
         * - Weight: O(1)
         * - DB Weight:
         *     - Read: Ledger
         *     - Write: Payee
         * # </weight>
         */
        export interface set_payee {
          type: "set_payee"
          payee: pallet_staking.RewardDestination
        }
        /**
         * Update the various staking configurations .
         *
         * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
         * * `min_validator_bond`: The minimum active bond needed to be a validator.
         * * `max_nominator_count`: The max number of users who can be a nominator at once. When
         *   set to `None`, no limit is enforced.
         * * `max_validator_count`: The max number of users who can be a validator at once. When
         *   set to `None`, no limit is enforced.
         * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
         *   should be filled in order for the `chill_other` transaction to work.
         * * `min_commission`: The minimum amount of commission that each validators must maintain.
         *   This is checked only upon calling `validate`. Existing validators are not affected.
         *
         * RuntimeOrigin must be Root to call this function.
         *
         * NOTE: Existing nominators and validators will not be affected by this update.
         * to kick people under the new limits, `chill_other` should be called.
         */
        export function set_staking_configs(
          value: Omit<pallet_staking.pallet.pallet.Call.set_staking_configs, "type">,
        ): pallet_staking.pallet.pallet.Call.set_staking_configs {
          return { type: "set_staking_configs", ...value }
        }
        /**
         * Update the various staking configurations .
         *
         * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
         * * `min_validator_bond`: The minimum active bond needed to be a validator.
         * * `max_nominator_count`: The max number of users who can be a nominator at once. When
         *   set to `None`, no limit is enforced.
         * * `max_validator_count`: The max number of users who can be a validator at once. When
         *   set to `None`, no limit is enforced.
         * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
         *   should be filled in order for the `chill_other` transaction to work.
         * * `min_commission`: The minimum amount of commission that each validators must maintain.
         *   This is checked only upon calling `validate`. Existing validators are not affected.
         *
         * RuntimeOrigin must be Root to call this function.
         *
         * NOTE: Existing nominators and validators will not be affected by this update.
         * to kick people under the new limits, `chill_other` should be called.
         */
        export interface set_staking_configs {
          type: "set_staking_configs"
          min_nominator_bond: pallet_staking.pallet.pallet.ConfigOp.$$u128
          min_validator_bond: pallet_staking.pallet.pallet.ConfigOp.$$u128
          max_nominator_count: pallet_staking.pallet.pallet.ConfigOp.$$u32
          max_validator_count: pallet_staking.pallet.pallet.ConfigOp.$$u32
          chill_threshold: pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent
          min_commission: pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill
        }
        /**
         * Sets the ideal number of validators.
         *
         * The dispatch origin must be Root.
         *
         * # <weight>
         * Weight: O(1)
         * Write: Validator Count
         * # </weight>
         */
        export function set_validator_count(
          value: Omit<pallet_staking.pallet.pallet.Call.set_validator_count, "type">,
        ): pallet_staking.pallet.pallet.Call.set_validator_count {
          return { type: "set_validator_count", ...value }
        }
        /**
         * Sets the ideal number of validators.
         *
         * The dispatch origin must be Root.
         *
         * # <weight>
         * Weight: O(1)
         * Write: Validator Count
         * # </weight>
         */
        export interface set_validator_count {
          type: "set_validator_count"
          new: Compact<u32>
        }
        /**
         * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
         * period ends. If this leaves an amount actively bonded less than
         * T::Currency::minimum_balance(), then it is increased to the full amount.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
         * the funds out of management ready for transfer.
         *
         * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
         * can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need
         * to be called first to remove some of the chunks (if possible).
         *
         * If a user encounters the `InsufficientBond` error when calling this extrinsic,
         * they should call `chill` first in order to free up their bonded funds.
         *
         * Emits `Unbonded`.
         *
         * See also [`Call::withdraw_unbonded`].
         */
        export function unbond(
          value: Omit<pallet_staking.pallet.pallet.Call.unbond, "type">,
        ): pallet_staking.pallet.pallet.Call.unbond {
          return { type: "unbond", ...value }
        }
        /**
         * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
         * period ends. If this leaves an amount actively bonded less than
         * T::Currency::minimum_balance(), then it is increased to the full amount.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         *
         * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
         * the funds out of management ready for transfer.
         *
         * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
         * can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need
         * to be called first to remove some of the chunks (if possible).
         *
         * If a user encounters the `InsufficientBond` error when calling this extrinsic,
         * they should call `chill` first in order to free up their bonded funds.
         *
         * Emits `Unbonded`.
         *
         * See also [`Call::withdraw_unbonded`].
         */
        export interface unbond {
          type: "unbond"
          value: Compact<u128>
        }
        /**
         * Declare the desire to validate for the origin controller.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         */
        export function validate(
          value: Omit<pallet_staking.pallet.pallet.Call.validate, "type">,
        ): pallet_staking.pallet.pallet.Call.validate {
          return { type: "validate", ...value }
        }
        /**
         * Declare the desire to validate for the origin controller.
         *
         * Effects will be felt at the beginning of the next era.
         *
         * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
         */
        export interface validate {
          type: "validate"
          prefs: pallet_staking.ValidatorPrefs
        }
        /**
         * Remove any unlocked chunks from the `unlocking` queue from our management.
         *
         * This essentially frees up that balance to be used by the stash account to do
         * whatever it wants.
         *
         * The dispatch origin for this call must be _Signed_ by the controller.
         *
         * Emits `Withdrawn`.
         *
         * See also [`Call::unbond`].
         *
         * # <weight>
         * Complexity O(S) where S is the number of slashing spans to remove
         * NOTE: Weight annotation is the kill scenario, we refund otherwise.
         * # </weight>
         */
        export function withdraw_unbonded(
          value: Omit<pallet_staking.pallet.pallet.Call.withdraw_unbonded, "type">,
        ): pallet_staking.pallet.pallet.Call.withdraw_unbonded {
          return { type: "withdraw_unbonded", ...value }
        }
        /**
         * Remove any unlocked chunks from the `unlocking` queue from our management.
         *
         * This essentially frees up that balance to be used by the stash account to do
         * whatever it wants.
         *
         * The dispatch origin for this call must be _Signed_ by the controller.
         *
         * Emits `Withdrawn`.
         *
         * See also [`Call::unbond`].
         *
         * # <weight>
         * Complexity O(S) where S is the number of slashing spans to remove
         * NOTE: Weight annotation is the kill scenario, we refund otherwise.
         * # </weight>
         */
        export interface withdraw_unbonded {
          type: "withdraw_unbonded"
          num_slashing_spans: u32
        }
      }
      export namespace ConfigOp {
        export const $$$u128: $.Codec<pallet_staking.pallet.pallet.ConfigOp.$$u128> = _codec.$207
        export const $$$u32: $.Codec<pallet_staking.pallet.pallet.ConfigOp.$$u32> = _codec.$208
        export namespace $$sp_arithmetic {
          export namespace per_things {
            export const $perbill: $.Codec<
              pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill
            > = _codec.$210
            export const $percent: $.Codec<
              pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent
            > = _codec.$209
            export type Perbill =
              | pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill.Noop
              | pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill.Set
              | pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill.Remove
            export namespace Perbill {
              export function Noop(): pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill.Noop {
                return { type: "Noop" }
              }
              export interface Noop {
                type: "Noop"
              }
              export function Remove(): pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill.Remove {
                return { type: "Remove" }
              }
              export interface Remove {
                type: "Remove"
              }
              export function Set(
                value: pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill.Set[
                  "value"
                ],
              ): pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Perbill.Set {
                return { type: "Set", value }
              }
              export interface Set {
                type: "Set"
                value: sp_arithmetic.per_things.Perbill
              }
            }
            export type Percent =
              | pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent.Noop
              | pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent.Set
              | pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent.Remove
            export namespace Percent {
              export function Noop(): pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent.Noop {
                return { type: "Noop" }
              }
              export interface Noop {
                type: "Noop"
              }
              export function Remove(): pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent.Remove {
                return { type: "Remove" }
              }
              export interface Remove {
                type: "Remove"
              }
              export function Set(
                value: pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent.Set[
                  "value"
                ],
              ): pallet_staking.pallet.pallet.ConfigOp.$$sp_arithmetic.per_things.Percent.Set {
                return { type: "Set", value }
              }
              export interface Set {
                type: "Set"
                value: sp_arithmetic.per_things.Percent
              }
            }
          }
        }
        export type $$u128 =
          | pallet_staking.pallet.pallet.ConfigOp.$$u128.Noop
          | pallet_staking.pallet.pallet.ConfigOp.$$u128.Set
          | pallet_staking.pallet.pallet.ConfigOp.$$u128.Remove
        export namespace $$u128 {
          export function Noop(): pallet_staking.pallet.pallet.ConfigOp.$$u128.Noop {
            return { type: "Noop" }
          }
          export interface Noop {
            type: "Noop"
          }
          export function Remove(): pallet_staking.pallet.pallet.ConfigOp.$$u128.Remove {
            return { type: "Remove" }
          }
          export interface Remove {
            type: "Remove"
          }
          export function Set(
            value: pallet_staking.pallet.pallet.ConfigOp.$$u128.Set["value"],
          ): pallet_staking.pallet.pallet.ConfigOp.$$u128.Set {
            return { type: "Set", value }
          }
          export interface Set {
            type: "Set"
            value: u128
          }
        }
        export type $$u32 =
          | pallet_staking.pallet.pallet.ConfigOp.$$u32.Noop
          | pallet_staking.pallet.pallet.ConfigOp.$$u32.Set
          | pallet_staking.pallet.pallet.ConfigOp.$$u32.Remove
        export namespace $$u32 {
          export function Noop(): pallet_staking.pallet.pallet.ConfigOp.$$u32.Noop {
            return { type: "Noop" }
          }
          export interface Noop {
            type: "Noop"
          }
          export function Remove(): pallet_staking.pallet.pallet.ConfigOp.$$u32.Remove {
            return { type: "Remove" }
          }
          export interface Remove {
            type: "Remove"
          }
          export function Set(
            value: pallet_staking.pallet.pallet.ConfigOp.$$u32.Set["value"],
          ): pallet_staking.pallet.pallet.ConfigOp.$$u32.Set {
            return { type: "Set", value }
          }
          export interface Set {
            type: "Set"
            value: u32
          }
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "NotController"
        | "NotStash"
        | "AlreadyBonded"
        | "AlreadyPaired"
        | "EmptyTargets"
        | "DuplicateIndex"
        | "InvalidSlashIndex"
        | "InsufficientBond"
        | "NoMoreChunks"
        | "NoUnlockChunk"
        | "FundedTarget"
        | "InvalidEraToReward"
        | "InvalidNumberOfNominations"
        | "NotSortedAndUnique"
        | "AlreadyClaimed"
        | "IncorrectHistoryDepth"
        | "IncorrectSlashingSpans"
        | "BadState"
        | "TooManyTargets"
        | "BadTarget"
        | "CannotChillOther"
        | "TooManyNominators"
        | "TooManyValidators"
        | "CommissionTooLow"
        | "BoundNotMet"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | pallet_staking.pallet.pallet.Event.EraPaid
        | pallet_staking.pallet.pallet.Event.Rewarded
        | pallet_staking.pallet.pallet.Event.Slashed
        | pallet_staking.pallet.pallet.Event.OldSlashingReportDiscarded
        | pallet_staking.pallet.pallet.Event.StakersElected
        | pallet_staking.pallet.pallet.Event.Bonded
        | pallet_staking.pallet.pallet.Event.Unbonded
        | pallet_staking.pallet.pallet.Event.Withdrawn
        | pallet_staking.pallet.pallet.Event.Kicked
        | pallet_staking.pallet.pallet.Event.StakingElectionFailed
        | pallet_staking.pallet.pallet.Event.Chilled
        | pallet_staking.pallet.pallet.Event.PayoutStarted
        | pallet_staking.pallet.pallet.Event.ValidatorPrefsSet
      export namespace Event {
        /**
         * An account has bonded this amount. \[stash, amount\]
         *
         * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
         * it will not be emitted for staking rewards when they are added to stake.
         */
        export function Bonded(
          value: Omit<pallet_staking.pallet.pallet.Event.Bonded, "type">,
        ): pallet_staking.pallet.pallet.Event.Bonded {
          return { type: "Bonded", ...value }
        }
        /**
         * An account has bonded this amount. \[stash, amount\]
         *
         * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
         * it will not be emitted for staking rewards when they are added to stake.
         */
        export interface Bonded {
          type: "Bonded"
          stash: sp_core.crypto.AccountId32
          amount: u128
        }
        /** An account has stopped participating as either a validator or nominator. */
        export function Chilled(
          value: Omit<pallet_staking.pallet.pallet.Event.Chilled, "type">,
        ): pallet_staking.pallet.pallet.Event.Chilled {
          return { type: "Chilled", ...value }
        }
        /** An account has stopped participating as either a validator or nominator. */
        export interface Chilled {
          type: "Chilled"
          stash: sp_core.crypto.AccountId32
        }
        /**
         * The era payout has been set; the first balance is the validator-payout; the second is
         * the remainder from the maximum amount of reward.
         */
        export function EraPaid(
          value: Omit<pallet_staking.pallet.pallet.Event.EraPaid, "type">,
        ): pallet_staking.pallet.pallet.Event.EraPaid {
          return { type: "EraPaid", ...value }
        }
        /**
         * The era payout has been set; the first balance is the validator-payout; the second is
         * the remainder from the maximum amount of reward.
         */
        export interface EraPaid {
          type: "EraPaid"
          era_index: u32
          validator_payout: u128
          remainder: u128
        }
        /** A nominator has been kicked from a validator. */
        export function Kicked(
          value: Omit<pallet_staking.pallet.pallet.Event.Kicked, "type">,
        ): pallet_staking.pallet.pallet.Event.Kicked {
          return { type: "Kicked", ...value }
        }
        /** A nominator has been kicked from a validator. */
        export interface Kicked {
          type: "Kicked"
          nominator: sp_core.crypto.AccountId32
          stash: sp_core.crypto.AccountId32
        }
        /**
         * An old slashing report from a prior era was discarded because it could
         * not be processed.
         */
        export function OldSlashingReportDiscarded(
          value: Omit<pallet_staking.pallet.pallet.Event.OldSlashingReportDiscarded, "type">,
        ): pallet_staking.pallet.pallet.Event.OldSlashingReportDiscarded {
          return { type: "OldSlashingReportDiscarded", ...value }
        }
        /**
         * An old slashing report from a prior era was discarded because it could
         * not be processed.
         */
        export interface OldSlashingReportDiscarded {
          type: "OldSlashingReportDiscarded"
          session_index: u32
        }
        /** The stakers' rewards are getting paid. */
        export function PayoutStarted(
          value: Omit<pallet_staking.pallet.pallet.Event.PayoutStarted, "type">,
        ): pallet_staking.pallet.pallet.Event.PayoutStarted {
          return { type: "PayoutStarted", ...value }
        }
        /** The stakers' rewards are getting paid. */
        export interface PayoutStarted {
          type: "PayoutStarted"
          era_index: u32
          validator_stash: sp_core.crypto.AccountId32
        }
        /** The nominator has been rewarded by this amount. */
        export function Rewarded(
          value: Omit<pallet_staking.pallet.pallet.Event.Rewarded, "type">,
        ): pallet_staking.pallet.pallet.Event.Rewarded {
          return { type: "Rewarded", ...value }
        }
        /** The nominator has been rewarded by this amount. */
        export interface Rewarded {
          type: "Rewarded"
          stash: sp_core.crypto.AccountId32
          amount: u128
        }
        /** One staker (and potentially its nominators) has been slashed by the given amount. */
        export function Slashed(
          value: Omit<pallet_staking.pallet.pallet.Event.Slashed, "type">,
        ): pallet_staking.pallet.pallet.Event.Slashed {
          return { type: "Slashed", ...value }
        }
        /** One staker (and potentially its nominators) has been slashed by the given amount. */
        export interface Slashed {
          type: "Slashed"
          staker: sp_core.crypto.AccountId32
          amount: u128
        }
        /** A new set of stakers was elected. */
        export function StakersElected(): pallet_staking.pallet.pallet.Event.StakersElected {
          return { type: "StakersElected" }
        }
        /** A new set of stakers was elected. */
        export interface StakersElected {
          type: "StakersElected"
        }
        /** The election failed. No new era is planned. */
        export function StakingElectionFailed(): pallet_staking.pallet.pallet.Event.StakingElectionFailed {
          return { type: "StakingElectionFailed" }
        }
        /** The election failed. No new era is planned. */
        export interface StakingElectionFailed {
          type: "StakingElectionFailed"
        }
        /** An account has unbonded this amount. */
        export function Unbonded(
          value: Omit<pallet_staking.pallet.pallet.Event.Unbonded, "type">,
        ): pallet_staking.pallet.pallet.Event.Unbonded {
          return { type: "Unbonded", ...value }
        }
        /** An account has unbonded this amount. */
        export interface Unbonded {
          type: "Unbonded"
          stash: sp_core.crypto.AccountId32
          amount: u128
        }
        /** A validator has set their preferences. */
        export function ValidatorPrefsSet(
          value: Omit<pallet_staking.pallet.pallet.Event.ValidatorPrefsSet, "type">,
        ): pallet_staking.pallet.pallet.Event.ValidatorPrefsSet {
          return { type: "ValidatorPrefsSet", ...value }
        }
        /** A validator has set their preferences. */
        export interface ValidatorPrefsSet {
          type: "ValidatorPrefsSet"
          stash: sp_core.crypto.AccountId32
          prefs: pallet_staking.ValidatorPrefs
        }
        /**
         * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
         * from the unlocking queue.
         */
        export function Withdrawn(
          value: Omit<pallet_staking.pallet.pallet.Event.Withdrawn, "type">,
        ): pallet_staking.pallet.pallet.Event.Withdrawn {
          return { type: "Withdrawn", ...value }
        }
        /**
         * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
         * from the unlocking queue.
         */
        export interface Withdrawn {
          type: "Withdrawn"
          stash: sp_core.crypto.AccountId32
          amount: u128
        }
      }
    }
  }
  export namespace slashing {
    export const $slashingSpans: $.Codec<pallet_staking.slashing.SlashingSpans> = _codec.$503
    export const $spanRecord: $.Codec<pallet_staking.slashing.SpanRecord> = _codec.$504
    export interface SlashingSpans {
      span_index: u32
      last_start: u32
      last_nonzero_slash: u32
      prior: Array<u32>
    }
    export function SlashingSpans(value: pallet_staking.slashing.SlashingSpans) {
      return value
    }
    export interface SpanRecord {
      slashed: u128
      paid_out: u128
    }
    export function SpanRecord(value: pallet_staking.slashing.SpanRecord) {
      return value
    }
  }
}
export namespace pallet_timestamp {
  export namespace pallet {
    export const $call: $.Codec<pallet_timestamp.pallet.Call> = _codec.$195
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call = pallet_timestamp.pallet.Call.set
    export namespace Call {
      /**
       * Set the current time.
       *
       * This call should be invoked exactly once per block. It will panic at the finalization
       * phase, if this call hasn't been invoked by that time.
       *
       * The timestamp should be greater than the previous one by the amount specified by
       * `MinimumPeriod`.
       *
       * The dispatch origin for this call must be `Inherent`.
       *
       * # <weight>
       * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
       * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
       *   `on_finalize`)
       * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
       * # </weight>
       */
      export function set(
        value: Omit<pallet_timestamp.pallet.Call.set, "type">,
      ): pallet_timestamp.pallet.Call.set {
        return { type: "set", ...value }
      }
      /**
       * Set the current time.
       *
       * This call should be invoked exactly once per block. It will panic at the finalization
       * phase, if this call hasn't been invoked by that time.
       *
       * The timestamp should be greater than the previous one by the amount specified by
       * `MinimumPeriod`.
       *
       * The dispatch origin for this call must be `Inherent`.
       *
       * # <weight>
       * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
       * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
       *   `on_finalize`)
       * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
       * # </weight>
       */
      export interface set {
        type: "set"
        now: Compact<u64>
      }
    }
  }
}
export namespace pallet_tips {
  export const $openTip: $.Codec<pallet_tips.OpenTip> = _codec.$598
  export interface OpenTip {
    reason: primitive_types.H256
    who: sp_core.crypto.AccountId32
    finder: sp_core.crypto.AccountId32
    deposit: u128
    closes: u32 | undefined
    tips: Array<[sp_core.crypto.AccountId32, u128]>
    finders_fee: boolean
  }
  export function OpenTip(value: pallet_tips.OpenTip) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_tips.pallet.Call> = _codec.$309
    export const $error: $.Codec<pallet_tips.pallet.Error> = _codec.$599
    export const $event: $.Codec<pallet_tips.pallet.Event> = _codec.$85
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_tips.pallet.Call.report_awesome
      | pallet_tips.pallet.Call.retract_tip
      | pallet_tips.pallet.Call.tip_new
      | pallet_tips.pallet.Call.tip
      | pallet_tips.pallet.Call.close_tip
      | pallet_tips.pallet.Call.slash_tip
    export namespace Call {
      /**
       * Close and payout a tip.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * The tip identified by `hash` must have finished its countdown period.
       *
       * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
       *   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
       *
       * # <weight>
       * - Complexity: `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length
       *   `T`. `T` is charged as upper bound given by `ContainsLengthBound`. The actual cost
       *   depends on the implementation of `T::Tippers`.
       * - DbReads: `Tips`, `Tippers`, `tip finder`
       * - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
       * # </weight>
       */
      export function close_tip(
        value: Omit<pallet_tips.pallet.Call.close_tip, "type">,
      ): pallet_tips.pallet.Call.close_tip {
        return { type: "close_tip", ...value }
      }
      /**
       * Close and payout a tip.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * The tip identified by `hash` must have finished its countdown period.
       *
       * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
       *   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
       *
       * # <weight>
       * - Complexity: `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length
       *   `T`. `T` is charged as upper bound given by `ContainsLengthBound`. The actual cost
       *   depends on the implementation of `T::Tippers`.
       * - DbReads: `Tips`, `Tippers`, `tip finder`
       * - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
       * # </weight>
       */
      export interface close_tip {
        type: "close_tip"
        hash: primitive_types.H256
      }
      /**
       * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
       * `DataDepositPerByte` for each byte in `reason`.
       *
       * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
       *   a UTF-8-encoded URL.
       * - `who`: The account which should be credited for the tip.
       *
       * Emits `NewTip` if successful.
       *
       * # <weight>
       * - Complexity: `O(R)` where `R` length of `reason`.
       *   - encoding and hashing of 'reason'
       * - DbReads: `Reasons`, `Tips`
       * - DbWrites: `Reasons`, `Tips`
       * # </weight>
       */
      export function report_awesome(
        value: Omit<pallet_tips.pallet.Call.report_awesome, "type">,
      ): pallet_tips.pallet.Call.report_awesome {
        return { type: "report_awesome", ...value }
      }
      /**
       * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
       * `DataDepositPerByte` for each byte in `reason`.
       *
       * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
       *   a UTF-8-encoded URL.
       * - `who`: The account which should be credited for the tip.
       *
       * Emits `NewTip` if successful.
       *
       * # <weight>
       * - Complexity: `O(R)` where `R` length of `reason`.
       *   - encoding and hashing of 'reason'
       * - DbReads: `Reasons`, `Tips`
       * - DbWrites: `Reasons`, `Tips`
       * # </weight>
       */
      export interface report_awesome {
        type: "report_awesome"
        reason: Uint8Array
        who: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
       *
       * If successful, the original deposit will be unreserved.
       *
       * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
       * must have been reported by the signing account through `report_awesome` (and not
       * through `tip_new`).
       *
       * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
       *   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
       *
       * Emits `TipRetracted` if successful.
       *
       * # <weight>
       * - Complexity: `O(1)`
       *   - Depends on the length of `T::Hash` which is fixed.
       * - DbReads: `Tips`, `origin account`
       * - DbWrites: `Reasons`, `Tips`, `origin account`
       * # </weight>
       */
      export function retract_tip(
        value: Omit<pallet_tips.pallet.Call.retract_tip, "type">,
      ): pallet_tips.pallet.Call.retract_tip {
        return { type: "retract_tip", ...value }
      }
      /**
       * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
       *
       * If successful, the original deposit will be unreserved.
       *
       * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
       * must have been reported by the signing account through `report_awesome` (and not
       * through `tip_new`).
       *
       * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
       *   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
       *
       * Emits `TipRetracted` if successful.
       *
       * # <weight>
       * - Complexity: `O(1)`
       *   - Depends on the length of `T::Hash` which is fixed.
       * - DbReads: `Tips`, `origin account`
       * - DbWrites: `Reasons`, `Tips`, `origin account`
       * # </weight>
       */
      export interface retract_tip {
        type: "retract_tip"
        hash: primitive_types.H256
      }
      /**
       * Remove and slash an already-open tip.
       *
       * May only be called from `T::RejectOrigin`.
       *
       * As a result, the finder is slashed and the deposits are lost.
       *
       * Emits `TipSlashed` if successful.
       *
       * # <weight>
       *   `T` is charged as upper bound given by `ContainsLengthBound`.
       *   The actual cost depends on the implementation of `T::Tippers`.
       * # </weight>
       */
      export function slash_tip(
        value: Omit<pallet_tips.pallet.Call.slash_tip, "type">,
      ): pallet_tips.pallet.Call.slash_tip {
        return { type: "slash_tip", ...value }
      }
      /**
       * Remove and slash an already-open tip.
       *
       * May only be called from `T::RejectOrigin`.
       *
       * As a result, the finder is slashed and the deposits are lost.
       *
       * Emits `TipSlashed` if successful.
       *
       * # <weight>
       *   `T` is charged as upper bound given by `ContainsLengthBound`.
       *   The actual cost depends on the implementation of `T::Tippers`.
       * # </weight>
       */
      export interface slash_tip {
        type: "slash_tip"
        hash: primitive_types.H256
      }
      /**
       * Declare a tip value for an already-open tip.
       *
       * The dispatch origin for this call must be _Signed_ and the signing account must be a
       * member of the `Tippers` set.
       *
       * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
       *   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
       *   account ID.
       * - `tip_value`: The amount of tip that the sender would like to give. The median tip
       *   value of active tippers will be given to the `who`.
       *
       * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
       * has started.
       *
       * # <weight>
       * - Complexity: `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length
       *   `T`, insert tip and check closing, `T` is charged as upper bound given by
       *   `ContainsLengthBound`. The actual cost depends on the implementation of `T::Tippers`.
       *
       *   Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
       *   is weighted as if almost full i.e of length `T-1`.
       * - DbReads: `Tippers`, `Tips`
       * - DbWrites: `Tips`
       * # </weight>
       */
      export function tip(
        value: Omit<pallet_tips.pallet.Call.tip, "type">,
      ): pallet_tips.pallet.Call.tip {
        return { type: "tip", ...value }
      }
      /**
       * Declare a tip value for an already-open tip.
       *
       * The dispatch origin for this call must be _Signed_ and the signing account must be a
       * member of the `Tippers` set.
       *
       * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
       *   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
       *   account ID.
       * - `tip_value`: The amount of tip that the sender would like to give. The median tip
       *   value of active tippers will be given to the `who`.
       *
       * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
       * has started.
       *
       * # <weight>
       * - Complexity: `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length
       *   `T`, insert tip and check closing, `T` is charged as upper bound given by
       *   `ContainsLengthBound`. The actual cost depends on the implementation of `T::Tippers`.
       *
       *   Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
       *   is weighted as if almost full i.e of length `T-1`.
       * - DbReads: `Tippers`, `Tips`
       * - DbWrites: `Tips`
       * # </weight>
       */
      export interface tip {
        type: "tip"
        hash: primitive_types.H256
        tip_value: Compact<u128>
      }
      /**
       * Give a tip for something new; no finder's fee will be taken.
       *
       * The dispatch origin for this call must be _Signed_ and the signing account must be a
       * member of the `Tippers` set.
       *
       * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
       *   a UTF-8-encoded URL.
       * - `who`: The account which should be credited for the tip.
       * - `tip_value`: The amount of tip that the sender would like to give. The median tip
       *   value of active tippers will be given to the `who`.
       *
       * Emits `NewTip` if successful.
       *
       * # <weight>
       * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
       *   - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
       *     `ContainsLengthBound`. The actual cost depends on the implementation of
       *     `T::Tippers`.
       *   - `O(R)`: hashing and encoding of reason of length `R`
       * - DbReads: `Tippers`, `Reasons`
       * - DbWrites: `Reasons`, `Tips`
       * # </weight>
       */
      export function tip_new(
        value: Omit<pallet_tips.pallet.Call.tip_new, "type">,
      ): pallet_tips.pallet.Call.tip_new {
        return { type: "tip_new", ...value }
      }
      /**
       * Give a tip for something new; no finder's fee will be taken.
       *
       * The dispatch origin for this call must be _Signed_ and the signing account must be a
       * member of the `Tippers` set.
       *
       * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
       *   a UTF-8-encoded URL.
       * - `who`: The account which should be credited for the tip.
       * - `tip_value`: The amount of tip that the sender would like to give. The median tip
       *   value of active tippers will be given to the `who`.
       *
       * Emits `NewTip` if successful.
       *
       * # <weight>
       * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
       *   - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
       *     `ContainsLengthBound`. The actual cost depends on the implementation of
       *     `T::Tippers`.
       *   - `O(R)`: hashing and encoding of reason of length `R`
       * - DbReads: `Tippers`, `Reasons`
       * - DbWrites: `Reasons`, `Tips`
       * # </weight>
       */
      export interface tip_new {
        type: "tip_new"
        reason: Uint8Array
        who: sp_runtime.multiaddress.MultiAddress
        tip_value: Compact<u128>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "ReasonTooBig"
      | "AlreadyKnown"
      | "UnknownTip"
      | "NotFinder"
      | "StillOpen"
      | "Premature"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_tips.pallet.Event.NewTip
      | pallet_tips.pallet.Event.TipClosing
      | pallet_tips.pallet.Event.TipClosed
      | pallet_tips.pallet.Event.TipRetracted
      | pallet_tips.pallet.Event.TipSlashed
    export namespace Event {
      /** A new tip suggestion has been opened. */
      export function NewTip(
        value: Omit<pallet_tips.pallet.Event.NewTip, "type">,
      ): pallet_tips.pallet.Event.NewTip {
        return { type: "NewTip", ...value }
      }
      /** A new tip suggestion has been opened. */
      export interface NewTip {
        type: "NewTip"
        tip_hash: primitive_types.H256
      }
      /** A tip suggestion has been closed. */
      export function TipClosed(
        value: Omit<pallet_tips.pallet.Event.TipClosed, "type">,
      ): pallet_tips.pallet.Event.TipClosed {
        return { type: "TipClosed", ...value }
      }
      /** A tip suggestion has been closed. */
      export interface TipClosed {
        type: "TipClosed"
        tip_hash: primitive_types.H256
        who: sp_core.crypto.AccountId32
        payout: u128
      }
      /** A tip suggestion has reached threshold and is closing. */
      export function TipClosing(
        value: Omit<pallet_tips.pallet.Event.TipClosing, "type">,
      ): pallet_tips.pallet.Event.TipClosing {
        return { type: "TipClosing", ...value }
      }
      /** A tip suggestion has reached threshold and is closing. */
      export interface TipClosing {
        type: "TipClosing"
        tip_hash: primitive_types.H256
      }
      /** A tip suggestion has been retracted. */
      export function TipRetracted(
        value: Omit<pallet_tips.pallet.Event.TipRetracted, "type">,
      ): pallet_tips.pallet.Event.TipRetracted {
        return { type: "TipRetracted", ...value }
      }
      /** A tip suggestion has been retracted. */
      export interface TipRetracted {
        type: "TipRetracted"
        tip_hash: primitive_types.H256
      }
      /** A tip suggestion has been slashed. */
      export function TipSlashed(
        value: Omit<pallet_tips.pallet.Event.TipSlashed, "type">,
      ): pallet_tips.pallet.Event.TipSlashed {
        return { type: "TipSlashed", ...value }
      }
      /** A tip suggestion has been slashed. */
      export interface TipSlashed {
        type: "TipSlashed"
        tip_hash: primitive_types.H256
        finder: sp_core.crypto.AccountId32
        deposit: u128
      }
    }
  }
}
export namespace pallet_transaction_payment {
  export const $releases: $.Codec<pallet_transaction_payment.Releases> = _codec.$480
  export type Releases = "V1Ancient" | "V2"
  export namespace pallet {
    export const $event: $.Codec<pallet_transaction_payment.pallet.Event> = _codec.$38
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event = pallet_transaction_payment.pallet.Event.TransactionFeePaid
    export namespace Event {
      /**
       * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
       * has been paid by `who`.
       */
      export function TransactionFeePaid(
        value: Omit<pallet_transaction_payment.pallet.Event.TransactionFeePaid, "type">,
      ): pallet_transaction_payment.pallet.Event.TransactionFeePaid {
        return { type: "TransactionFeePaid", ...value }
      }
      /**
       * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
       * has been paid by `who`.
       */
      export interface TransactionFeePaid {
        type: "TransactionFeePaid"
        who: sp_core.crypto.AccountId32
        actual_fee: u128
        tip: u128
      }
    }
  }
}
export namespace pallet_treasury {
  export const $proposal: $.Codec<pallet_treasury.Proposal> = _codec.$556
  export interface Proposal {
    proposer: sp_core.crypto.AccountId32
    value: u128
    beneficiary: sp_core.crypto.AccountId32
    bond: u128
  }
  export function Proposal(value: pallet_treasury.Proposal) {
    return value
  }
  export namespace pallet {
    export const $call: $.Codec<pallet_treasury.pallet.Call> = _codec.$244
    export const $error: $.Codec<pallet_treasury.pallet.Error> = _codec.$561
    export const $event: $.Codec<pallet_treasury.pallet.Event> = _codec.$71
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_treasury.pallet.Call.propose_spend
      | pallet_treasury.pallet.Call.reject_proposal
      | pallet_treasury.pallet.Call.approve_proposal
      | pallet_treasury.pallet.Call.spend
      | pallet_treasury.pallet.Call.remove_approval
    export namespace Call {
      /**
       * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
       * and the original deposit will be returned.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - Complexity: O(1).
       * - DbReads: `Proposals`, `Approvals`
       * - DbWrite: `Approvals`
       * # </weight>
       */
      export function approve_proposal(
        value: Omit<pallet_treasury.pallet.Call.approve_proposal, "type">,
      ): pallet_treasury.pallet.Call.approve_proposal {
        return { type: "approve_proposal", ...value }
      }
      /**
       * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
       * and the original deposit will be returned.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - Complexity: O(1).
       * - DbReads: `Proposals`, `Approvals`
       * - DbWrite: `Approvals`
       * # </weight>
       */
      export interface approve_proposal {
        type: "approve_proposal"
        proposal_id: Compact<u32>
      }
      /**
       * Put forward a suggestion for spending. A deposit proportional to the value
       * is reserved and slashed if the proposal is rejected. It is returned once the
       * proposal is awarded.
       *
       * # <weight>
       * - Complexity: O(1)
       * - DbReads: `ProposalCount`, `origin account`
       * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
       * # </weight>
       */
      export function propose_spend(
        value: Omit<pallet_treasury.pallet.Call.propose_spend, "type">,
      ): pallet_treasury.pallet.Call.propose_spend {
        return { type: "propose_spend", ...value }
      }
      /**
       * Put forward a suggestion for spending. A deposit proportional to the value
       * is reserved and slashed if the proposal is rejected. It is returned once the
       * proposal is awarded.
       *
       * # <weight>
       * - Complexity: O(1)
       * - DbReads: `ProposalCount`, `origin account`
       * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
       * # </weight>
       */
      export interface propose_spend {
        type: "propose_spend"
        value: Compact<u128>
        beneficiary: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Reject a proposed spend. The original deposit will be slashed.
       *
       * May only be called from `T::RejectOrigin`.
       *
       * # <weight>
       * - Complexity: O(1)
       * - DbReads: `Proposals`, `rejected proposer account`
       * - DbWrites: `Proposals`, `rejected proposer account`
       * # </weight>
       */
      export function reject_proposal(
        value: Omit<pallet_treasury.pallet.Call.reject_proposal, "type">,
      ): pallet_treasury.pallet.Call.reject_proposal {
        return { type: "reject_proposal", ...value }
      }
      /**
       * Reject a proposed spend. The original deposit will be slashed.
       *
       * May only be called from `T::RejectOrigin`.
       *
       * # <weight>
       * - Complexity: O(1)
       * - DbReads: `Proposals`, `rejected proposer account`
       * - DbWrites: `Proposals`, `rejected proposer account`
       * # </weight>
       */
      export interface reject_proposal {
        type: "reject_proposal"
        proposal_id: Compact<u32>
      }
      /**
       * Force a previously approved proposal to be removed from the approval queue.
       * The original deposit will no longer be returned.
       *
       * May only be called from `T::RejectOrigin`.
       * - `proposal_id`: The index of a proposal
       *
       * # <weight>
       * - Complexity: O(A) where `A` is the number of approvals
       * - Db reads and writes: `Approvals`
       * # </weight>
       *
       * Errors:
       * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
       * i.e., the proposal has not been approved. This could also mean the proposal does not
       * exist altogether, thus there is no way it would have been approved in the first place.
       */
      export function remove_approval(
        value: Omit<pallet_treasury.pallet.Call.remove_approval, "type">,
      ): pallet_treasury.pallet.Call.remove_approval {
        return { type: "remove_approval", ...value }
      }
      /**
       * Force a previously approved proposal to be removed from the approval queue.
       * The original deposit will no longer be returned.
       *
       * May only be called from `T::RejectOrigin`.
       * - `proposal_id`: The index of a proposal
       *
       * # <weight>
       * - Complexity: O(A) where `A` is the number of approvals
       * - Db reads and writes: `Approvals`
       * # </weight>
       *
       * Errors:
       * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
       * i.e., the proposal has not been approved. This could also mean the proposal does not
       * exist altogether, thus there is no way it would have been approved in the first place.
       */
      export interface remove_approval {
        type: "remove_approval"
        proposal_id: Compact<u32>
      }
      /**
       * Propose and approve a spend of treasury funds.
       *
       * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
       * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
       * - `beneficiary`: The destination account for the transfer.
       *
       * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
       * beneficiary.
       */
      export function spend(
        value: Omit<pallet_treasury.pallet.Call.spend, "type">,
      ): pallet_treasury.pallet.Call.spend {
        return { type: "spend", ...value }
      }
      /**
       * Propose and approve a spend of treasury funds.
       *
       * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
       * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
       * - `beneficiary`: The destination account for the transfer.
       *
       * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
       * beneficiary.
       */
      export interface spend {
        type: "spend"
        amount: Compact<u128>
        beneficiary: sp_runtime.multiaddress.MultiAddress
      }
    }
    /** Error for the treasury pallet. */
    export type Error =
      | "InsufficientProposersBalance"
      | "InvalidIndex"
      | "TooManyApprovals"
      | "InsufficientPermission"
      | "ProposalNotApproved"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_treasury.pallet.Event.Proposed
      | pallet_treasury.pallet.Event.Spending
      | pallet_treasury.pallet.Event.Awarded
      | pallet_treasury.pallet.Event.Rejected
      | pallet_treasury.pallet.Event.Burnt
      | pallet_treasury.pallet.Event.Rollover
      | pallet_treasury.pallet.Event.Deposit
      | pallet_treasury.pallet.Event.SpendApproved
    export namespace Event {
      /** Some funds have been allocated. */
      export function Awarded(
        value: Omit<pallet_treasury.pallet.Event.Awarded, "type">,
      ): pallet_treasury.pallet.Event.Awarded {
        return { type: "Awarded", ...value }
      }
      /** Some funds have been allocated. */
      export interface Awarded {
        type: "Awarded"
        proposal_index: u32
        award: u128
        account: sp_core.crypto.AccountId32
      }
      /** Some of our funds have been burnt. */
      export function Burnt(
        value: Omit<pallet_treasury.pallet.Event.Burnt, "type">,
      ): pallet_treasury.pallet.Event.Burnt {
        return { type: "Burnt", ...value }
      }
      /** Some of our funds have been burnt. */
      export interface Burnt {
        type: "Burnt"
        burnt_funds: u128
      }
      /** Some funds have been deposited. */
      export function Deposit(
        value: Omit<pallet_treasury.pallet.Event.Deposit, "type">,
      ): pallet_treasury.pallet.Event.Deposit {
        return { type: "Deposit", ...value }
      }
      /** Some funds have been deposited. */
      export interface Deposit {
        type: "Deposit"
        value: u128
      }
      /** New proposal. */
      export function Proposed(
        value: Omit<pallet_treasury.pallet.Event.Proposed, "type">,
      ): pallet_treasury.pallet.Event.Proposed {
        return { type: "Proposed", ...value }
      }
      /** New proposal. */
      export interface Proposed {
        type: "Proposed"
        proposal_index: u32
      }
      /** A proposal was rejected; funds were slashed. */
      export function Rejected(
        value: Omit<pallet_treasury.pallet.Event.Rejected, "type">,
      ): pallet_treasury.pallet.Event.Rejected {
        return { type: "Rejected", ...value }
      }
      /** A proposal was rejected; funds were slashed. */
      export interface Rejected {
        type: "Rejected"
        proposal_index: u32
        slashed: u128
      }
      /** Spending has finished; this is the amount that rolls over until next spend. */
      export function Rollover(
        value: Omit<pallet_treasury.pallet.Event.Rollover, "type">,
      ): pallet_treasury.pallet.Event.Rollover {
        return { type: "Rollover", ...value }
      }
      /** Spending has finished; this is the amount that rolls over until next spend. */
      export interface Rollover {
        type: "Rollover"
        rollover_balance: u128
      }
      /** A new spend proposal has been approved. */
      export function SpendApproved(
        value: Omit<pallet_treasury.pallet.Event.SpendApproved, "type">,
      ): pallet_treasury.pallet.Event.SpendApproved {
        return { type: "SpendApproved", ...value }
      }
      /** A new spend proposal has been approved. */
      export interface SpendApproved {
        type: "SpendApproved"
        proposal_index: u32
        amount: u128
        beneficiary: sp_core.crypto.AccountId32
      }
      /** We have ended a spend period and will now allocate funds. */
      export function Spending(
        value: Omit<pallet_treasury.pallet.Event.Spending, "type">,
      ): pallet_treasury.pallet.Event.Spending {
        return { type: "Spending", ...value }
      }
      /** We have ended a spend period and will now allocate funds. */
      export interface Spending {
        type: "Spending"
        budget_remaining: u128
      }
    }
  }
}
export namespace pallet_utility {
  export namespace pallet {
    export const $call: $.Codec<pallet_utility.pallet.Call> = _codec.$254
    export const $error: $.Codec<pallet_utility.pallet.Error> = _codec.$567
    export const $event: $.Codec<pallet_utility.pallet.Event> = _codec.$76
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_utility.pallet.Call.batch
      | pallet_utility.pallet.Call.as_derivative
      | pallet_utility.pallet.Call.batch_all
      | pallet_utility.pallet.Call.dispatch_as
      | pallet_utility.pallet.Call.force_batch
    export namespace Call {
      /**
       * Send a call through an indexed pseudonym of the sender.
       *
       * Filter from origin are passed along. The call will be dispatched with an origin which
       * use the same filter as the origin of this call.
       *
       * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
       * because you expect `proxy` to have been used prior in the call stack and you do not want
       * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
       * in the Multisig pallet instead.
       *
       * NOTE: Prior to version *12, this was called `as_limited_sub`.
       *
       * The dispatch origin for this call must be _Signed_.
       */
      export function as_derivative(
        value: Omit<pallet_utility.pallet.Call.as_derivative, "type">,
      ): pallet_utility.pallet.Call.as_derivative {
        return { type: "as_derivative", ...value }
      }
      /**
       * Send a call through an indexed pseudonym of the sender.
       *
       * Filter from origin are passed along. The call will be dispatched with an origin which
       * use the same filter as the origin of this call.
       *
       * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
       * because you expect `proxy` to have been used prior in the call stack and you do not want
       * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
       * in the Multisig pallet instead.
       *
       * NOTE: Prior to version *12, this was called `as_limited_sub`.
       *
       * The dispatch origin for this call must be _Signed_.
       */
      export interface as_derivative {
        type: "as_derivative"
        index: u16
        call: polkadot_runtime.RuntimeCall
      }
      /**
       * Send a batch of dispatch calls.
       *
       * May be called from any origin.
       *
       * - `calls`: The calls to be dispatched from the same origin. The number of call must not
       *   exceed the constant: `batched_calls_limit` (available in constant metadata).
       *
       * If origin is root then call are dispatch without checking origin filter. (This includes
       * bypassing `frame_system::Config::BaseCallFilter`).
       *
       * # <weight>
       * - Complexity: O(C) where C is the number of calls to be batched.
       * # </weight>
       *
       * This will return `Ok` in all circumstances. To determine the success of the batch, an
       * event is deposited. If a call failed and the batch was interrupted, then the
       * `BatchInterrupted` event is deposited, along with the number of successful calls made
       * and the error of the failed call. If all were successful, then the `BatchCompleted`
       * event is deposited.
       */
      export function batch(
        value: Omit<pallet_utility.pallet.Call.batch, "type">,
      ): pallet_utility.pallet.Call.batch {
        return { type: "batch", ...value }
      }
      /**
       * Send a batch of dispatch calls.
       *
       * May be called from any origin.
       *
       * - `calls`: The calls to be dispatched from the same origin. The number of call must not
       *   exceed the constant: `batched_calls_limit` (available in constant metadata).
       *
       * If origin is root then call are dispatch without checking origin filter. (This includes
       * bypassing `frame_system::Config::BaseCallFilter`).
       *
       * # <weight>
       * - Complexity: O(C) where C is the number of calls to be batched.
       * # </weight>
       *
       * This will return `Ok` in all circumstances. To determine the success of the batch, an
       * event is deposited. If a call failed and the batch was interrupted, then the
       * `BatchInterrupted` event is deposited, along with the number of successful calls made
       * and the error of the failed call. If all were successful, then the `BatchCompleted`
       * event is deposited.
       */
      export interface batch {
        type: "batch"
        calls: Array<polkadot_runtime.RuntimeCall>
      }
      /**
       * Send a batch of dispatch calls and atomically execute them.
       * The whole transaction will rollback and fail if any of the calls failed.
       *
       * May be called from any origin.
       *
       * - `calls`: The calls to be dispatched from the same origin. The number of call must not
       *   exceed the constant: `batched_calls_limit` (available in constant metadata).
       *
       * If origin is root then call are dispatch without checking origin filter. (This includes
       * bypassing `frame_system::Config::BaseCallFilter`).
       *
       * # <weight>
       * - Complexity: O(C) where C is the number of calls to be batched.
       * # </weight>
       */
      export function batch_all(
        value: Omit<pallet_utility.pallet.Call.batch_all, "type">,
      ): pallet_utility.pallet.Call.batch_all {
        return { type: "batch_all", ...value }
      }
      /**
       * Send a batch of dispatch calls and atomically execute them.
       * The whole transaction will rollback and fail if any of the calls failed.
       *
       * May be called from any origin.
       *
       * - `calls`: The calls to be dispatched from the same origin. The number of call must not
       *   exceed the constant: `batched_calls_limit` (available in constant metadata).
       *
       * If origin is root then call are dispatch without checking origin filter. (This includes
       * bypassing `frame_system::Config::BaseCallFilter`).
       *
       * # <weight>
       * - Complexity: O(C) where C is the number of calls to be batched.
       * # </weight>
       */
      export interface batch_all {
        type: "batch_all"
        calls: Array<polkadot_runtime.RuntimeCall>
      }
      /**
       * Dispatches a function call with a provided origin.
       *
       * The dispatch origin for this call must be _Root_.
       *
       * # <weight>
       * - O(1).
       * - Limited storage reads.
       * - One DB write (event).
       * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
       * # </weight>
       */
      export function dispatch_as(
        value: Omit<pallet_utility.pallet.Call.dispatch_as, "type">,
      ): pallet_utility.pallet.Call.dispatch_as {
        return { type: "dispatch_as", ...value }
      }
      /**
       * Dispatches a function call with a provided origin.
       *
       * The dispatch origin for this call must be _Root_.
       *
       * # <weight>
       * - O(1).
       * - Limited storage reads.
       * - One DB write (event).
       * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
       * # </weight>
       */
      export interface dispatch_as {
        type: "dispatch_as"
        as_origin: polkadot_runtime.OriginCaller
        call: polkadot_runtime.RuntimeCall
      }
      /**
       * Send a batch of dispatch calls.
       * Unlike `batch`, it allows errors and won't interrupt.
       *
       * May be called from any origin.
       *
       * - `calls`: The calls to be dispatched from the same origin. The number of call must not
       *   exceed the constant: `batched_calls_limit` (available in constant metadata).
       *
       * If origin is root then call are dispatch without checking origin filter. (This includes
       * bypassing `frame_system::Config::BaseCallFilter`).
       *
       * # <weight>
       * - Complexity: O(C) where C is the number of calls to be batched.
       * # </weight>
       */
      export function force_batch(
        value: Omit<pallet_utility.pallet.Call.force_batch, "type">,
      ): pallet_utility.pallet.Call.force_batch {
        return { type: "force_batch", ...value }
      }
      /**
       * Send a batch of dispatch calls.
       * Unlike `batch`, it allows errors and won't interrupt.
       *
       * May be called from any origin.
       *
       * - `calls`: The calls to be dispatched from the same origin. The number of call must not
       *   exceed the constant: `batched_calls_limit` (available in constant metadata).
       *
       * If origin is root then call are dispatch without checking origin filter. (This includes
       * bypassing `frame_system::Config::BaseCallFilter`).
       *
       * # <weight>
       * - Complexity: O(C) where C is the number of calls to be batched.
       * # </weight>
       */
      export interface force_batch {
        type: "force_batch"
        calls: Array<polkadot_runtime.RuntimeCall>
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error = "TooManyCalls"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_utility.pallet.Event.BatchInterrupted
      | pallet_utility.pallet.Event.BatchCompleted
      | pallet_utility.pallet.Event.BatchCompletedWithErrors
      | pallet_utility.pallet.Event.ItemCompleted
      | pallet_utility.pallet.Event.ItemFailed
      | pallet_utility.pallet.Event.DispatchedAs
    export namespace Event {
      /** Batch of dispatches completed fully with no error. */
      export function BatchCompleted(): pallet_utility.pallet.Event.BatchCompleted {
        return { type: "BatchCompleted" }
      }
      /** Batch of dispatches completed fully with no error. */
      export interface BatchCompleted {
        type: "BatchCompleted"
      }
      /** Batch of dispatches completed but has errors. */
      export function BatchCompletedWithErrors(): pallet_utility.pallet.Event.BatchCompletedWithErrors {
        return { type: "BatchCompletedWithErrors" }
      }
      /** Batch of dispatches completed but has errors. */
      export interface BatchCompletedWithErrors {
        type: "BatchCompletedWithErrors"
      }
      /**
       * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
       * well as the error.
       */
      export function BatchInterrupted(
        value: Omit<pallet_utility.pallet.Event.BatchInterrupted, "type">,
      ): pallet_utility.pallet.Event.BatchInterrupted {
        return { type: "BatchInterrupted", ...value }
      }
      /**
       * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
       * well as the error.
       */
      export interface BatchInterrupted {
        type: "BatchInterrupted"
        index: u32
        error: sp_runtime.DispatchError
      }
      /** A call was dispatched. */
      export function DispatchedAs(
        value: Omit<pallet_utility.pallet.Event.DispatchedAs, "type">,
      ): pallet_utility.pallet.Event.DispatchedAs {
        return { type: "DispatchedAs", ...value }
      }
      /** A call was dispatched. */
      export interface DispatchedAs {
        type: "DispatchedAs"
        result: null | ChainError<sp_runtime.DispatchError>
      }
      /** A single item within a Batch of dispatches has completed with no error. */
      export function ItemCompleted(): pallet_utility.pallet.Event.ItemCompleted {
        return { type: "ItemCompleted" }
      }
      /** A single item within a Batch of dispatches has completed with no error. */
      export interface ItemCompleted {
        type: "ItemCompleted"
      }
      /** A single item within a Batch of dispatches has completed with error. */
      export function ItemFailed(
        value: Omit<pallet_utility.pallet.Event.ItemFailed, "type">,
      ): pallet_utility.pallet.Event.ItemFailed {
        return { type: "ItemFailed", ...value }
      }
      /** A single item within a Batch of dispatches has completed with error. */
      export interface ItemFailed {
        type: "ItemFailed"
        error: sp_runtime.DispatchError
      }
    }
  }
}
export namespace pallet_vesting {
  export const $releases: $.Codec<pallet_vesting.Releases> = _codec.$565
  export type Releases = "V0" | "V1"
  export namespace pallet {
    export const $call: $.Codec<pallet_vesting.pallet.Call> = _codec.$252
    export const $error: $.Codec<pallet_vesting.pallet.Error> = _codec.$566
    export const $event: $.Codec<pallet_vesting.pallet.Event> = _codec.$75
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_vesting.pallet.Call.vest
      | pallet_vesting.pallet.Call.vest_other
      | pallet_vesting.pallet.Call.vested_transfer
      | pallet_vesting.pallet.Call.force_vested_transfer
      | pallet_vesting.pallet.Call.merge_schedules
    export namespace Call {
      /**
       * Force a vested transfer.
       *
       * The dispatch origin for this call must be _Root_.
       *
       * - `source`: The account whose funds should be transferred.
       * - `target`: The account that should be transferred the vested funds.
       * - `schedule`: The vesting schedule attached to the transfer.
       *
       * Emits `VestingCreated`.
       *
       * NOTE: This will unlock all schedules through the current block.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 4 Reads, 4 Writes
       *     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
       *     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
       * # </weight>
       */
      export function force_vested_transfer(
        value: Omit<pallet_vesting.pallet.Call.force_vested_transfer, "type">,
      ): pallet_vesting.pallet.Call.force_vested_transfer {
        return { type: "force_vested_transfer", ...value }
      }
      /**
       * Force a vested transfer.
       *
       * The dispatch origin for this call must be _Root_.
       *
       * - `source`: The account whose funds should be transferred.
       * - `target`: The account that should be transferred the vested funds.
       * - `schedule`: The vesting schedule attached to the transfer.
       *
       * Emits `VestingCreated`.
       *
       * NOTE: This will unlock all schedules through the current block.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 4 Reads, 4 Writes
       *     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
       *     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
       * # </weight>
       */
      export interface force_vested_transfer {
        type: "force_vested_transfer"
        source: sp_runtime.multiaddress.MultiAddress
        target: sp_runtime.multiaddress.MultiAddress
        schedule: pallet_vesting.vesting_info.VestingInfo
      }
      /**
       * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
       * the highest possible start and end blocks. If both schedules have already started the
       * current block will be used as the schedule start; with the caveat that if one schedule
       * is finished by the current block, the other will be treated as the new merged schedule,
       * unmodified.
       *
       * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
       * NOTE: This will unlock all schedules through the current block prior to merging.
       * NOTE: If both schedules have ended by the current block, no new schedule will be created
       * and both will be removed.
       *
       * Merged schedule attributes:
       * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
       *   current_block)`.
       * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
       * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `schedule1_index`: index of the first schedule to merge.
       * - `schedule2_index`: index of the second schedule to merge.
       */
      export function merge_schedules(
        value: Omit<pallet_vesting.pallet.Call.merge_schedules, "type">,
      ): pallet_vesting.pallet.Call.merge_schedules {
        return { type: "merge_schedules", ...value }
      }
      /**
       * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
       * the highest possible start and end blocks. If both schedules have already started the
       * current block will be used as the schedule start; with the caveat that if one schedule
       * is finished by the current block, the other will be treated as the new merged schedule,
       * unmodified.
       *
       * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
       * NOTE: This will unlock all schedules through the current block prior to merging.
       * NOTE: If both schedules have ended by the current block, no new schedule will be created
       * and both will be removed.
       *
       * Merged schedule attributes:
       * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
       *   current_block)`.
       * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
       * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `schedule1_index`: index of the first schedule to merge.
       * - `schedule2_index`: index of the second schedule to merge.
       */
      export interface merge_schedules {
        type: "merge_schedules"
        schedule1_index: u32
        schedule2_index: u32
      }
      /**
       * Unlock any vested funds of the sender account.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have funds still
       * locked under this pallet.
       *
       * Emits either `VestingCompleted` or `VestingUpdated`.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 2 Reads, 2 Writes
       *     - Reads: Vesting Storage, Balances Locks, [Sender Account]
       *     - Writes: Vesting Storage, Balances Locks, [Sender Account]
       * # </weight>
       */
      export function vest(): pallet_vesting.pallet.Call.vest {
        return { type: "vest" }
      }
      /**
       * Unlock any vested funds of the sender account.
       *
       * The dispatch origin for this call must be _Signed_ and the sender must have funds still
       * locked under this pallet.
       *
       * Emits either `VestingCompleted` or `VestingUpdated`.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 2 Reads, 2 Writes
       *     - Reads: Vesting Storage, Balances Locks, [Sender Account]
       *     - Writes: Vesting Storage, Balances Locks, [Sender Account]
       * # </weight>
       */
      export interface vest {
        type: "vest"
      }
      /**
       * Unlock any vested funds of a `target` account.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `target`: The account whose vested funds should be unlocked. Must have funds still
       * locked under this pallet.
       *
       * Emits either `VestingCompleted` or `VestingUpdated`.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 3 Reads, 3 Writes
       *     - Reads: Vesting Storage, Balances Locks, Target Account
       *     - Writes: Vesting Storage, Balances Locks, Target Account
       * # </weight>
       */
      export function vest_other(
        value: Omit<pallet_vesting.pallet.Call.vest_other, "type">,
      ): pallet_vesting.pallet.Call.vest_other {
        return { type: "vest_other", ...value }
      }
      /**
       * Unlock any vested funds of a `target` account.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `target`: The account whose vested funds should be unlocked. Must have funds still
       * locked under this pallet.
       *
       * Emits either `VestingCompleted` or `VestingUpdated`.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 3 Reads, 3 Writes
       *     - Reads: Vesting Storage, Balances Locks, Target Account
       *     - Writes: Vesting Storage, Balances Locks, Target Account
       * # </weight>
       */
      export interface vest_other {
        type: "vest_other"
        target: sp_runtime.multiaddress.MultiAddress
      }
      /**
       * Create a vested transfer.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `target`: The account receiving the vested funds.
       * - `schedule`: The vesting schedule attached to the transfer.
       *
       * Emits `VestingCreated`.
       *
       * NOTE: This will unlock all schedules through the current block.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 3 Reads, 3 Writes
       *     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
       *     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
       * # </weight>
       */
      export function vested_transfer(
        value: Omit<pallet_vesting.pallet.Call.vested_transfer, "type">,
      ): pallet_vesting.pallet.Call.vested_transfer {
        return { type: "vested_transfer", ...value }
      }
      /**
       * Create a vested transfer.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * - `target`: The account receiving the vested funds.
       * - `schedule`: The vesting schedule attached to the transfer.
       *
       * Emits `VestingCreated`.
       *
       * NOTE: This will unlock all schedules through the current block.
       *
       * # <weight>
       * - `O(1)`.
       * - DbWeight: 3 Reads, 3 Writes
       *     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
       *     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
       * # </weight>
       */
      export interface vested_transfer {
        type: "vested_transfer"
        target: sp_runtime.multiaddress.MultiAddress
        schedule: pallet_vesting.vesting_info.VestingInfo
      }
    }
    /** Error for the vesting pallet. */
    export type Error =
      | "NotVesting"
      | "AtMaxVestingSchedules"
      | "AmountLow"
      | "ScheduleIndexOutOfBounds"
      | "InvalidScheduleParams"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_vesting.pallet.Event.VestingUpdated
      | pallet_vesting.pallet.Event.VestingCompleted
    export namespace Event {
      /** An \[account\] has become fully vested. */
      export function VestingCompleted(
        value: Omit<pallet_vesting.pallet.Event.VestingCompleted, "type">,
      ): pallet_vesting.pallet.Event.VestingCompleted {
        return { type: "VestingCompleted", ...value }
      }
      /** An \[account\] has become fully vested. */
      export interface VestingCompleted {
        type: "VestingCompleted"
        account: sp_core.crypto.AccountId32
      }
      /**
       * The amount vested has been updated. This could indicate a change in funds available.
       * The balance given is the amount which is left unvested (and thus locked).
       */
      export function VestingUpdated(
        value: Omit<pallet_vesting.pallet.Event.VestingUpdated, "type">,
      ): pallet_vesting.pallet.Event.VestingUpdated {
        return { type: "VestingUpdated", ...value }
      }
      /**
       * The amount vested has been updated. This could indicate a change in funds available.
       * The balance given is the amount which is left unvested (and thus locked).
       */
      export interface VestingUpdated {
        type: "VestingUpdated"
        account: sp_core.crypto.AccountId32
        unvested: u128
      }
    }
  }
  export namespace vesting_info {
    export const $vestingInfo: $.Codec<pallet_vesting.vesting_info.VestingInfo> = _codec.$253
    export interface VestingInfo {
      locked: u128
      per_block: u128
      starting_block: u32
    }
    export function VestingInfo(value: pallet_vesting.vesting_info.VestingInfo) {
      return value
    }
  }
}
export namespace pallet_xcm {
  export namespace pallet {
    export const $call: $.Codec<pallet_xcm.pallet.Call> = _codec.$423
    export const $error: $.Codec<pallet_xcm.pallet.Error> = _codec.$724
    export const $event: $.Codec<pallet_xcm.pallet.Event> = _codec.$121
    export const $origin: $.Codec<pallet_xcm.pallet.Origin> = _codec.$261
    export const $queryStatus: $.Codec<pallet_xcm.pallet.QueryStatus> = _codec.$713
    export const $versionMigrationStage: $.Codec<pallet_xcm.pallet.VersionMigrationStage> =
      _codec.$722
    /** Contains one variant per dispatchable that can be called by an extrinsic. */
    export type Call =
      | pallet_xcm.pallet.Call.send
      | pallet_xcm.pallet.Call.teleport_assets
      | pallet_xcm.pallet.Call.reserve_transfer_assets
      | pallet_xcm.pallet.Call.execute
      | pallet_xcm.pallet.Call.force_xcm_version
      | pallet_xcm.pallet.Call.force_default_xcm_version
      | pallet_xcm.pallet.Call.force_subscribe_version_notify
      | pallet_xcm.pallet.Call.force_unsubscribe_version_notify
      | pallet_xcm.pallet.Call.limited_reserve_transfer_assets
      | pallet_xcm.pallet.Call.limited_teleport_assets
    export namespace Call {
      /**
       * Execute an XCM message from a local, signed, origin.
       *
       * An event is deposited indicating whether `msg` could be executed completely or only
       * partially.
       *
       * No more than `max_weight` will be used in its attempted execution. If this is less than the
       * maximum amount of weight that the message could take to be executed, then no execution
       * attempt will be made.
       *
       * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
       * to completion; only that *some* of it was executed.
       */
      export function execute(
        value: Omit<pallet_xcm.pallet.Call.execute, "type">,
      ): pallet_xcm.pallet.Call.execute {
        return { type: "execute", ...value }
      }
      /**
       * Execute an XCM message from a local, signed, origin.
       *
       * An event is deposited indicating whether `msg` could be executed completely or only
       * partially.
       *
       * No more than `max_weight` will be used in its attempted execution. If this is less than the
       * maximum amount of weight that the message could take to be executed, then no execution
       * attempt will be made.
       *
       * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
       * to completion; only that *some* of it was executed.
       */
      export interface execute {
        type: "execute"
        message: xcm.VersionedXcm
        max_weight: u64
      }
      /**
       * Set a safe XCM version (the version that XCM should be encoded with if the most recent
       * version a destination can accept is unknown).
       *
       * - `origin`: Must be Root.
       * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
       */
      export function force_default_xcm_version(
        value: Omit<pallet_xcm.pallet.Call.force_default_xcm_version, "type">,
      ): pallet_xcm.pallet.Call.force_default_xcm_version {
        return { type: "force_default_xcm_version", ...value }
      }
      /**
       * Set a safe XCM version (the version that XCM should be encoded with if the most recent
       * version a destination can accept is unknown).
       *
       * - `origin`: Must be Root.
       * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
       */
      export interface force_default_xcm_version {
        type: "force_default_xcm_version"
        maybe_xcm_version: u32 | undefined
      }
      /**
       * Ask a location to notify us regarding their XCM version and any changes to it.
       *
       * - `origin`: Must be Root.
       * - `location`: The location to which we should subscribe for XCM version notifications.
       */
      export function force_subscribe_version_notify(
        value: Omit<pallet_xcm.pallet.Call.force_subscribe_version_notify, "type">,
      ): pallet_xcm.pallet.Call.force_subscribe_version_notify {
        return { type: "force_subscribe_version_notify", ...value }
      }
      /**
       * Ask a location to notify us regarding their XCM version and any changes to it.
       *
       * - `origin`: Must be Root.
       * - `location`: The location to which we should subscribe for XCM version notifications.
       */
      export interface force_subscribe_version_notify {
        type: "force_subscribe_version_notify"
        location: xcm.VersionedMultiLocation
      }
      /**
       * Require that a particular destination should no longer notify us regarding any XCM
       * version changes.
       *
       * - `origin`: Must be Root.
       * - `location`: The location to which we are currently subscribed for XCM version
       *   notifications which we no longer desire.
       */
      export function force_unsubscribe_version_notify(
        value: Omit<pallet_xcm.pallet.Call.force_unsubscribe_version_notify, "type">,
      ): pallet_xcm.pallet.Call.force_unsubscribe_version_notify {
        return { type: "force_unsubscribe_version_notify", ...value }
      }
      /**
       * Require that a particular destination should no longer notify us regarding any XCM
       * version changes.
       *
       * - `origin`: Must be Root.
       * - `location`: The location to which we are currently subscribed for XCM version
       *   notifications which we no longer desire.
       */
      export interface force_unsubscribe_version_notify {
        type: "force_unsubscribe_version_notify"
        location: xcm.VersionedMultiLocation
      }
      /**
       * Extoll that a particular destination can be communicated with through a particular
       * version of XCM.
       *
       * - `origin`: Must be Root.
       * - `location`: The destination that is being described.
       * - `xcm_version`: The latest version of XCM that `location` supports.
       */
      export function force_xcm_version(
        value: Omit<pallet_xcm.pallet.Call.force_xcm_version, "type">,
      ): pallet_xcm.pallet.Call.force_xcm_version {
        return { type: "force_xcm_version", ...value }
      }
      /**
       * Extoll that a particular destination can be communicated with through a particular
       * version of XCM.
       *
       * - `origin`: Must be Root.
       * - `location`: The destination that is being described.
       * - `xcm_version`: The latest version of XCM that `location` supports.
       */
      export interface force_xcm_version {
        type: "force_xcm_version"
        location: xcm.v1.multilocation.MultiLocation
        xcm_version: u32
      }
      /**
       * Transfer some assets from the local chain to the sovereign account of a destination
       * chain and forward a notification XCM.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
       * is needed than `weight_limit`, then the operation will fail and the assets send may be
       * at risk.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
       *   `dest` side.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
       */
      export function limited_reserve_transfer_assets(
        value: Omit<pallet_xcm.pallet.Call.limited_reserve_transfer_assets, "type">,
      ): pallet_xcm.pallet.Call.limited_reserve_transfer_assets {
        return { type: "limited_reserve_transfer_assets", ...value }
      }
      /**
       * Transfer some assets from the local chain to the sovereign account of a destination
       * chain and forward a notification XCM.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
       * is needed than `weight_limit`, then the operation will fail and the assets send may be
       * at risk.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
       *   `dest` side.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
       */
      export interface limited_reserve_transfer_assets {
        type: "limited_reserve_transfer_assets"
        dest: xcm.VersionedMultiLocation
        beneficiary: xcm.VersionedMultiLocation
        assets: xcm.VersionedMultiAssets
        fee_asset_item: u32
        weight_limit: xcm.v2.WeightLimit
      }
      /**
       * Teleport some assets from the local chain to some destination chain.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
       * is needed than `weight_limit`, then the operation will fail and the assets send may be
       * at risk.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
       *   `dest` side. May not be empty.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
       */
      export function limited_teleport_assets(
        value: Omit<pallet_xcm.pallet.Call.limited_teleport_assets, "type">,
      ): pallet_xcm.pallet.Call.limited_teleport_assets {
        return { type: "limited_teleport_assets", ...value }
      }
      /**
       * Teleport some assets from the local chain to some destination chain.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
       * is needed than `weight_limit`, then the operation will fail and the assets send may be
       * at risk.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
       *   `dest` side. May not be empty.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
       */
      export interface limited_teleport_assets {
        type: "limited_teleport_assets"
        dest: xcm.VersionedMultiLocation
        beneficiary: xcm.VersionedMultiLocation
        assets: xcm.VersionedMultiAssets
        fee_asset_item: u32
        weight_limit: xcm.v2.WeightLimit
      }
      /**
       * Transfer some assets from the local chain to the sovereign account of a destination
       * chain and forward a notification XCM.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
       * with all fees taken as needed from the asset.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
       *   `dest` side.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       */
      export function reserve_transfer_assets(
        value: Omit<pallet_xcm.pallet.Call.reserve_transfer_assets, "type">,
      ): pallet_xcm.pallet.Call.reserve_transfer_assets {
        return { type: "reserve_transfer_assets", ...value }
      }
      /**
       * Transfer some assets from the local chain to the sovereign account of a destination
       * chain and forward a notification XCM.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
       * with all fees taken as needed from the asset.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
       *   `dest` side.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       */
      export interface reserve_transfer_assets {
        type: "reserve_transfer_assets"
        dest: xcm.VersionedMultiLocation
        beneficiary: xcm.VersionedMultiLocation
        assets: xcm.VersionedMultiAssets
        fee_asset_item: u32
      }
      export function send(
        value: Omit<pallet_xcm.pallet.Call.send, "type">,
      ): pallet_xcm.pallet.Call.send {
        return { type: "send", ...value }
      }
      export interface send {
        type: "send"
        dest: xcm.VersionedMultiLocation
        message: xcm.VersionedXcm
      }
      /**
       * Teleport some assets from the local chain to some destination chain.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
       * with all fees taken as needed from the asset.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
       *   `dest` side. May not be empty.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       */
      export function teleport_assets(
        value: Omit<pallet_xcm.pallet.Call.teleport_assets, "type">,
      ): pallet_xcm.pallet.Call.teleport_assets {
        return { type: "teleport_assets", ...value }
      }
      /**
       * Teleport some assets from the local chain to some destination chain.
       *
       * Fee payment on the destination side is made from the asset in the `assets` vector of
       * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
       * with all fees taken as needed from the asset.
       *
       * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
       * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
       *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
       * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
       *   an `AccountId32` value.
       * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
       *   `dest` side. May not be empty.
       * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
       *   fees.
       */
      export interface teleport_assets {
        type: "teleport_assets"
        dest: xcm.VersionedMultiLocation
        beneficiary: xcm.VersionedMultiLocation
        assets: xcm.VersionedMultiAssets
        fee_asset_item: u32
      }
    }
    /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
    export type Error =
      | "Unreachable"
      | "SendFailure"
      | "Filtered"
      | "UnweighableMessage"
      | "DestinationNotInvertible"
      | "Empty"
      | "CannotReanchor"
      | "TooManyAssets"
      | "InvalidOrigin"
      | "BadVersion"
      | "BadLocation"
      | "NoSubscription"
      | "AlreadySubscribed"
    /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
    export type Event =
      | pallet_xcm.pallet.Event.Attempted
      | pallet_xcm.pallet.Event.Sent
      | pallet_xcm.pallet.Event.UnexpectedResponse
      | pallet_xcm.pallet.Event.ResponseReady
      | pallet_xcm.pallet.Event.Notified
      | pallet_xcm.pallet.Event.NotifyOverweight
      | pallet_xcm.pallet.Event.NotifyDispatchError
      | pallet_xcm.pallet.Event.NotifyDecodeFailed
      | pallet_xcm.pallet.Event.InvalidResponder
      | pallet_xcm.pallet.Event.InvalidResponderVersion
      | pallet_xcm.pallet.Event.ResponseTaken
      | pallet_xcm.pallet.Event.AssetsTrapped
      | pallet_xcm.pallet.Event.VersionChangeNotified
      | pallet_xcm.pallet.Event.SupportedVersionChanged
      | pallet_xcm.pallet.Event.NotifyTargetSendFail
      | pallet_xcm.pallet.Event.NotifyTargetMigrationFail
      | pallet_xcm.pallet.Event.AssetsClaimed
    export namespace Event {
      /**
       * Some assets have been claimed from an asset trap
       *
       * \[ hash, origin, assets \]
       */
      export function AssetsClaimed(
        ...value: pallet_xcm.pallet.Event.AssetsClaimed["value"]
      ): pallet_xcm.pallet.Event.AssetsClaimed {
        return { type: "AssetsClaimed", value }
      }
      /**
       * Some assets have been claimed from an asset trap
       *
       * \[ hash, origin, assets \]
       */
      export interface AssetsClaimed {
        type: "AssetsClaimed"
        value: [primitive_types.H256, xcm.v1.multilocation.MultiLocation, xcm.VersionedMultiAssets]
      }
      /**
       * Some assets have been placed in an asset trap.
       *
       * \[ hash, origin, assets \]
       */
      export function AssetsTrapped(
        ...value: pallet_xcm.pallet.Event.AssetsTrapped["value"]
      ): pallet_xcm.pallet.Event.AssetsTrapped {
        return { type: "AssetsTrapped", value }
      }
      /**
       * Some assets have been placed in an asset trap.
       *
       * \[ hash, origin, assets \]
       */
      export interface AssetsTrapped {
        type: "AssetsTrapped"
        value: [primitive_types.H256, xcm.v1.multilocation.MultiLocation, xcm.VersionedMultiAssets]
      }
      /**
       * Execution of an XCM message was attempted.
       *
       * \[ outcome \]
       */
      export function Attempted(
        value: pallet_xcm.pallet.Event.Attempted["value"],
      ): pallet_xcm.pallet.Event.Attempted {
        return { type: "Attempted", value }
      }
      /**
       * Execution of an XCM message was attempted.
       *
       * \[ outcome \]
       */
      export interface Attempted {
        type: "Attempted"
        value: xcm.v2.traits.Outcome
      }
      /**
       * Expected query response has been received but the origin location of the response does
       * not match that expected. The query remains registered for a later, valid, response to
       * be received and acted upon.
       *
       * \[ origin location, id, expected location \]
       */
      export function InvalidResponder(
        ...value: pallet_xcm.pallet.Event.InvalidResponder["value"]
      ): pallet_xcm.pallet.Event.InvalidResponder {
        return { type: "InvalidResponder", value }
      }
      /**
       * Expected query response has been received but the origin location of the response does
       * not match that expected. The query remains registered for a later, valid, response to
       * be received and acted upon.
       *
       * \[ origin location, id, expected location \]
       */
      export interface InvalidResponder {
        type: "InvalidResponder"
        value: [
          xcm.v1.multilocation.MultiLocation,
          u64,
          xcm.v1.multilocation.MultiLocation | undefined,
        ]
      }
      /**
       * Expected query response has been received but the expected origin location placed in
       * storage by this runtime previously cannot be decoded. The query remains registered.
       *
       * This is unexpected (since a location placed in storage in a previously executing
       * runtime should be readable prior to query timeout) and dangerous since the possibly
       * valid response will be dropped. Manual governance intervention is probably going to be
       * needed.
       *
       * \[ origin location, id \]
       */
      export function InvalidResponderVersion(
        ...value: pallet_xcm.pallet.Event.InvalidResponderVersion["value"]
      ): pallet_xcm.pallet.Event.InvalidResponderVersion {
        return { type: "InvalidResponderVersion", value }
      }
      /**
       * Expected query response has been received but the expected origin location placed in
       * storage by this runtime previously cannot be decoded. The query remains registered.
       *
       * This is unexpected (since a location placed in storage in a previously executing
       * runtime should be readable prior to query timeout) and dangerous since the possibly
       * valid response will be dropped. Manual governance intervention is probably going to be
       * needed.
       *
       * \[ origin location, id \]
       */
      export interface InvalidResponderVersion {
        type: "InvalidResponderVersion"
        value: [xcm.v1.multilocation.MultiLocation, u64]
      }
      /**
       * Query response has been received and query is removed. The registered notification has
       * been dispatched and executed successfully.
       *
       * \[ id, pallet index, call index \]
       */
      export function Notified(
        ...value: pallet_xcm.pallet.Event.Notified["value"]
      ): pallet_xcm.pallet.Event.Notified {
        return { type: "Notified", value }
      }
      /**
       * Query response has been received and query is removed. The registered notification has
       * been dispatched and executed successfully.
       *
       * \[ id, pallet index, call index \]
       */
      export interface Notified {
        type: "Notified"
        value: [u64, u8, u8]
      }
      /**
       * Query response has been received and query is removed. The dispatch was unable to be
       * decoded into a `Call`; this might be due to dispatch function having a signature which
       * is not `(origin, QueryId, Response)`.
       *
       * \[ id, pallet index, call index \]
       */
      export function NotifyDecodeFailed(
        ...value: pallet_xcm.pallet.Event.NotifyDecodeFailed["value"]
      ): pallet_xcm.pallet.Event.NotifyDecodeFailed {
        return { type: "NotifyDecodeFailed", value }
      }
      /**
       * Query response has been received and query is removed. The dispatch was unable to be
       * decoded into a `Call`; this might be due to dispatch function having a signature which
       * is not `(origin, QueryId, Response)`.
       *
       * \[ id, pallet index, call index \]
       */
      export interface NotifyDecodeFailed {
        type: "NotifyDecodeFailed"
        value: [u64, u8, u8]
      }
      /**
       * Query response has been received and query is removed. There was a general error with
       * dispatching the notification call.
       *
       * \[ id, pallet index, call index \]
       */
      export function NotifyDispatchError(
        ...value: pallet_xcm.pallet.Event.NotifyDispatchError["value"]
      ): pallet_xcm.pallet.Event.NotifyDispatchError {
        return { type: "NotifyDispatchError", value }
      }
      /**
       * Query response has been received and query is removed. There was a general error with
       * dispatching the notification call.
       *
       * \[ id, pallet index, call index \]
       */
      export interface NotifyDispatchError {
        type: "NotifyDispatchError"
        value: [u64, u8, u8]
      }
      /**
       * Query response has been received and query is removed. The registered notification could
       * not be dispatched because the dispatch weight is greater than the maximum weight
       * originally budgeted by this runtime for the query result.
       *
       * \[ id, pallet index, call index, actual weight, max budgeted weight \]
       */
      export function NotifyOverweight(
        ...value: pallet_xcm.pallet.Event.NotifyOverweight["value"]
      ): pallet_xcm.pallet.Event.NotifyOverweight {
        return { type: "NotifyOverweight", value }
      }
      /**
       * Query response has been received and query is removed. The registered notification could
       * not be dispatched because the dispatch weight is greater than the maximum weight
       * originally budgeted by this runtime for the query result.
       *
       * \[ id, pallet index, call index, actual weight, max budgeted weight \]
       */
      export interface NotifyOverweight {
        type: "NotifyOverweight"
        value: [u64, u8, u8, sp_weights.weight_v2.Weight, sp_weights.weight_v2.Weight]
      }
      /**
       * A given location which had a version change subscription was dropped owing to an error
       * migrating the location to our new XCM format.
       *
       * \[ location, query ID \]
       */
      export function NotifyTargetMigrationFail(
        ...value: pallet_xcm.pallet.Event.NotifyTargetMigrationFail["value"]
      ): pallet_xcm.pallet.Event.NotifyTargetMigrationFail {
        return { type: "NotifyTargetMigrationFail", value }
      }
      /**
       * A given location which had a version change subscription was dropped owing to an error
       * migrating the location to our new XCM format.
       *
       * \[ location, query ID \]
       */
      export interface NotifyTargetMigrationFail {
        type: "NotifyTargetMigrationFail"
        value: [xcm.VersionedMultiLocation, u64]
      }
      /**
       * A given location which had a version change subscription was dropped owing to an error
       * sending the notification to it.
       *
       * \[ location, query ID, error \]
       */
      export function NotifyTargetSendFail(
        ...value: pallet_xcm.pallet.Event.NotifyTargetSendFail["value"]
      ): pallet_xcm.pallet.Event.NotifyTargetSendFail {
        return { type: "NotifyTargetSendFail", value }
      }
      /**
       * A given location which had a version change subscription was dropped owing to an error
       * sending the notification to it.
       *
       * \[ location, query ID, error \]
       */
      export interface NotifyTargetSendFail {
        type: "NotifyTargetSendFail"
        value: [xcm.v1.multilocation.MultiLocation, u64, xcm.v2.traits.Error]
      }
      /**
       * Query response has been received and is ready for taking with `take_response`. There is
       * no registered notification call.
       *
       * \[ id, response \]
       */
      export function ResponseReady(
        ...value: pallet_xcm.pallet.Event.ResponseReady["value"]
      ): pallet_xcm.pallet.Event.ResponseReady {
        return { type: "ResponseReady", value }
      }
      /**
       * Query response has been received and is ready for taking with `take_response`. There is
       * no registered notification call.
       *
       * \[ id, response \]
       */
      export interface ResponseReady {
        type: "ResponseReady"
        value: [u64, xcm.v2.Response]
      }
      /**
       * Received query response has been read and removed.
       *
       * \[ id \]
       */
      export function ResponseTaken(
        value: pallet_xcm.pallet.Event.ResponseTaken["value"],
      ): pallet_xcm.pallet.Event.ResponseTaken {
        return { type: "ResponseTaken", value }
      }
      /**
       * Received query response has been read and removed.
       *
       * \[ id \]
       */
      export interface ResponseTaken {
        type: "ResponseTaken"
        value: u64
      }
      /**
       * A XCM message was sent.
       *
       * \[ origin, destination, message \]
       */
      export function Sent(
        ...value: pallet_xcm.pallet.Event.Sent["value"]
      ): pallet_xcm.pallet.Event.Sent {
        return { type: "Sent", value }
      }
      /**
       * A XCM message was sent.
       *
       * \[ origin, destination, message \]
       */
      export interface Sent {
        type: "Sent"
        value: [
          xcm.v1.multilocation.MultiLocation,
          xcm.v1.multilocation.MultiLocation,
          Array<xcm.v2.Instruction>,
        ]
      }
      /**
       * The supported version of a location has been changed. This might be through an
       * automatic notification or a manual intervention.
       *
       * \[ location, XCM version \]
       */
      export function SupportedVersionChanged(
        ...value: pallet_xcm.pallet.Event.SupportedVersionChanged["value"]
      ): pallet_xcm.pallet.Event.SupportedVersionChanged {
        return { type: "SupportedVersionChanged", value }
      }
      /**
       * The supported version of a location has been changed. This might be through an
       * automatic notification or a manual intervention.
       *
       * \[ location, XCM version \]
       */
      export interface SupportedVersionChanged {
        type: "SupportedVersionChanged"
        value: [xcm.v1.multilocation.MultiLocation, u32]
      }
      /**
       * Query response received which does not match a registered query. This may be because a
       * matching query was never registered, it may be because it is a duplicate response, or
       * because the query timed out.
       *
       * \[ origin location, id \]
       */
      export function UnexpectedResponse(
        ...value: pallet_xcm.pallet.Event.UnexpectedResponse["value"]
      ): pallet_xcm.pallet.Event.UnexpectedResponse {
        return { type: "UnexpectedResponse", value }
      }
      /**
       * Query response received which does not match a registered query. This may be because a
       * matching query was never registered, it may be because it is a duplicate response, or
       * because the query timed out.
       *
       * \[ origin location, id \]
       */
      export interface UnexpectedResponse {
        type: "UnexpectedResponse"
        value: [xcm.v1.multilocation.MultiLocation, u64]
      }
      /**
       * An XCM version change notification message has been attempted to be sent.
       *
       * \[ destination, result \]
       */
      export function VersionChangeNotified(
        ...value: pallet_xcm.pallet.Event.VersionChangeNotified["value"]
      ): pallet_xcm.pallet.Event.VersionChangeNotified {
        return { type: "VersionChangeNotified", value }
      }
      /**
       * An XCM version change notification message has been attempted to be sent.
       *
       * \[ destination, result \]
       */
      export interface VersionChangeNotified {
        type: "VersionChangeNotified"
        value: [xcm.v1.multilocation.MultiLocation, u32]
      }
    }
    export type Origin = pallet_xcm.pallet.Origin.Xcm | pallet_xcm.pallet.Origin.Response
    export namespace Origin {
      export function Response(
        value: pallet_xcm.pallet.Origin.Response["value"],
      ): pallet_xcm.pallet.Origin.Response {
        return { type: "Response", value }
      }
      export interface Response {
        type: "Response"
        value: xcm.v1.multilocation.MultiLocation
      }
      export function Xcm(
        value: pallet_xcm.pallet.Origin.Xcm["value"],
      ): pallet_xcm.pallet.Origin.Xcm {
        return { type: "Xcm", value }
      }
      export interface Xcm {
        type: "Xcm"
        value: xcm.v1.multilocation.MultiLocation
      }
    }
    export type QueryStatus =
      | pallet_xcm.pallet.QueryStatus.Pending
      | pallet_xcm.pallet.QueryStatus.VersionNotifier
      | pallet_xcm.pallet.QueryStatus.Ready
    export namespace QueryStatus {
      export function Pending(
        value: Omit<pallet_xcm.pallet.QueryStatus.Pending, "type">,
      ): pallet_xcm.pallet.QueryStatus.Pending {
        return { type: "Pending", ...value }
      }
      export interface Pending {
        type: "Pending"
        responder: xcm.VersionedMultiLocation
        maybe_notify: [u8, u8] | undefined
        timeout: u32
      }
      export function Ready(
        value: Omit<pallet_xcm.pallet.QueryStatus.Ready, "type">,
      ): pallet_xcm.pallet.QueryStatus.Ready {
        return { type: "Ready", ...value }
      }
      export interface Ready {
        type: "Ready"
        response: xcm.VersionedResponse
        at: u32
      }
      export function VersionNotifier(
        value: Omit<pallet_xcm.pallet.QueryStatus.VersionNotifier, "type">,
      ): pallet_xcm.pallet.QueryStatus.VersionNotifier {
        return { type: "VersionNotifier", ...value }
      }
      export interface VersionNotifier {
        type: "VersionNotifier"
        origin: xcm.VersionedMultiLocation
        is_active: boolean
      }
    }
    export type VersionMigrationStage =
      | pallet_xcm.pallet.VersionMigrationStage.MigrateSupportedVersion
      | pallet_xcm.pallet.VersionMigrationStage.MigrateVersionNotifiers
      | pallet_xcm.pallet.VersionMigrationStage.NotifyCurrentTargets
      | pallet_xcm.pallet.VersionMigrationStage.MigrateAndNotifyOldTargets
    export namespace VersionMigrationStage {
      export function MigrateAndNotifyOldTargets(): pallet_xcm.pallet.VersionMigrationStage.MigrateAndNotifyOldTargets {
        return { type: "MigrateAndNotifyOldTargets" }
      }
      export interface MigrateAndNotifyOldTargets {
        type: "MigrateAndNotifyOldTargets"
      }
      export function MigrateSupportedVersion(): pallet_xcm.pallet.VersionMigrationStage.MigrateSupportedVersion {
        return { type: "MigrateSupportedVersion" }
      }
      export interface MigrateSupportedVersion {
        type: "MigrateSupportedVersion"
      }
      export function MigrateVersionNotifiers(): pallet_xcm.pallet.VersionMigrationStage.MigrateVersionNotifiers {
        return { type: "MigrateVersionNotifiers" }
      }
      export interface MigrateVersionNotifiers {
        type: "MigrateVersionNotifiers"
      }
      export function NotifyCurrentTargets(
        value: pallet_xcm.pallet.VersionMigrationStage.NotifyCurrentTargets["value"],
      ): pallet_xcm.pallet.VersionMigrationStage.NotifyCurrentTargets {
        return { type: "NotifyCurrentTargets", value }
      }
      export interface NotifyCurrentTargets {
        type: "NotifyCurrentTargets"
        value: Uint8Array | undefined
      }
    }
  }
}
export namespace polkadot_core_primitives {
  export const $candidateHash: $.Codec<polkadot_core_primitives.CandidateHash> = _codec.$114
  export const $inboundDownwardMessage: $.Codec<polkadot_core_primitives.InboundDownwardMessage> =
    _codec.$683
  export const $inboundHrmpMessage: $.Codec<polkadot_core_primitives.InboundHrmpMessage> =
    _codec.$691
  export const $outboundHrmpMessage: $.Codec<polkadot_core_primitives.OutboundHrmpMessage> =
    _codec.$392
  export type CandidateHash = primitive_types.H256
  export function CandidateHash(value: polkadot_core_primitives.CandidateHash) {
    return value
  }
  export interface InboundDownwardMessage {
    sent_at: u32
    msg: Uint8Array
  }
  export function InboundDownwardMessage(value: polkadot_core_primitives.InboundDownwardMessage) {
    return value
  }
  export interface InboundHrmpMessage {
    sent_at: u32
    data: Uint8Array
  }
  export function InboundHrmpMessage(value: polkadot_core_primitives.InboundHrmpMessage) {
    return value
  }
  export interface OutboundHrmpMessage {
    recipient: polkadot_parachain.primitives.Id
    data: Uint8Array
  }
  export function OutboundHrmpMessage(value: polkadot_core_primitives.OutboundHrmpMessage) {
    return value
  }
}
export namespace polkadot_parachain {
  export namespace primitives {
    export const $headData: $.Codec<polkadot_parachain.primitives.HeadData> = _codec.$104
    export const $hrmpChannelId: $.Codec<polkadot_parachain.primitives.HrmpChannelId> = _codec.$112
    export const $id: $.Codec<polkadot_parachain.primitives.Id> = _codec.$98
    export const $validationCode: $.Codec<polkadot_parachain.primitives.ValidationCode> =
      _codec.$394
    export const $validationCodeHash: $.Codec<polkadot_parachain.primitives.ValidationCodeHash> =
      _codec.$103
    export type HeadData = Uint8Array
    export function HeadData(value: polkadot_parachain.primitives.HeadData) {
      return value
    }
    export interface HrmpChannelId {
      sender: polkadot_parachain.primitives.Id
      recipient: polkadot_parachain.primitives.Id
    }
    export function HrmpChannelId(value: polkadot_parachain.primitives.HrmpChannelId) {
      return value
    }
    export type Id = u32
    export function Id(value: polkadot_parachain.primitives.Id) {
      return value
    }
    export type ValidationCode = Uint8Array
    export function ValidationCode(value: polkadot_parachain.primitives.ValidationCode) {
      return value
    }
    export type ValidationCodeHash = primitive_types.H256
    export function ValidationCodeHash(value: polkadot_parachain.primitives.ValidationCodeHash) {
      return value
    }
  }
}
export namespace polkadot_primitives {
  export namespace v2 {
    export const $availabilityBitfield: $.Codec<polkadot_primitives.v2.AvailabilityBitfield> =
      _codec.$382
    export const $backedCandidate: $.Codec<polkadot_primitives.v2.BackedCandidate> = _codec.$388
    export const $candidateCommitments: $.Codec<polkadot_primitives.v2.CandidateCommitments> =
      _codec.$390
    export const $candidateDescriptor: $.Codec<polkadot_primitives.v2.CandidateDescriptor> =
      _codec.$97
    export const $candidateReceipt: $.Codec<polkadot_primitives.v2.CandidateReceipt> = _codec.$96
    export const $committedCandidateReceipt: $.Codec<
      polkadot_primitives.v2.CommittedCandidateReceipt
    > = _codec.$389
    export const $coreIndex: $.Codec<polkadot_primitives.v2.CoreIndex> = _codec.$105
    export const $coreOccupied: $.Codec<polkadot_primitives.v2.CoreOccupied> = _codec.$661
    export const $disputeState: $.Codec<polkadot_primitives.v2.DisputeState> = _codec.$699
    export const $disputeStatement: $.Codec<polkadot_primitives.v2.DisputeStatement> = _codec.$401
    export const $disputeStatementSet: $.Codec<polkadot_primitives.v2.DisputeStatementSet> =
      _codec.$398
    export const $groupIndex: $.Codec<polkadot_primitives.v2.GroupIndex> = _codec.$106
    export const $inherentData: $.Codec<polkadot_primitives.v2.InherentData> = _codec.$379
    export const $invalidDisputeStatementKind: $.Codec<
      polkadot_primitives.v2.InvalidDisputeStatementKind
    > = _codec.$403
    export const $parathreadClaim: $.Codec<polkadot_primitives.v2.ParathreadClaim> = _codec.$658
    export const $parathreadEntry: $.Codec<polkadot_primitives.v2.ParathreadEntry> = _codec.$657
    export const $pvfCheckStatement: $.Codec<polkadot_primitives.v2.PvfCheckStatement> = _codec.$405
    export const $scrapedOnChainVotes: $.Codec<polkadot_primitives.v2.ScrapedOnChainVotes> =
      _codec.$647
    export const $sessionInfo: $.Codec<polkadot_primitives.v2.SessionInfo> = _codec.$696
    export const $upgradeGoAhead: $.Codec<polkadot_primitives.v2.UpgradeGoAhead> = _codec.$676
    export const $upgradeRestriction: $.Codec<polkadot_primitives.v2.UpgradeRestriction> =
      _codec.$677
    export const $validDisputeStatementKind: $.Codec<
      polkadot_primitives.v2.ValidDisputeStatementKind
    > = _codec.$402
    export const $validatorIndex: $.Codec<polkadot_primitives.v2.ValidatorIndex> = _codec.$385
    export const $validityAttestation: $.Codec<polkadot_primitives.v2.ValidityAttestation> =
      _codec.$396
    export type AvailabilityBitfield = BitSequence
    export function AvailabilityBitfield(value: polkadot_primitives.v2.AvailabilityBitfield) {
      return value
    }
    export interface BackedCandidate {
      candidate: polkadot_primitives.v2.CommittedCandidateReceipt
      validity_votes: Array<polkadot_primitives.v2.ValidityAttestation>
      validator_indices: BitSequence
    }
    export function BackedCandidate(value: polkadot_primitives.v2.BackedCandidate) {
      return value
    }
    export interface CandidateCommitments {
      upward_messages: Array<Uint8Array>
      horizontal_messages: Array<polkadot_core_primitives.OutboundHrmpMessage>
      new_validation_code: polkadot_parachain.primitives.ValidationCode | undefined
      head_data: polkadot_parachain.primitives.HeadData
      processed_downward_messages: u32
      hrmp_watermark: u32
    }
    export function CandidateCommitments(value: polkadot_primitives.v2.CandidateCommitments) {
      return value
    }
    export interface CandidateDescriptor {
      para_id: polkadot_parachain.primitives.Id
      relay_parent: primitive_types.H256
      collator: polkadot_primitives.v2.collator_app.Public
      persisted_validation_data_hash: primitive_types.H256
      pov_hash: primitive_types.H256
      erasure_root: primitive_types.H256
      signature: polkadot_primitives.v2.collator_app.Signature
      para_head: primitive_types.H256
      validation_code_hash: polkadot_parachain.primitives.ValidationCodeHash
    }
    export function CandidateDescriptor(value: polkadot_primitives.v2.CandidateDescriptor) {
      return value
    }
    export interface CandidateReceipt {
      descriptor: polkadot_primitives.v2.CandidateDescriptor
      commitments_hash: primitive_types.H256
    }
    export function CandidateReceipt(value: polkadot_primitives.v2.CandidateReceipt) {
      return value
    }
    export interface CommittedCandidateReceipt {
      descriptor: polkadot_primitives.v2.CandidateDescriptor
      commitments: polkadot_primitives.v2.CandidateCommitments
    }
    export function CommittedCandidateReceipt(
      value: polkadot_primitives.v2.CommittedCandidateReceipt,
    ) {
      return value
    }
    export type CoreIndex = u32
    export function CoreIndex(value: polkadot_primitives.v2.CoreIndex) {
      return value
    }
    export type CoreOccupied =
      | polkadot_primitives.v2.CoreOccupied.Parathread
      | polkadot_primitives.v2.CoreOccupied.Parachain
    export namespace CoreOccupied {
      export function Parachain(): polkadot_primitives.v2.CoreOccupied.Parachain {
        return { type: "Parachain" }
      }
      export interface Parachain {
        type: "Parachain"
      }
      export function Parathread(
        value: polkadot_primitives.v2.CoreOccupied.Parathread["value"],
      ): polkadot_primitives.v2.CoreOccupied.Parathread {
        return { type: "Parathread", value }
      }
      export interface Parathread {
        type: "Parathread"
        value: polkadot_primitives.v2.ParathreadEntry
      }
    }
    export interface DisputeState {
      validators_for: BitSequence
      validators_against: BitSequence
      start: u32
      concluded_at: u32 | undefined
    }
    export function DisputeState(value: polkadot_primitives.v2.DisputeState) {
      return value
    }
    export type DisputeStatement =
      | polkadot_primitives.v2.DisputeStatement.Valid
      | polkadot_primitives.v2.DisputeStatement.Invalid
    export namespace DisputeStatement {
      export function Invalid(
        value: polkadot_primitives.v2.DisputeStatement.Invalid["value"],
      ): polkadot_primitives.v2.DisputeStatement.Invalid {
        return { type: "Invalid", value }
      }
      export interface Invalid {
        type: "Invalid"
        value: polkadot_primitives.v2.InvalidDisputeStatementKind
      }
      export function Valid(
        value: polkadot_primitives.v2.DisputeStatement.Valid["value"],
      ): polkadot_primitives.v2.DisputeStatement.Valid {
        return { type: "Valid", value }
      }
      export interface Valid {
        type: "Valid"
        value: polkadot_primitives.v2.ValidDisputeStatementKind
      }
    }
    export interface DisputeStatementSet {
      candidate_hash: polkadot_core_primitives.CandidateHash
      session: u32
      statements: Array<
        [
          polkadot_primitives.v2.DisputeStatement,
          polkadot_primitives.v2.ValidatorIndex,
          polkadot_primitives.v2.validator_app.Signature,
        ]
      >
    }
    export function DisputeStatementSet(value: polkadot_primitives.v2.DisputeStatementSet) {
      return value
    }
    export type GroupIndex = u32
    export function GroupIndex(value: polkadot_primitives.v2.GroupIndex) {
      return value
    }
    export interface InherentData {
      bitfields: Array<polkadot_primitives.v2.signed.UncheckedSigned>
      backed_candidates: Array<polkadot_primitives.v2.BackedCandidate>
      disputes: Array<polkadot_primitives.v2.DisputeStatementSet>
      parent_header: sp_runtime.generic.header.Header
    }
    export function InherentData(value: polkadot_primitives.v2.InherentData) {
      return value
    }
    export type InvalidDisputeStatementKind = "Explicit"
    export type ParathreadClaim = [
      polkadot_parachain.primitives.Id,
      polkadot_primitives.v2.collator_app.Public,
    ]
    export function ParathreadClaim(...value: polkadot_primitives.v2.ParathreadClaim) {
      return value
    }
    export interface ParathreadEntry {
      claim: polkadot_primitives.v2.ParathreadClaim
      retries: u32
    }
    export function ParathreadEntry(value: polkadot_primitives.v2.ParathreadEntry) {
      return value
    }
    export interface PvfCheckStatement {
      accept: boolean
      subject: polkadot_parachain.primitives.ValidationCodeHash
      session_index: u32
      validator_index: polkadot_primitives.v2.ValidatorIndex
    }
    export function PvfCheckStatement(value: polkadot_primitives.v2.PvfCheckStatement) {
      return value
    }
    export interface ScrapedOnChainVotes {
      session: u32
      backing_validators_per_candidate: Array<
        [
          polkadot_primitives.v2.CandidateReceipt,
          Array<
            [polkadot_primitives.v2.ValidatorIndex, polkadot_primitives.v2.ValidityAttestation]
          >,
        ]
      >
      disputes: Array<polkadot_primitives.v2.DisputeStatementSet>
    }
    export function ScrapedOnChainVotes(value: polkadot_primitives.v2.ScrapedOnChainVotes) {
      return value
    }
    export interface SessionInfo {
      active_validator_indices: Array<polkadot_primitives.v2.ValidatorIndex>
      random_seed: Uint8Array
      dispute_period: u32
      validators: Array<polkadot_primitives.v2.validator_app.Public>
      discovery_keys: Array<sp_authority_discovery.app.Public>
      assignment_keys: Array<polkadot_primitives.v2.assignment_app.Public>
      validator_groups: Array<Array<polkadot_primitives.v2.ValidatorIndex>>
      n_cores: u32
      zeroth_delay_tranche_width: u32
      relay_vrf_modulo_samples: u32
      n_delay_tranches: u32
      no_show_slots: u32
      needed_approvals: u32
    }
    export function SessionInfo(value: polkadot_primitives.v2.SessionInfo) {
      return value
    }
    export type UpgradeGoAhead = "Abort" | "GoAhead"
    export type UpgradeRestriction = "Present"
    export type ValidDisputeStatementKind =
      | polkadot_primitives.v2.ValidDisputeStatementKind.Explicit
      | polkadot_primitives.v2.ValidDisputeStatementKind.BackingSeconded
      | polkadot_primitives.v2.ValidDisputeStatementKind.BackingValid
      | polkadot_primitives.v2.ValidDisputeStatementKind.ApprovalChecking
    export namespace ValidDisputeStatementKind {
      export function ApprovalChecking(): polkadot_primitives.v2.ValidDisputeStatementKind.ApprovalChecking {
        return { type: "ApprovalChecking" }
      }
      export interface ApprovalChecking {
        type: "ApprovalChecking"
      }
      export function BackingSeconded(
        value: polkadot_primitives.v2.ValidDisputeStatementKind.BackingSeconded["value"],
      ): polkadot_primitives.v2.ValidDisputeStatementKind.BackingSeconded {
        return { type: "BackingSeconded", value }
      }
      export interface BackingSeconded {
        type: "BackingSeconded"
        value: primitive_types.H256
      }
      export function BackingValid(
        value: polkadot_primitives.v2.ValidDisputeStatementKind.BackingValid["value"],
      ): polkadot_primitives.v2.ValidDisputeStatementKind.BackingValid {
        return { type: "BackingValid", value }
      }
      export interface BackingValid {
        type: "BackingValid"
        value: primitive_types.H256
      }
      export function Explicit(): polkadot_primitives.v2.ValidDisputeStatementKind.Explicit {
        return { type: "Explicit" }
      }
      export interface Explicit {
        type: "Explicit"
      }
    }
    export type ValidatorIndex = u32
    export function ValidatorIndex(value: polkadot_primitives.v2.ValidatorIndex) {
      return value
    }
    export type ValidityAttestation =
      | polkadot_primitives.v2.ValidityAttestation.Implicit
      | polkadot_primitives.v2.ValidityAttestation.Explicit
    export namespace ValidityAttestation {
      export function Explicit(
        value: polkadot_primitives.v2.ValidityAttestation.Explicit["value"],
      ): polkadot_primitives.v2.ValidityAttestation.Explicit {
        return { type: "Explicit", value }
      }
      export interface Explicit {
        type: "Explicit"
        value: polkadot_primitives.v2.validator_app.Signature
      }
      export function Implicit(
        value: polkadot_primitives.v2.ValidityAttestation.Implicit["value"],
      ): polkadot_primitives.v2.ValidityAttestation.Implicit {
        return { type: "Implicit", value }
      }
      export interface Implicit {
        type: "Implicit"
        value: polkadot_primitives.v2.validator_app.Signature
      }
    }
    export namespace assignment_app {
      export const $public: $.Codec<polkadot_primitives.v2.assignment_app.Public> = _codec.$214
      export type Public = sp_core.sr25519.Public
      export function Public(value: polkadot_primitives.v2.assignment_app.Public) {
        return value
      }
    }
    export namespace collator_app {
      export const $public: $.Codec<polkadot_primitives.v2.collator_app.Public> = _codec.$99
      export const $signature: $.Codec<polkadot_primitives.v2.collator_app.Signature> = _codec.$100
      export type Public = sp_core.sr25519.Public
      export function Public(value: polkadot_primitives.v2.collator_app.Public) {
        return value
      }
      export type Signature = sp_core.sr25519.Signature
      export function Signature(value: polkadot_primitives.v2.collator_app.Signature) {
        return value
      }
    }
    export namespace signed {
      export const $uncheckedSigned: $.Codec<polkadot_primitives.v2.signed.UncheckedSigned> =
        _codec.$381
      export interface UncheckedSigned {
        payload: polkadot_primitives.v2.AvailabilityBitfield
        validator_index: polkadot_primitives.v2.ValidatorIndex
        signature: polkadot_primitives.v2.validator_app.Signature
      }
      export function UncheckedSigned(value: polkadot_primitives.v2.signed.UncheckedSigned) {
        return value
      }
    }
    export namespace validator_app {
      export const $public: $.Codec<polkadot_primitives.v2.validator_app.Public> = _codec.$213
      export const $signature: $.Codec<polkadot_primitives.v2.validator_app.Signature> = _codec.$386
      export type Public = sp_core.sr25519.Public
      export function Public(value: polkadot_primitives.v2.validator_app.Public) {
        return value
      }
      export type Signature = sp_core.sr25519.Signature
      export function Signature(value: polkadot_primitives.v2.validator_app.Signature) {
        return value
      }
    }
  }
}
export namespace polkadot_runtime {
  export const $nposCompactSolution16: $.Codec<polkadot_runtime.NposCompactSolution16> = _codec.$312
  export const $originCaller: $.Codec<polkadot_runtime.OriginCaller> = _codec.$256
  export const $proxyType: $.Codec<polkadot_runtime.ProxyType> = _codec.$79
  export const $runtime: $.Codec<polkadot_runtime.Runtime> = _codec.$737
  export const $runtimeCall: $.Codec<polkadot_runtime.RuntimeCall> = _codec.$181
  export const $runtimeEvent: $.Codec<polkadot_runtime.RuntimeEvent> = _codec.$19
  export const $sessionKeys: $.Codec<polkadot_runtime.SessionKeys> = _codec.$212
  export interface NposCompactSolution16 {
    votes1: Array<[Compact<u32>, Compact<u16>]>
    votes2: Array<
      [Compact<u32>, [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>], Compact<u16>]
    >
    votes3: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes4: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes5: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes6: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes7: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes8: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes9: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes10: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes11: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes12: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes13: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes14: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes15: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
    votes16: Array<
      [
        Compact<u32>,
        [
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
          [Compact<u16>, Compact<sp_arithmetic.per_things.PerU16>],
        ],
        Compact<u16>,
      ]
    >
  }
  export function NposCompactSolution16(value: polkadot_runtime.NposCompactSolution16) {
    return value
  }
  export type OriginCaller =
    | polkadot_runtime.OriginCaller.system
    | polkadot_runtime.OriginCaller.Council
    | polkadot_runtime.OriginCaller.TechnicalCommittee
    | polkadot_runtime.OriginCaller.ParachainsOrigin
    | polkadot_runtime.OriginCaller.XcmPallet
    | polkadot_runtime.OriginCaller.Void
  export namespace OriginCaller {
    export function Council(
      value: polkadot_runtime.OriginCaller.Council["value"],
    ): polkadot_runtime.OriginCaller.Council {
      return { type: "Council", value }
    }
    export interface Council {
      type: "Council"
      value: pallet_collective.RawOrigin
    }
    export function ParachainsOrigin(
      value: polkadot_runtime.OriginCaller.ParachainsOrigin["value"],
    ): polkadot_runtime.OriginCaller.ParachainsOrigin {
      return { type: "ParachainsOrigin", value }
    }
    export interface ParachainsOrigin {
      type: "ParachainsOrigin"
      value: polkadot_runtime_parachains.origin.pallet.Origin
    }
    export function TechnicalCommittee(
      value: polkadot_runtime.OriginCaller.TechnicalCommittee["value"],
    ): polkadot_runtime.OriginCaller.TechnicalCommittee {
      return { type: "TechnicalCommittee", value }
    }
    export interface TechnicalCommittee {
      type: "TechnicalCommittee"
      value: pallet_collective.RawOrigin
    }
    export function Void(
      value: polkadot_runtime.OriginCaller.Void["value"],
    ): polkadot_runtime.OriginCaller.Void {
      return { type: "Void", value }
    }
    export interface Void {
      type: "Void"
      value: sp_core.Void
    }
    export function XcmPallet(
      value: polkadot_runtime.OriginCaller.XcmPallet["value"],
    ): polkadot_runtime.OriginCaller.XcmPallet {
      return { type: "XcmPallet", value }
    }
    export interface XcmPallet {
      type: "XcmPallet"
      value: pallet_xcm.pallet.Origin
    }
    export function system(
      value: polkadot_runtime.OriginCaller.system["value"],
    ): polkadot_runtime.OriginCaller.system {
      return { type: "system", value }
    }
    export interface system {
      type: "system"
      value: frame_support.dispatch.RawOrigin
    }
  }
  export type ProxyType =
    | "Any"
    | "NonTransfer"
    | "Governance"
    | "Staking"
    | "IdentityJudgement"
    | "CancelProxy"
    | "Auction"
  export function Runtime() {
    return null
  }
  export type Runtime = null
  export type RuntimeCall =
    | polkadot_runtime.RuntimeCall.System
    | polkadot_runtime.RuntimeCall.Scheduler
    | polkadot_runtime.RuntimeCall.Preimage
    | polkadot_runtime.RuntimeCall.Babe
    | polkadot_runtime.RuntimeCall.Timestamp
    | polkadot_runtime.RuntimeCall.Indices
    | polkadot_runtime.RuntimeCall.Balances
    | polkadot_runtime.RuntimeCall.Authorship
    | polkadot_runtime.RuntimeCall.Staking
    | polkadot_runtime.RuntimeCall.Session
    | polkadot_runtime.RuntimeCall.Grandpa
    | polkadot_runtime.RuntimeCall.ImOnline
    | polkadot_runtime.RuntimeCall.Democracy
    | polkadot_runtime.RuntimeCall.Council
    | polkadot_runtime.RuntimeCall.TechnicalCommittee
    | polkadot_runtime.RuntimeCall.PhragmenElection
    | polkadot_runtime.RuntimeCall.TechnicalMembership
    | polkadot_runtime.RuntimeCall.Treasury
    | polkadot_runtime.RuntimeCall.Claims
    | polkadot_runtime.RuntimeCall.Vesting
    | polkadot_runtime.RuntimeCall.Utility
    | polkadot_runtime.RuntimeCall.Identity
    | polkadot_runtime.RuntimeCall.Proxy
    | polkadot_runtime.RuntimeCall.Multisig
    | polkadot_runtime.RuntimeCall.Bounties
    | polkadot_runtime.RuntimeCall.ChildBounties
    | polkadot_runtime.RuntimeCall.Tips
    | polkadot_runtime.RuntimeCall.ElectionProviderMultiPhase
    | polkadot_runtime.RuntimeCall.VoterList
    | polkadot_runtime.RuntimeCall.NominationPools
    | polkadot_runtime.RuntimeCall.FastUnstake
    | polkadot_runtime.RuntimeCall.Configuration
    | polkadot_runtime.RuntimeCall.ParasShared
    | polkadot_runtime.RuntimeCall.ParaInclusion
    | polkadot_runtime.RuntimeCall.ParaInherent
    | polkadot_runtime.RuntimeCall.Paras
    | polkadot_runtime.RuntimeCall.Initializer
    | polkadot_runtime.RuntimeCall.Dmp
    | polkadot_runtime.RuntimeCall.Ump
    | polkadot_runtime.RuntimeCall.Hrmp
    | polkadot_runtime.RuntimeCall.ParasDisputes
    | polkadot_runtime.RuntimeCall.Registrar
    | polkadot_runtime.RuntimeCall.Slots
    | polkadot_runtime.RuntimeCall.Auctions
    | polkadot_runtime.RuntimeCall.Crowdloan
    | polkadot_runtime.RuntimeCall.XcmPallet
  export namespace RuntimeCall {
    export function Auctions(
      value: polkadot_runtime.RuntimeCall.Auctions["value"],
    ): polkadot_runtime.RuntimeCall.Auctions {
      return { type: "Auctions", value }
    }
    export interface Auctions {
      type: "Auctions"
      value: polkadot_runtime_common.auctions.pallet.Call
    }
    export function Authorship(
      value: polkadot_runtime.RuntimeCall.Authorship["value"],
    ): polkadot_runtime.RuntimeCall.Authorship {
      return { type: "Authorship", value }
    }
    export interface Authorship {
      type: "Authorship"
      value: pallet_authorship.pallet.Call
    }
    export function Babe(
      value: polkadot_runtime.RuntimeCall.Babe["value"],
    ): polkadot_runtime.RuntimeCall.Babe {
      return { type: "Babe", value }
    }
    export interface Babe {
      type: "Babe"
      value: pallet_babe.pallet.Call
    }
    export function Balances(
      value: polkadot_runtime.RuntimeCall.Balances["value"],
    ): polkadot_runtime.RuntimeCall.Balances {
      return { type: "Balances", value }
    }
    export interface Balances {
      type: "Balances"
      value: pallet_balances.pallet.Call
    }
    export function Bounties(
      value: polkadot_runtime.RuntimeCall.Bounties["value"],
    ): polkadot_runtime.RuntimeCall.Bounties {
      return { type: "Bounties", value }
    }
    export interface Bounties {
      type: "Bounties"
      value: pallet_bounties.pallet.Call
    }
    export function ChildBounties(
      value: polkadot_runtime.RuntimeCall.ChildBounties["value"],
    ): polkadot_runtime.RuntimeCall.ChildBounties {
      return { type: "ChildBounties", value }
    }
    export interface ChildBounties {
      type: "ChildBounties"
      value: pallet_child_bounties.pallet.Call
    }
    export function Claims(
      value: polkadot_runtime.RuntimeCall.Claims["value"],
    ): polkadot_runtime.RuntimeCall.Claims {
      return { type: "Claims", value }
    }
    export interface Claims {
      type: "Claims"
      value: polkadot_runtime_common.claims.pallet.Call
    }
    export function Configuration(
      value: polkadot_runtime.RuntimeCall.Configuration["value"],
    ): polkadot_runtime.RuntimeCall.Configuration {
      return { type: "Configuration", value }
    }
    export interface Configuration {
      type: "Configuration"
      value: polkadot_runtime_parachains.configuration.pallet.Call
    }
    export function Council(
      value: polkadot_runtime.RuntimeCall.Council["value"],
    ): polkadot_runtime.RuntimeCall.Council {
      return { type: "Council", value }
    }
    export interface Council {
      type: "Council"
      value: pallet_collective.pallet.Call
    }
    export function Crowdloan(
      value: polkadot_runtime.RuntimeCall.Crowdloan["value"],
    ): polkadot_runtime.RuntimeCall.Crowdloan {
      return { type: "Crowdloan", value }
    }
    export interface Crowdloan {
      type: "Crowdloan"
      value: polkadot_runtime_common.crowdloan.pallet.Call
    }
    export function Democracy(
      value: polkadot_runtime.RuntimeCall.Democracy["value"],
    ): polkadot_runtime.RuntimeCall.Democracy {
      return { type: "Democracy", value }
    }
    export interface Democracy {
      type: "Democracy"
      value: pallet_democracy.pallet.Call
    }
    export function Dmp(
      value: polkadot_runtime.RuntimeCall.Dmp["value"],
    ): polkadot_runtime.RuntimeCall.Dmp {
      return { type: "Dmp", value }
    }
    export interface Dmp {
      type: "Dmp"
      value: polkadot_runtime_parachains.dmp.pallet.Call
    }
    export function ElectionProviderMultiPhase(
      value: polkadot_runtime.RuntimeCall.ElectionProviderMultiPhase["value"],
    ): polkadot_runtime.RuntimeCall.ElectionProviderMultiPhase {
      return { type: "ElectionProviderMultiPhase", value }
    }
    export interface ElectionProviderMultiPhase {
      type: "ElectionProviderMultiPhase"
      value: pallet_election_provider_multi_phase.pallet.Call
    }
    export function FastUnstake(
      value: polkadot_runtime.RuntimeCall.FastUnstake["value"],
    ): polkadot_runtime.RuntimeCall.FastUnstake {
      return { type: "FastUnstake", value }
    }
    export interface FastUnstake {
      type: "FastUnstake"
      value: pallet_fast_unstake.pallet.Call
    }
    export function Grandpa(
      value: polkadot_runtime.RuntimeCall.Grandpa["value"],
    ): polkadot_runtime.RuntimeCall.Grandpa {
      return { type: "Grandpa", value }
    }
    export interface Grandpa {
      type: "Grandpa"
      value: pallet_grandpa.pallet.Call
    }
    export function Hrmp(
      value: polkadot_runtime.RuntimeCall.Hrmp["value"],
    ): polkadot_runtime.RuntimeCall.Hrmp {
      return { type: "Hrmp", value }
    }
    export interface Hrmp {
      type: "Hrmp"
      value: polkadot_runtime_parachains.hrmp.pallet.Call
    }
    export function Identity(
      value: polkadot_runtime.RuntimeCall.Identity["value"],
    ): polkadot_runtime.RuntimeCall.Identity {
      return { type: "Identity", value }
    }
    export interface Identity {
      type: "Identity"
      value: pallet_identity.pallet.Call
    }
    export function ImOnline(
      value: polkadot_runtime.RuntimeCall.ImOnline["value"],
    ): polkadot_runtime.RuntimeCall.ImOnline {
      return { type: "ImOnline", value }
    }
    export interface ImOnline {
      type: "ImOnline"
      value: pallet_im_online.pallet.Call
    }
    export function Indices(
      value: polkadot_runtime.RuntimeCall.Indices["value"],
    ): polkadot_runtime.RuntimeCall.Indices {
      return { type: "Indices", value }
    }
    export interface Indices {
      type: "Indices"
      value: pallet_indices.pallet.Call
    }
    export function Initializer(
      value: polkadot_runtime.RuntimeCall.Initializer["value"],
    ): polkadot_runtime.RuntimeCall.Initializer {
      return { type: "Initializer", value }
    }
    export interface Initializer {
      type: "Initializer"
      value: polkadot_runtime_parachains.initializer.pallet.Call
    }
    export function Multisig(
      value: polkadot_runtime.RuntimeCall.Multisig["value"],
    ): polkadot_runtime.RuntimeCall.Multisig {
      return { type: "Multisig", value }
    }
    export interface Multisig {
      type: "Multisig"
      value: pallet_multisig.pallet.Call
    }
    export function NominationPools(
      value: polkadot_runtime.RuntimeCall.NominationPools["value"],
    ): polkadot_runtime.RuntimeCall.NominationPools {
      return { type: "NominationPools", value }
    }
    export interface NominationPools {
      type: "NominationPools"
      value: pallet_nomination_pools.pallet.Call
    }
    export function ParaInclusion(
      value: polkadot_runtime.RuntimeCall.ParaInclusion["value"],
    ): polkadot_runtime.RuntimeCall.ParaInclusion {
      return { type: "ParaInclusion", value }
    }
    export interface ParaInclusion {
      type: "ParaInclusion"
      value: polkadot_runtime_parachains.inclusion.pallet.Call
    }
    export function ParaInherent(
      value: polkadot_runtime.RuntimeCall.ParaInherent["value"],
    ): polkadot_runtime.RuntimeCall.ParaInherent {
      return { type: "ParaInherent", value }
    }
    export interface ParaInherent {
      type: "ParaInherent"
      value: polkadot_runtime_parachains.paras_inherent.pallet.Call
    }
    export function Paras(
      value: polkadot_runtime.RuntimeCall.Paras["value"],
    ): polkadot_runtime.RuntimeCall.Paras {
      return { type: "Paras", value }
    }
    export interface Paras {
      type: "Paras"
      value: polkadot_runtime_parachains.paras.pallet.Call
    }
    export function ParasDisputes(
      value: polkadot_runtime.RuntimeCall.ParasDisputes["value"],
    ): polkadot_runtime.RuntimeCall.ParasDisputes {
      return { type: "ParasDisputes", value }
    }
    export interface ParasDisputes {
      type: "ParasDisputes"
      value: polkadot_runtime_parachains.disputes.pallet.Call
    }
    export function ParasShared(
      value: polkadot_runtime.RuntimeCall.ParasShared["value"],
    ): polkadot_runtime.RuntimeCall.ParasShared {
      return { type: "ParasShared", value }
    }
    export interface ParasShared {
      type: "ParasShared"
      value: polkadot_runtime_parachains.shared.pallet.Call
    }
    export function PhragmenElection(
      value: polkadot_runtime.RuntimeCall.PhragmenElection["value"],
    ): polkadot_runtime.RuntimeCall.PhragmenElection {
      return { type: "PhragmenElection", value }
    }
    export interface PhragmenElection {
      type: "PhragmenElection"
      value: pallet_elections_phragmen.pallet.Call
    }
    export function Preimage(
      value: polkadot_runtime.RuntimeCall.Preimage["value"],
    ): polkadot_runtime.RuntimeCall.Preimage {
      return { type: "Preimage", value }
    }
    export interface Preimage {
      type: "Preimage"
      value: pallet_preimage.pallet.Call
    }
    export function Proxy(
      value: polkadot_runtime.RuntimeCall.Proxy["value"],
    ): polkadot_runtime.RuntimeCall.Proxy {
      return { type: "Proxy", value }
    }
    export interface Proxy {
      type: "Proxy"
      value: pallet_proxy.pallet.Call
    }
    export function Registrar(
      value: polkadot_runtime.RuntimeCall.Registrar["value"],
    ): polkadot_runtime.RuntimeCall.Registrar {
      return { type: "Registrar", value }
    }
    export interface Registrar {
      type: "Registrar"
      value: polkadot_runtime_common.paras_registrar.pallet.Call
    }
    export function Scheduler(
      value: polkadot_runtime.RuntimeCall.Scheduler["value"],
    ): polkadot_runtime.RuntimeCall.Scheduler {
      return { type: "Scheduler", value }
    }
    export interface Scheduler {
      type: "Scheduler"
      value: pallet_scheduler.pallet.Call
    }
    export function Session(
      value: polkadot_runtime.RuntimeCall.Session["value"],
    ): polkadot_runtime.RuntimeCall.Session {
      return { type: "Session", value }
    }
    export interface Session {
      type: "Session"
      value: pallet_session.pallet.Call
    }
    export function Slots(
      value: polkadot_runtime.RuntimeCall.Slots["value"],
    ): polkadot_runtime.RuntimeCall.Slots {
      return { type: "Slots", value }
    }
    export interface Slots {
      type: "Slots"
      value: polkadot_runtime_common.slots.pallet.Call
    }
    export function Staking(
      value: polkadot_runtime.RuntimeCall.Staking["value"],
    ): polkadot_runtime.RuntimeCall.Staking {
      return { type: "Staking", value }
    }
    export interface Staking {
      type: "Staking"
      value: pallet_staking.pallet.pallet.Call
    }
    export function System(
      value: polkadot_runtime.RuntimeCall.System["value"],
    ): polkadot_runtime.RuntimeCall.System {
      return { type: "System", value }
    }
    export interface System {
      type: "System"
      value: frame_system.pallet.Call
    }
    export function TechnicalCommittee(
      value: polkadot_runtime.RuntimeCall.TechnicalCommittee["value"],
    ): polkadot_runtime.RuntimeCall.TechnicalCommittee {
      return { type: "TechnicalCommittee", value }
    }
    export interface TechnicalCommittee {
      type: "TechnicalCommittee"
      value: pallet_collective.pallet.Call
    }
    export function TechnicalMembership(
      value: polkadot_runtime.RuntimeCall.TechnicalMembership["value"],
    ): polkadot_runtime.RuntimeCall.TechnicalMembership {
      return { type: "TechnicalMembership", value }
    }
    export interface TechnicalMembership {
      type: "TechnicalMembership"
      value: pallet_membership.pallet.Call
    }
    export function Timestamp(
      value: polkadot_runtime.RuntimeCall.Timestamp["value"],
    ): polkadot_runtime.RuntimeCall.Timestamp {
      return { type: "Timestamp", value }
    }
    export interface Timestamp {
      type: "Timestamp"
      value: pallet_timestamp.pallet.Call
    }
    export function Tips(
      value: polkadot_runtime.RuntimeCall.Tips["value"],
    ): polkadot_runtime.RuntimeCall.Tips {
      return { type: "Tips", value }
    }
    export interface Tips {
      type: "Tips"
      value: pallet_tips.pallet.Call
    }
    export function Treasury(
      value: polkadot_runtime.RuntimeCall.Treasury["value"],
    ): polkadot_runtime.RuntimeCall.Treasury {
      return { type: "Treasury", value }
    }
    export interface Treasury {
      type: "Treasury"
      value: pallet_treasury.pallet.Call
    }
    export function Ump(
      value: polkadot_runtime.RuntimeCall.Ump["value"],
    ): polkadot_runtime.RuntimeCall.Ump {
      return { type: "Ump", value }
    }
    export interface Ump {
      type: "Ump"
      value: polkadot_runtime_parachains.ump.pallet.Call
    }
    export function Utility(
      value: polkadot_runtime.RuntimeCall.Utility["value"],
    ): polkadot_runtime.RuntimeCall.Utility {
      return { type: "Utility", value }
    }
    export interface Utility {
      type: "Utility"
      value: pallet_utility.pallet.Call
    }
    export function Vesting(
      value: polkadot_runtime.RuntimeCall.Vesting["value"],
    ): polkadot_runtime.RuntimeCall.Vesting {
      return { type: "Vesting", value }
    }
    export interface Vesting {
      type: "Vesting"
      value: pallet_vesting.pallet.Call
    }
    export function VoterList(
      value: polkadot_runtime.RuntimeCall.VoterList["value"],
    ): polkadot_runtime.RuntimeCall.VoterList {
      return { type: "VoterList", value }
    }
    export interface VoterList {
      type: "VoterList"
      value: pallet_bags_list.pallet.Call
    }
    export function XcmPallet(
      value: polkadot_runtime.RuntimeCall.XcmPallet["value"],
    ): polkadot_runtime.RuntimeCall.XcmPallet {
      return { type: "XcmPallet", value }
    }
    export interface XcmPallet {
      type: "XcmPallet"
      value: pallet_xcm.pallet.Call
    }
  }
  export type RuntimeEvent =
    | polkadot_runtime.RuntimeEvent.System
    | polkadot_runtime.RuntimeEvent.Scheduler
    | polkadot_runtime.RuntimeEvent.Preimage
    | polkadot_runtime.RuntimeEvent.Indices
    | polkadot_runtime.RuntimeEvent.Balances
    | polkadot_runtime.RuntimeEvent.TransactionPayment
    | polkadot_runtime.RuntimeEvent.Staking
    | polkadot_runtime.RuntimeEvent.Offences
    | polkadot_runtime.RuntimeEvent.Session
    | polkadot_runtime.RuntimeEvent.Grandpa
    | polkadot_runtime.RuntimeEvent.ImOnline
    | polkadot_runtime.RuntimeEvent.Democracy
    | polkadot_runtime.RuntimeEvent.Council
    | polkadot_runtime.RuntimeEvent.TechnicalCommittee
    | polkadot_runtime.RuntimeEvent.PhragmenElection
    | polkadot_runtime.RuntimeEvent.TechnicalMembership
    | polkadot_runtime.RuntimeEvent.Treasury
    | polkadot_runtime.RuntimeEvent.Claims
    | polkadot_runtime.RuntimeEvent.Vesting
    | polkadot_runtime.RuntimeEvent.Utility
    | polkadot_runtime.RuntimeEvent.Identity
    | polkadot_runtime.RuntimeEvent.Proxy
    | polkadot_runtime.RuntimeEvent.Multisig
    | polkadot_runtime.RuntimeEvent.Bounties
    | polkadot_runtime.RuntimeEvent.ChildBounties
    | polkadot_runtime.RuntimeEvent.Tips
    | polkadot_runtime.RuntimeEvent.ElectionProviderMultiPhase
    | polkadot_runtime.RuntimeEvent.VoterList
    | polkadot_runtime.RuntimeEvent.NominationPools
    | polkadot_runtime.RuntimeEvent.FastUnstake
    | polkadot_runtime.RuntimeEvent.ParaInclusion
    | polkadot_runtime.RuntimeEvent.Paras
    | polkadot_runtime.RuntimeEvent.Ump
    | polkadot_runtime.RuntimeEvent.Hrmp
    | polkadot_runtime.RuntimeEvent.ParasDisputes
    | polkadot_runtime.RuntimeEvent.Registrar
    | polkadot_runtime.RuntimeEvent.Slots
    | polkadot_runtime.RuntimeEvent.Auctions
    | polkadot_runtime.RuntimeEvent.Crowdloan
    | polkadot_runtime.RuntimeEvent.XcmPallet
  export namespace RuntimeEvent {
    export function Auctions(
      value: polkadot_runtime.RuntimeEvent.Auctions["value"],
    ): polkadot_runtime.RuntimeEvent.Auctions {
      return { type: "Auctions", value }
    }
    export interface Auctions {
      type: "Auctions"
      value: polkadot_runtime_common.auctions.pallet.Event
    }
    export function Balances(
      value: polkadot_runtime.RuntimeEvent.Balances["value"],
    ): polkadot_runtime.RuntimeEvent.Balances {
      return { type: "Balances", value }
    }
    export interface Balances {
      type: "Balances"
      value: pallet_balances.pallet.Event
    }
    export function Bounties(
      value: polkadot_runtime.RuntimeEvent.Bounties["value"],
    ): polkadot_runtime.RuntimeEvent.Bounties {
      return { type: "Bounties", value }
    }
    export interface Bounties {
      type: "Bounties"
      value: pallet_bounties.pallet.Event
    }
    export function ChildBounties(
      value: polkadot_runtime.RuntimeEvent.ChildBounties["value"],
    ): polkadot_runtime.RuntimeEvent.ChildBounties {
      return { type: "ChildBounties", value }
    }
    export interface ChildBounties {
      type: "ChildBounties"
      value: pallet_child_bounties.pallet.Event
    }
    export function Claims(
      value: polkadot_runtime.RuntimeEvent.Claims["value"],
    ): polkadot_runtime.RuntimeEvent.Claims {
      return { type: "Claims", value }
    }
    export interface Claims {
      type: "Claims"
      value: polkadot_runtime_common.claims.pallet.Event
    }
    export function Council(
      value: polkadot_runtime.RuntimeEvent.Council["value"],
    ): polkadot_runtime.RuntimeEvent.Council {
      return { type: "Council", value }
    }
    export interface Council {
      type: "Council"
      value: pallet_collective.pallet.Event
    }
    export function Crowdloan(
      value: polkadot_runtime.RuntimeEvent.Crowdloan["value"],
    ): polkadot_runtime.RuntimeEvent.Crowdloan {
      return { type: "Crowdloan", value }
    }
    export interface Crowdloan {
      type: "Crowdloan"
      value: polkadot_runtime_common.crowdloan.pallet.Event
    }
    export function Democracy(
      value: polkadot_runtime.RuntimeEvent.Democracy["value"],
    ): polkadot_runtime.RuntimeEvent.Democracy {
      return { type: "Democracy", value }
    }
    export interface Democracy {
      type: "Democracy"
      value: pallet_democracy.pallet.Event
    }
    export function ElectionProviderMultiPhase(
      value: polkadot_runtime.RuntimeEvent.ElectionProviderMultiPhase["value"],
    ): polkadot_runtime.RuntimeEvent.ElectionProviderMultiPhase {
      return { type: "ElectionProviderMultiPhase", value }
    }
    export interface ElectionProviderMultiPhase {
      type: "ElectionProviderMultiPhase"
      value: pallet_election_provider_multi_phase.pallet.Event
    }
    export function FastUnstake(
      value: polkadot_runtime.RuntimeEvent.FastUnstake["value"],
    ): polkadot_runtime.RuntimeEvent.FastUnstake {
      return { type: "FastUnstake", value }
    }
    export interface FastUnstake {
      type: "FastUnstake"
      value: pallet_fast_unstake.pallet.Event
    }
    export function Grandpa(
      value: polkadot_runtime.RuntimeEvent.Grandpa["value"],
    ): polkadot_runtime.RuntimeEvent.Grandpa {
      return { type: "Grandpa", value }
    }
    export interface Grandpa {
      type: "Grandpa"
      value: pallet_grandpa.pallet.Event
    }
    export function Hrmp(
      value: polkadot_runtime.RuntimeEvent.Hrmp["value"],
    ): polkadot_runtime.RuntimeEvent.Hrmp {
      return { type: "Hrmp", value }
    }
    export interface Hrmp {
      type: "Hrmp"
      value: polkadot_runtime_parachains.hrmp.pallet.Event
    }
    export function Identity(
      value: polkadot_runtime.RuntimeEvent.Identity["value"],
    ): polkadot_runtime.RuntimeEvent.Identity {
      return { type: "Identity", value }
    }
    export interface Identity {
      type: "Identity"
      value: pallet_identity.pallet.Event
    }
    export function ImOnline(
      value: polkadot_runtime.RuntimeEvent.ImOnline["value"],
    ): polkadot_runtime.RuntimeEvent.ImOnline {
      return { type: "ImOnline", value }
    }
    export interface ImOnline {
      type: "ImOnline"
      value: pallet_im_online.pallet.Event
    }
    export function Indices(
      value: polkadot_runtime.RuntimeEvent.Indices["value"],
    ): polkadot_runtime.RuntimeEvent.Indices {
      return { type: "Indices", value }
    }
    export interface Indices {
      type: "Indices"
      value: pallet_indices.pallet.Event
    }
    export function Multisig(
      value: polkadot_runtime.RuntimeEvent.Multisig["value"],
    ): polkadot_runtime.RuntimeEvent.Multisig {
      return { type: "Multisig", value }
    }
    export interface Multisig {
      type: "Multisig"
      value: pallet_multisig.pallet.Event
    }
    export function NominationPools(
      value: polkadot_runtime.RuntimeEvent.NominationPools["value"],
    ): polkadot_runtime.RuntimeEvent.NominationPools {
      return { type: "NominationPools", value }
    }
    export interface NominationPools {
      type: "NominationPools"
      value: pallet_nomination_pools.pallet.Event
    }
    export function Offences(
      value: polkadot_runtime.RuntimeEvent.Offences["value"],
    ): polkadot_runtime.RuntimeEvent.Offences {
      return { type: "Offences", value }
    }
    export interface Offences {
      type: "Offences"
      value: pallet_offences.pallet.Event
    }
    export function ParaInclusion(
      value: polkadot_runtime.RuntimeEvent.ParaInclusion["value"],
    ): polkadot_runtime.RuntimeEvent.ParaInclusion {
      return { type: "ParaInclusion", value }
    }
    export interface ParaInclusion {
      type: "ParaInclusion"
      value: polkadot_runtime_parachains.inclusion.pallet.Event
    }
    export function Paras(
      value: polkadot_runtime.RuntimeEvent.Paras["value"],
    ): polkadot_runtime.RuntimeEvent.Paras {
      return { type: "Paras", value }
    }
    export interface Paras {
      type: "Paras"
      value: polkadot_runtime_parachains.paras.pallet.Event
    }
    export function ParasDisputes(
      value: polkadot_runtime.RuntimeEvent.ParasDisputes["value"],
    ): polkadot_runtime.RuntimeEvent.ParasDisputes {
      return { type: "ParasDisputes", value }
    }
    export interface ParasDisputes {
      type: "ParasDisputes"
      value: polkadot_runtime_parachains.disputes.pallet.Event
    }
    export function PhragmenElection(
      value: polkadot_runtime.RuntimeEvent.PhragmenElection["value"],
    ): polkadot_runtime.RuntimeEvent.PhragmenElection {
      return { type: "PhragmenElection", value }
    }
    export interface PhragmenElection {
      type: "PhragmenElection"
      value: pallet_elections_phragmen.pallet.Event
    }
    export function Preimage(
      value: polkadot_runtime.RuntimeEvent.Preimage["value"],
    ): polkadot_runtime.RuntimeEvent.Preimage {
      return { type: "Preimage", value }
    }
    export interface Preimage {
      type: "Preimage"
      value: pallet_preimage.pallet.Event
    }
    export function Proxy(
      value: polkadot_runtime.RuntimeEvent.Proxy["value"],
    ): polkadot_runtime.RuntimeEvent.Proxy {
      return { type: "Proxy", value }
    }
    export interface Proxy {
      type: "Proxy"
      value: pallet_proxy.pallet.Event
    }
    export function Registrar(
      value: polkadot_runtime.RuntimeEvent.Registrar["value"],
    ): polkadot_runtime.RuntimeEvent.Registrar {
      return { type: "Registrar", value }
    }
    export interface Registrar {
      type: "Registrar"
      value: polkadot_runtime_common.paras_registrar.pallet.Event
    }
    export function Scheduler(
      value: polkadot_runtime.RuntimeEvent.Scheduler["value"],
    ): polkadot_runtime.RuntimeEvent.Scheduler {
      return { type: "Scheduler", value }
    }
    export interface Scheduler {
      type: "Scheduler"
      value: pallet_scheduler.pallet.Event
    }
    export function Session(
      value: polkadot_runtime.RuntimeEvent.Session["value"],
    ): polkadot_runtime.RuntimeEvent.Session {
      return { type: "Session", value }
    }
    export interface Session {
      type: "Session"
      value: pallet_session.pallet.Event
    }
    export function Slots(
      value: polkadot_runtime.RuntimeEvent.Slots["value"],
    ): polkadot_runtime.RuntimeEvent.Slots {
      return { type: "Slots", value }
    }
    export interface Slots {
      type: "Slots"
      value: polkadot_runtime_common.slots.pallet.Event
    }
    export function Staking(
      value: polkadot_runtime.RuntimeEvent.Staking["value"],
    ): polkadot_runtime.RuntimeEvent.Staking {
      return { type: "Staking", value }
    }
    export interface Staking {
      type: "Staking"
      value: pallet_staking.pallet.pallet.Event
    }
    export function System(
      value: polkadot_runtime.RuntimeEvent.System["value"],
    ): polkadot_runtime.RuntimeEvent.System {
      return { type: "System", value }
    }
    export interface System {
      type: "System"
      value: frame_system.pallet.Event
    }
    export function TechnicalCommittee(
      value: polkadot_runtime.RuntimeEvent.TechnicalCommittee["value"],
    ): polkadot_runtime.RuntimeEvent.TechnicalCommittee {
      return { type: "TechnicalCommittee", value }
    }
    export interface TechnicalCommittee {
      type: "TechnicalCommittee"
      value: pallet_collective.pallet.Event
    }
    export function TechnicalMembership(
      value: polkadot_runtime.RuntimeEvent.TechnicalMembership["value"],
    ): polkadot_runtime.RuntimeEvent.TechnicalMembership {
      return { type: "TechnicalMembership", value }
    }
    export interface TechnicalMembership {
      type: "TechnicalMembership"
      value: pallet_membership.pallet.Event
    }
    export function Tips(
      value: polkadot_runtime.RuntimeEvent.Tips["value"],
    ): polkadot_runtime.RuntimeEvent.Tips {
      return { type: "Tips", value }
    }
    export interface Tips {
      type: "Tips"
      value: pallet_tips.pallet.Event
    }
    export function TransactionPayment(
      value: polkadot_runtime.RuntimeEvent.TransactionPayment["value"],
    ): polkadot_runtime.RuntimeEvent.TransactionPayment {
      return { type: "TransactionPayment", value }
    }
    export interface TransactionPayment {
      type: "TransactionPayment"
      value: pallet_transaction_payment.pallet.Event
    }
    export function Treasury(
      value: polkadot_runtime.RuntimeEvent.Treasury["value"],
    ): polkadot_runtime.RuntimeEvent.Treasury {
      return { type: "Treasury", value }
    }
    export interface Treasury {
      type: "Treasury"
      value: pallet_treasury.pallet.Event
    }
    export function Ump(
      value: polkadot_runtime.RuntimeEvent.Ump["value"],
    ): polkadot_runtime.RuntimeEvent.Ump {
      return { type: "Ump", value }
    }
    export interface Ump {
      type: "Ump"
      value: polkadot_runtime_parachains.ump.pallet.Event
    }
    export function Utility(
      value: polkadot_runtime.RuntimeEvent.Utility["value"],
    ): polkadot_runtime.RuntimeEvent.Utility {
      return { type: "Utility", value }
    }
    export interface Utility {
      type: "Utility"
      value: pallet_utility.pallet.Event
    }
    export function Vesting(
      value: polkadot_runtime.RuntimeEvent.Vesting["value"],
    ): polkadot_runtime.RuntimeEvent.Vesting {
      return { type: "Vesting", value }
    }
    export interface Vesting {
      type: "Vesting"
      value: pallet_vesting.pallet.Event
    }
    export function VoterList(
      value: polkadot_runtime.RuntimeEvent.VoterList["value"],
    ): polkadot_runtime.RuntimeEvent.VoterList {
      return { type: "VoterList", value }
    }
    export interface VoterList {
      type: "VoterList"
      value: pallet_bags_list.pallet.Event
    }
    export function XcmPallet(
      value: polkadot_runtime.RuntimeEvent.XcmPallet["value"],
    ): polkadot_runtime.RuntimeEvent.XcmPallet {
      return { type: "XcmPallet", value }
    }
    export interface XcmPallet {
      type: "XcmPallet"
      value: pallet_xcm.pallet.Event
    }
  }
  export interface SessionKeys {
    grandpa: sp_finality_grandpa.app.Public
    babe: sp_consensus_babe.app.Public
    im_online: pallet_im_online.sr25519.app_sr25519.Public
    para_validator: polkadot_primitives.v2.validator_app.Public
    para_assignment: polkadot_primitives.v2.assignment_app.Public
    authority_discovery: sp_authority_discovery.app.Public
  }
  export function SessionKeys(value: polkadot_runtime.SessionKeys) {
    return value
  }
}
export namespace polkadot_runtime_common {
  export namespace auctions {
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_common.auctions.pallet.Call> = _codec.$413
      export const $error: $.Codec<polkadot_runtime_common.auctions.pallet.Error> = _codec.$709
      export const $event: $.Codec<polkadot_runtime_common.auctions.pallet.Event> = _codec.$119
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_common.auctions.pallet.Call.new_auction
        | polkadot_runtime_common.auctions.pallet.Call.bid
        | polkadot_runtime_common.auctions.pallet.Call.cancel_auction
      export namespace Call {
        /**
         * Make a new bid from an account (including a parachain account) for deploying a new
         * parachain.
         *
         * Multiple simultaneous bids from the same bidder are allowed only as long as all active
         * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
         *
         * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
         * funded by) the same account.
         * - `auction_index` is the index of the auction to bid on. Should just be the present
         * value of `AuctionCounter`.
         * - `first_slot` is the first lease period index of the range to bid on. This is the
         * absolute lease period index value, not an auction-specific offset.
         * - `last_slot` is the last lease period index of the range to bid on. This is the
         * absolute lease period index value, not an auction-specific offset.
         * - `amount` is the amount to bid to be held as deposit for the parachain should the
         * bid win. This amount is held throughout the range.
         */
        export function bid(
          value: Omit<polkadot_runtime_common.auctions.pallet.Call.bid, "type">,
        ): polkadot_runtime_common.auctions.pallet.Call.bid {
          return { type: "bid", ...value }
        }
        /**
         * Make a new bid from an account (including a parachain account) for deploying a new
         * parachain.
         *
         * Multiple simultaneous bids from the same bidder are allowed only as long as all active
         * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
         *
         * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
         * funded by) the same account.
         * - `auction_index` is the index of the auction to bid on. Should just be the present
         * value of `AuctionCounter`.
         * - `first_slot` is the first lease period index of the range to bid on. This is the
         * absolute lease period index value, not an auction-specific offset.
         * - `last_slot` is the last lease period index of the range to bid on. This is the
         * absolute lease period index value, not an auction-specific offset.
         * - `amount` is the amount to bid to be held as deposit for the parachain should the
         * bid win. This amount is held throughout the range.
         */
        export interface bid {
          type: "bid"
          para: Compact<polkadot_parachain.primitives.Id>
          auction_index: Compact<u32>
          first_slot: Compact<u32>
          last_slot: Compact<u32>
          amount: Compact<u128>
        }
        /**
         * Cancel an in-progress auction.
         *
         * Can only be called by Root origin.
         */
        export function cancel_auction(): polkadot_runtime_common.auctions.pallet.Call.cancel_auction {
          return { type: "cancel_auction" }
        }
        /**
         * Cancel an in-progress auction.
         *
         * Can only be called by Root origin.
         */
        export interface cancel_auction {
          type: "cancel_auction"
        }
        /**
         * Create a new auction.
         *
         * This can only happen when there isn't already an auction in progress and may only be
         * called by the root origin. Accepts the `duration` of this auction and the
         * `lease_period_index` of the initial lease period of the four that are to be auctioned.
         */
        export function new_auction(
          value: Omit<polkadot_runtime_common.auctions.pallet.Call.new_auction, "type">,
        ): polkadot_runtime_common.auctions.pallet.Call.new_auction {
          return { type: "new_auction", ...value }
        }
        /**
         * Create a new auction.
         *
         * This can only happen when there isn't already an auction in progress and may only be
         * called by the root origin. Accepts the `duration` of this auction and the
         * `lease_period_index` of the initial lease period of the four that are to be auctioned.
         */
        export interface new_auction {
          type: "new_auction"
          duration: Compact<u32>
          lease_period_index: Compact<u32>
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "AuctionInProgress"
        | "LeasePeriodInPast"
        | "ParaNotRegistered"
        | "NotCurrentAuction"
        | "NotAuction"
        | "AuctionEnded"
        | "AlreadyLeasedOut"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_common.auctions.pallet.Event.AuctionStarted
        | polkadot_runtime_common.auctions.pallet.Event.AuctionClosed
        | polkadot_runtime_common.auctions.pallet.Event.Reserved
        | polkadot_runtime_common.auctions.pallet.Event.Unreserved
        | polkadot_runtime_common.auctions.pallet.Event.ReserveConfiscated
        | polkadot_runtime_common.auctions.pallet.Event.BidAccepted
        | polkadot_runtime_common.auctions.pallet.Event.WinningOffset
      export namespace Event {
        /** An auction ended. All funds become unreserved. */
        export function AuctionClosed(
          value: Omit<polkadot_runtime_common.auctions.pallet.Event.AuctionClosed, "type">,
        ): polkadot_runtime_common.auctions.pallet.Event.AuctionClosed {
          return { type: "AuctionClosed", ...value }
        }
        /** An auction ended. All funds become unreserved. */
        export interface AuctionClosed {
          type: "AuctionClosed"
          auction_index: u32
        }
        /**
         * An auction started. Provides its index and the block number where it will begin to
         * close and the first lease period of the quadruplet that is auctioned.
         */
        export function AuctionStarted(
          value: Omit<polkadot_runtime_common.auctions.pallet.Event.AuctionStarted, "type">,
        ): polkadot_runtime_common.auctions.pallet.Event.AuctionStarted {
          return { type: "AuctionStarted", ...value }
        }
        /**
         * An auction started. Provides its index and the block number where it will begin to
         * close and the first lease period of the quadruplet that is auctioned.
         */
        export interface AuctionStarted {
          type: "AuctionStarted"
          auction_index: u32
          lease_period: u32
          ending: u32
        }
        /** A new bid has been accepted as the current winner. */
        export function BidAccepted(
          value: Omit<polkadot_runtime_common.auctions.pallet.Event.BidAccepted, "type">,
        ): polkadot_runtime_common.auctions.pallet.Event.BidAccepted {
          return { type: "BidAccepted", ...value }
        }
        /** A new bid has been accepted as the current winner. */
        export interface BidAccepted {
          type: "BidAccepted"
          bidder: sp_core.crypto.AccountId32
          para_id: polkadot_parachain.primitives.Id
          amount: u128
          first_slot: u32
          last_slot: u32
        }
        /**
         * Someone attempted to lease the same slot twice for a parachain. The amount is held in reserve
         * but no parachain slot has been leased.
         */
        export function ReserveConfiscated(
          value: Omit<polkadot_runtime_common.auctions.pallet.Event.ReserveConfiscated, "type">,
        ): polkadot_runtime_common.auctions.pallet.Event.ReserveConfiscated {
          return { type: "ReserveConfiscated", ...value }
        }
        /**
         * Someone attempted to lease the same slot twice for a parachain. The amount is held in reserve
         * but no parachain slot has been leased.
         */
        export interface ReserveConfiscated {
          type: "ReserveConfiscated"
          para_id: polkadot_parachain.primitives.Id
          leaser: sp_core.crypto.AccountId32
          amount: u128
        }
        /**
         * Funds were reserved for a winning bid. First balance is the extra amount reserved.
         * Second is the total.
         */
        export function Reserved(
          value: Omit<polkadot_runtime_common.auctions.pallet.Event.Reserved, "type">,
        ): polkadot_runtime_common.auctions.pallet.Event.Reserved {
          return { type: "Reserved", ...value }
        }
        /**
         * Funds were reserved for a winning bid. First balance is the extra amount reserved.
         * Second is the total.
         */
        export interface Reserved {
          type: "Reserved"
          bidder: sp_core.crypto.AccountId32
          extra_reserved: u128
          total_amount: u128
        }
        /** Funds were unreserved since bidder is no longer active. `[bidder, amount]` */
        export function Unreserved(
          value: Omit<polkadot_runtime_common.auctions.pallet.Event.Unreserved, "type">,
        ): polkadot_runtime_common.auctions.pallet.Event.Unreserved {
          return { type: "Unreserved", ...value }
        }
        /** Funds were unreserved since bidder is no longer active. `[bidder, amount]` */
        export interface Unreserved {
          type: "Unreserved"
          bidder: sp_core.crypto.AccountId32
          amount: u128
        }
        /** The winning offset was chosen for an auction. This will map into the `Winning` storage map. */
        export function WinningOffset(
          value: Omit<polkadot_runtime_common.auctions.pallet.Event.WinningOffset, "type">,
        ): polkadot_runtime_common.auctions.pallet.Event.WinningOffset {
          return { type: "WinningOffset", ...value }
        }
        /** The winning offset was chosen for an auction. This will map into the `Winning` storage map. */
        export interface WinningOffset {
          type: "WinningOffset"
          auction_index: u32
          block_number: u32
        }
      }
    }
  }
  export namespace claims {
    export const $ecdsaSignature: $.Codec<polkadot_runtime_common.claims.EcdsaSignature> =
      _codec.$246
    export const $ethereumAddress: $.Codec<polkadot_runtime_common.claims.EthereumAddress> =
      _codec.$73
    export const $prevalidateAttests: $.Codec<polkadot_runtime_common.claims.PrevalidateAttests> =
      _codec.$736
    export const $statementKind: $.Codec<polkadot_runtime_common.claims.StatementKind> = _codec.$251
    export type EcdsaSignature = Uint8Array
    export function EcdsaSignature(value: polkadot_runtime_common.claims.EcdsaSignature) {
      return value
    }
    export type EthereumAddress = Uint8Array
    export function EthereumAddress(value: polkadot_runtime_common.claims.EthereumAddress) {
      return value
    }
    export function PrevalidateAttests() {
      return null
    }
    export type PrevalidateAttests = null
    export type StatementKind = "Regular" | "Saft"
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_common.claims.pallet.Call> = _codec.$245
      export const $error: $.Codec<polkadot_runtime_common.claims.pallet.Error> = _codec.$562
      export const $event: $.Codec<polkadot_runtime_common.claims.pallet.Event> = _codec.$72
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_common.claims.pallet.Call.claim
        | polkadot_runtime_common.claims.pallet.Call.mint_claim
        | polkadot_runtime_common.claims.pallet.Call.claim_attest
        | polkadot_runtime_common.claims.pallet.Call.attest
        | polkadot_runtime_common.claims.pallet.Call.move_claim
      export namespace Call {
        /**
         * Attest to a statement, needed to finalize the claims process.
         *
         * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a `SignedExtension`.
         *
         * Unsigned Validation:
         * A call to attest is deemed valid if the sender has a `Preclaim` registered
         * and provides a `statement` which is expected for the account.
         *
         * Parameters:
         * - `statement`: The identity of the statement which is being attested to in the signature.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * Weight includes logic to do pre-validation on `attest` call.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export function attest(
          value: Omit<polkadot_runtime_common.claims.pallet.Call.attest, "type">,
        ): polkadot_runtime_common.claims.pallet.Call.attest {
          return { type: "attest", ...value }
        }
        /**
         * Attest to a statement, needed to finalize the claims process.
         *
         * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a `SignedExtension`.
         *
         * Unsigned Validation:
         * A call to attest is deemed valid if the sender has a `Preclaim` registered
         * and provides a `statement` which is expected for the account.
         *
         * Parameters:
         * - `statement`: The identity of the statement which is being attested to in the signature.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * Weight includes logic to do pre-validation on `attest` call.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export interface attest {
          type: "attest"
          statement: Uint8Array
        }
        /**
         * Make a claim to collect your DOTs.
         *
         * The dispatch origin for this call must be _None_.
         *
         * Unsigned Validation:
         * A call to claim is deemed valid if the signature provided matches
         * the expected signed message of:
         *
         * > Ethereum Signed Message:
         * > (configured prefix string)(address)
         *
         * and `address` matches the `dest` account.
         *
         * Parameters:
         * - `dest`: The destination account to payout the claim.
         * - `ethereum_signature`: The signature of an ethereum signed message
         *    matching the format described above.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * Weight includes logic to validate unsigned `claim` call.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export function claim(
          value: Omit<polkadot_runtime_common.claims.pallet.Call.claim, "type">,
        ): polkadot_runtime_common.claims.pallet.Call.claim {
          return { type: "claim", ...value }
        }
        /**
         * Make a claim to collect your DOTs.
         *
         * The dispatch origin for this call must be _None_.
         *
         * Unsigned Validation:
         * A call to claim is deemed valid if the signature provided matches
         * the expected signed message of:
         *
         * > Ethereum Signed Message:
         * > (configured prefix string)(address)
         *
         * and `address` matches the `dest` account.
         *
         * Parameters:
         * - `dest`: The destination account to payout the claim.
         * - `ethereum_signature`: The signature of an ethereum signed message
         *    matching the format described above.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * Weight includes logic to validate unsigned `claim` call.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export interface claim {
          type: "claim"
          dest: sp_core.crypto.AccountId32
          ethereum_signature: polkadot_runtime_common.claims.EcdsaSignature
        }
        /**
         * Make a claim to collect your DOTs by signing a statement.
         *
         * The dispatch origin for this call must be _None_.
         *
         * Unsigned Validation:
         * A call to `claim_attest` is deemed valid if the signature provided matches
         * the expected signed message of:
         *
         * > Ethereum Signed Message:
         * > (configured prefix string)(address)(statement)
         *
         * and `address` matches the `dest` account; the `statement` must match that which is
         * expected according to your purchase arrangement.
         *
         * Parameters:
         * - `dest`: The destination account to payout the claim.
         * - `ethereum_signature`: The signature of an ethereum signed message
         *    matching the format described above.
         * - `statement`: The identity of the statement which is being attested to in the signature.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * Weight includes logic to validate unsigned `claim_attest` call.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export function claim_attest(
          value: Omit<polkadot_runtime_common.claims.pallet.Call.claim_attest, "type">,
        ): polkadot_runtime_common.claims.pallet.Call.claim_attest {
          return { type: "claim_attest", ...value }
        }
        /**
         * Make a claim to collect your DOTs by signing a statement.
         *
         * The dispatch origin for this call must be _None_.
         *
         * Unsigned Validation:
         * A call to `claim_attest` is deemed valid if the signature provided matches
         * the expected signed message of:
         *
         * > Ethereum Signed Message:
         * > (configured prefix string)(address)(statement)
         *
         * and `address` matches the `dest` account; the `statement` must match that which is
         * expected according to your purchase arrangement.
         *
         * Parameters:
         * - `dest`: The destination account to payout the claim.
         * - `ethereum_signature`: The signature of an ethereum signed message
         *    matching the format described above.
         * - `statement`: The identity of the statement which is being attested to in the signature.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * Weight includes logic to validate unsigned `claim_attest` call.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export interface claim_attest {
          type: "claim_attest"
          dest: sp_core.crypto.AccountId32
          ethereum_signature: polkadot_runtime_common.claims.EcdsaSignature
          statement: Uint8Array
        }
        /**
         * Mint a new claim to collect DOTs.
         *
         * The dispatch origin for this call must be _Root_.
         *
         * Parameters:
         * - `who`: The Ethereum address allowed to collect this claim.
         * - `value`: The number of DOTs that will be claimed.
         * - `vesting_schedule`: An optional vesting schedule for these DOTs.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * We assume worst case that both vesting and statement is being inserted.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export function mint_claim(
          value: Omit<polkadot_runtime_common.claims.pallet.Call.mint_claim, "type">,
        ): polkadot_runtime_common.claims.pallet.Call.mint_claim {
          return { type: "mint_claim", ...value }
        }
        /**
         * Mint a new claim to collect DOTs.
         *
         * The dispatch origin for this call must be _Root_.
         *
         * Parameters:
         * - `who`: The Ethereum address allowed to collect this claim.
         * - `value`: The number of DOTs that will be claimed.
         * - `vesting_schedule`: An optional vesting schedule for these DOTs.
         *
         * <weight>
         * The weight of this call is invariant over the input parameters.
         * We assume worst case that both vesting and statement is being inserted.
         *
         * Total Complexity: O(1)
         * </weight>
         */
        export interface mint_claim {
          type: "mint_claim"
          who: polkadot_runtime_common.claims.EthereumAddress
          value: u128
          vesting_schedule: [u128, u128, u32] | undefined
          statement: polkadot_runtime_common.claims.StatementKind | undefined
        }
        export function move_claim(
          value: Omit<polkadot_runtime_common.claims.pallet.Call.move_claim, "type">,
        ): polkadot_runtime_common.claims.pallet.Call.move_claim {
          return { type: "move_claim", ...value }
        }
        export interface move_claim {
          type: "move_claim"
          old: polkadot_runtime_common.claims.EthereumAddress
          new: polkadot_runtime_common.claims.EthereumAddress
          maybe_preclaim: sp_core.crypto.AccountId32 | undefined
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "InvalidEthereumSignature"
        | "SignerHasNoClaim"
        | "SenderHasNoClaim"
        | "PotUnderflow"
        | "InvalidStatement"
        | "VestedBalanceExists"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event = polkadot_runtime_common.claims.pallet.Event.Claimed
      export namespace Event {
        /** Someone claimed some DOTs. */
        export function Claimed(
          value: Omit<polkadot_runtime_common.claims.pallet.Event.Claimed, "type">,
        ): polkadot_runtime_common.claims.pallet.Event.Claimed {
          return { type: "Claimed", ...value }
        }
        /** Someone claimed some DOTs. */
        export interface Claimed {
          type: "Claimed"
          who: sp_core.crypto.AccountId32
          ethereum_address: polkadot_runtime_common.claims.EthereumAddress
          amount: u128
        }
      }
    }
  }
  export namespace crowdloan {
    export const $fundInfo: $.Codec<polkadot_runtime_common.crowdloan.FundInfo> = _codec.$710
    export const $lastContribution: $.Codec<polkadot_runtime_common.crowdloan.LastContribution> =
      _codec.$711
    export interface FundInfo {
      depositor: sp_core.crypto.AccountId32
      verifier: sp_runtime.MultiSigner | undefined
      deposit: u128
      raised: u128
      end: u32
      cap: u128
      last_contribution: polkadot_runtime_common.crowdloan.LastContribution
      first_period: u32
      last_period: u32
      fund_index: u32
    }
    export function FundInfo(value: polkadot_runtime_common.crowdloan.FundInfo) {
      return value
    }
    export type LastContribution =
      | polkadot_runtime_common.crowdloan.LastContribution.Never
      | polkadot_runtime_common.crowdloan.LastContribution.PreEnding
      | polkadot_runtime_common.crowdloan.LastContribution.Ending
    export namespace LastContribution {
      export function Ending(
        value: polkadot_runtime_common.crowdloan.LastContribution.Ending["value"],
      ): polkadot_runtime_common.crowdloan.LastContribution.Ending {
        return { type: "Ending", value }
      }
      export interface Ending {
        type: "Ending"
        value: u32
      }
      export function Never(): polkadot_runtime_common.crowdloan.LastContribution.Never {
        return { type: "Never" }
      }
      export interface Never {
        type: "Never"
      }
      export function PreEnding(
        value: polkadot_runtime_common.crowdloan.LastContribution.PreEnding["value"],
      ): polkadot_runtime_common.crowdloan.LastContribution.PreEnding {
        return { type: "PreEnding", value }
      }
      export interface PreEnding {
        type: "PreEnding"
        value: u32
      }
    }
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_common.crowdloan.pallet.Call> = _codec.$415
      export const $error: $.Codec<polkadot_runtime_common.crowdloan.pallet.Error> = _codec.$712
      export const $event: $.Codec<polkadot_runtime_common.crowdloan.pallet.Event> = _codec.$120
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_common.crowdloan.pallet.Call.create
        | polkadot_runtime_common.crowdloan.pallet.Call.contribute
        | polkadot_runtime_common.crowdloan.pallet.Call.withdraw
        | polkadot_runtime_common.crowdloan.pallet.Call.refund
        | polkadot_runtime_common.crowdloan.pallet.Call.dissolve
        | polkadot_runtime_common.crowdloan.pallet.Call.edit
        | polkadot_runtime_common.crowdloan.pallet.Call.add_memo
        | polkadot_runtime_common.crowdloan.pallet.Call.poke
        | polkadot_runtime_common.crowdloan.pallet.Call.contribute_all
      export namespace Call {
        /**
         * Add an optional memo to an existing crowdloan contribution.
         *
         * Origin must be Signed, and the user must have contributed to the crowdloan.
         */
        export function add_memo(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.add_memo, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.add_memo {
          return { type: "add_memo", ...value }
        }
        /**
         * Add an optional memo to an existing crowdloan contribution.
         *
         * Origin must be Signed, and the user must have contributed to the crowdloan.
         */
        export interface add_memo {
          type: "add_memo"
          index: polkadot_parachain.primitives.Id
          memo: Uint8Array
        }
        /**
         * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
         * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
         */
        export function contribute(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.contribute, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.contribute {
          return { type: "contribute", ...value }
        }
        /**
         * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
         * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
         */
        export interface contribute {
          type: "contribute"
          index: Compact<polkadot_parachain.primitives.Id>
          value: Compact<u128>
          signature: sp_runtime.MultiSignature | undefined
        }
        /**
         * Contribute your entire balance to a crowd sale. This will transfer the entire balance of a user over to fund a parachain
         * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
         */
        export function contribute_all(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.contribute_all, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.contribute_all {
          return { type: "contribute_all", ...value }
        }
        /**
         * Contribute your entire balance to a crowd sale. This will transfer the entire balance of a user over to fund a parachain
         * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
         */
        export interface contribute_all {
          type: "contribute_all"
          index: Compact<polkadot_parachain.primitives.Id>
          signature: sp_runtime.MultiSignature | undefined
        }
        /**
         * Create a new crowdloaning campaign for a parachain slot with the given lease period range.
         *
         * This applies a lock to your parachain configuration, ensuring that it cannot be changed
         * by the parachain manager.
         */
        export function create(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.create, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.create {
          return { type: "create", ...value }
        }
        /**
         * Create a new crowdloaning campaign for a parachain slot with the given lease period range.
         *
         * This applies a lock to your parachain configuration, ensuring that it cannot be changed
         * by the parachain manager.
         */
        export interface create {
          type: "create"
          index: Compact<polkadot_parachain.primitives.Id>
          cap: Compact<u128>
          first_period: Compact<u32>
          last_period: Compact<u32>
          end: Compact<u32>
          verifier: sp_runtime.MultiSigner | undefined
        }
        /** Remove a fund after the retirement period has ended and all funds have been returned. */
        export function dissolve(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.dissolve, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.dissolve {
          return { type: "dissolve", ...value }
        }
        /** Remove a fund after the retirement period has ended and all funds have been returned. */
        export interface dissolve {
          type: "dissolve"
          index: Compact<polkadot_parachain.primitives.Id>
        }
        /**
         * Edit the configuration for an in-progress crowdloan.
         *
         * Can only be called by Root origin.
         */
        export function edit(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.edit, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.edit {
          return { type: "edit", ...value }
        }
        /**
         * Edit the configuration for an in-progress crowdloan.
         *
         * Can only be called by Root origin.
         */
        export interface edit {
          type: "edit"
          index: Compact<polkadot_parachain.primitives.Id>
          cap: Compact<u128>
          first_period: Compact<u32>
          last_period: Compact<u32>
          end: Compact<u32>
          verifier: sp_runtime.MultiSigner | undefined
        }
        /**
         * Poke the fund into `NewRaise`
         *
         * Origin must be Signed, and the fund has non-zero raise.
         */
        export function poke(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.poke, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.poke {
          return { type: "poke", ...value }
        }
        /**
         * Poke the fund into `NewRaise`
         *
         * Origin must be Signed, and the fund has non-zero raise.
         */
        export interface poke {
          type: "poke"
          index: polkadot_parachain.primitives.Id
        }
        /**
         * Automatically refund contributors of an ended crowdloan.
         * Due to weight restrictions, this function may need to be called multiple
         * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
         *
         * Origin must be signed, but can come from anyone.
         */
        export function refund(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.refund, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.refund {
          return { type: "refund", ...value }
        }
        /**
         * Automatically refund contributors of an ended crowdloan.
         * Due to weight restrictions, this function may need to be called multiple
         * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
         *
         * Origin must be signed, but can come from anyone.
         */
        export interface refund {
          type: "refund"
          index: Compact<polkadot_parachain.primitives.Id>
        }
        /**
         * Withdraw full balance of a specific contributor.
         *
         * Origin must be signed, but can come from anyone.
         *
         * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement, then the retirement
         * flag must be set. For a fund to be ready for retirement, then:
         * - it must not already be in retirement;
         * - the amount of raised funds must be bigger than the _free_ balance of the account;
         * - and either:
         *   - the block number must be at least `end`; or
         *   - the current lease period must be greater than the fund's `last_period`.
         *
         * In this case, the fund's retirement flag is set and its `end` is reset to the current block
         * number.
         *
         * - `who`: The account whose contribution should be withdrawn.
         * - `index`: The parachain to whose crowdloan the contribution was made.
         */
        export function withdraw(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Call.withdraw, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Call.withdraw {
          return { type: "withdraw", ...value }
        }
        /**
         * Withdraw full balance of a specific contributor.
         *
         * Origin must be signed, but can come from anyone.
         *
         * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement, then the retirement
         * flag must be set. For a fund to be ready for retirement, then:
         * - it must not already be in retirement;
         * - the amount of raised funds must be bigger than the _free_ balance of the account;
         * - and either:
         *   - the block number must be at least `end`; or
         *   - the current lease period must be greater than the fund's `last_period`.
         *
         * In this case, the fund's retirement flag is set and its `end` is reset to the current block
         * number.
         *
         * - `who`: The account whose contribution should be withdrawn.
         * - `index`: The parachain to whose crowdloan the contribution was made.
         */
        export interface withdraw {
          type: "withdraw"
          who: sp_core.crypto.AccountId32
          index: Compact<polkadot_parachain.primitives.Id>
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "FirstPeriodInPast"
        | "FirstPeriodTooFarInFuture"
        | "LastPeriodBeforeFirstPeriod"
        | "LastPeriodTooFarInFuture"
        | "CannotEndInPast"
        | "EndTooFarInFuture"
        | "Overflow"
        | "ContributionTooSmall"
        | "InvalidParaId"
        | "CapExceeded"
        | "ContributionPeriodOver"
        | "InvalidOrigin"
        | "NotParachain"
        | "LeaseActive"
        | "BidOrLeaseActive"
        | "FundNotEnded"
        | "NoContributions"
        | "NotReadyToDissolve"
        | "InvalidSignature"
        | "MemoTooLarge"
        | "AlreadyInNewRaise"
        | "VrfDelayInProgress"
        | "NoLeasePeriod"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_common.crowdloan.pallet.Event.Created
        | polkadot_runtime_common.crowdloan.pallet.Event.Contributed
        | polkadot_runtime_common.crowdloan.pallet.Event.Withdrew
        | polkadot_runtime_common.crowdloan.pallet.Event.PartiallyRefunded
        | polkadot_runtime_common.crowdloan.pallet.Event.AllRefunded
        | polkadot_runtime_common.crowdloan.pallet.Event.Dissolved
        | polkadot_runtime_common.crowdloan.pallet.Event.HandleBidResult
        | polkadot_runtime_common.crowdloan.pallet.Event.Edited
        | polkadot_runtime_common.crowdloan.pallet.Event.MemoUpdated
        | polkadot_runtime_common.crowdloan.pallet.Event.AddedToNewRaise
      export namespace Event {
        /** A parachain has been moved to `NewRaise` */
        export function AddedToNewRaise(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.AddedToNewRaise, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.AddedToNewRaise {
          return { type: "AddedToNewRaise", ...value }
        }
        /** A parachain has been moved to `NewRaise` */
        export interface AddedToNewRaise {
          type: "AddedToNewRaise"
          para_id: polkadot_parachain.primitives.Id
        }
        /** All loans in a fund have been refunded. */
        export function AllRefunded(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.AllRefunded, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.AllRefunded {
          return { type: "AllRefunded", ...value }
        }
        /** All loans in a fund have been refunded. */
        export interface AllRefunded {
          type: "AllRefunded"
          para_id: polkadot_parachain.primitives.Id
        }
        /** Contributed to a crowd sale. */
        export function Contributed(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.Contributed, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.Contributed {
          return { type: "Contributed", ...value }
        }
        /** Contributed to a crowd sale. */
        export interface Contributed {
          type: "Contributed"
          who: sp_core.crypto.AccountId32
          fund_index: polkadot_parachain.primitives.Id
          amount: u128
        }
        /** Create a new crowdloaning campaign. */
        export function Created(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.Created, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.Created {
          return { type: "Created", ...value }
        }
        /** Create a new crowdloaning campaign. */
        export interface Created {
          type: "Created"
          para_id: polkadot_parachain.primitives.Id
        }
        /** Fund is dissolved. */
        export function Dissolved(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.Dissolved, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.Dissolved {
          return { type: "Dissolved", ...value }
        }
        /** Fund is dissolved. */
        export interface Dissolved {
          type: "Dissolved"
          para_id: polkadot_parachain.primitives.Id
        }
        /** The configuration to a crowdloan has been edited. */
        export function Edited(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.Edited, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.Edited {
          return { type: "Edited", ...value }
        }
        /** The configuration to a crowdloan has been edited. */
        export interface Edited {
          type: "Edited"
          para_id: polkadot_parachain.primitives.Id
        }
        /** The result of trying to submit a new bid to the Slots pallet. */
        export function HandleBidResult(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.HandleBidResult, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.HandleBidResult {
          return { type: "HandleBidResult", ...value }
        }
        /** The result of trying to submit a new bid to the Slots pallet. */
        export interface HandleBidResult {
          type: "HandleBidResult"
          para_id: polkadot_parachain.primitives.Id
          result: null | ChainError<sp_runtime.DispatchError>
        }
        /** A memo has been updated. */
        export function MemoUpdated(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.MemoUpdated, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.MemoUpdated {
          return { type: "MemoUpdated", ...value }
        }
        /** A memo has been updated. */
        export interface MemoUpdated {
          type: "MemoUpdated"
          who: sp_core.crypto.AccountId32
          para_id: polkadot_parachain.primitives.Id
          memo: Uint8Array
        }
        /**
         * The loans in a fund have been partially dissolved, i.e. there are some left
         * over child keys that still need to be killed.
         */
        export function PartiallyRefunded(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.PartiallyRefunded, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.PartiallyRefunded {
          return { type: "PartiallyRefunded", ...value }
        }
        /**
         * The loans in a fund have been partially dissolved, i.e. there are some left
         * over child keys that still need to be killed.
         */
        export interface PartiallyRefunded {
          type: "PartiallyRefunded"
          para_id: polkadot_parachain.primitives.Id
        }
        /** Withdrew full balance of a contributor. */
        export function Withdrew(
          value: Omit<polkadot_runtime_common.crowdloan.pallet.Event.Withdrew, "type">,
        ): polkadot_runtime_common.crowdloan.pallet.Event.Withdrew {
          return { type: "Withdrew", ...value }
        }
        /** Withdrew full balance of a contributor. */
        export interface Withdrew {
          type: "Withdrew"
          who: sp_core.crypto.AccountId32
          fund_index: polkadot_parachain.primitives.Id
          amount: u128
        }
      }
    }
  }
  export namespace paras_registrar {
    export const $paraInfo: $.Codec<polkadot_runtime_common.paras_registrar.ParaInfo> = _codec.$701
    export interface ParaInfo {
      manager: sp_core.crypto.AccountId32
      deposit: u128
      locked: boolean
    }
    export function ParaInfo(value: polkadot_runtime_common.paras_registrar.ParaInfo) {
      return value
    }
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_common.paras_registrar.pallet.Call> = _codec.$411
      export const $error: $.Codec<polkadot_runtime_common.paras_registrar.pallet.Error> =
        _codec.$702
      export const $event: $.Codec<polkadot_runtime_common.paras_registrar.pallet.Event> =
        _codec.$117
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_common.paras_registrar.pallet.Call.register
        | polkadot_runtime_common.paras_registrar.pallet.Call.force_register
        | polkadot_runtime_common.paras_registrar.pallet.Call.deregister
        | polkadot_runtime_common.paras_registrar.pallet.Call.swap
        | polkadot_runtime_common.paras_registrar.pallet.Call.remove_lock
        | polkadot_runtime_common.paras_registrar.pallet.Call.reserve
        | polkadot_runtime_common.paras_registrar.pallet.Call.add_lock
        | polkadot_runtime_common.paras_registrar.pallet.Call.schedule_code_upgrade
        | polkadot_runtime_common.paras_registrar.pallet.Call.set_current_head
      export namespace Call {
        /**
         * Add a manager lock from a para. This will prevent the manager of a
         * para to deregister or swap a para.
         *
         * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
         */
        export function add_lock(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.add_lock, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.add_lock {
          return { type: "add_lock", ...value }
        }
        /**
         * Add a manager lock from a para. This will prevent the manager of a
         * para to deregister or swap a para.
         *
         * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
         */
        export interface add_lock {
          type: "add_lock"
          para: polkadot_parachain.primitives.Id
        }
        /**
         * Deregister a Para Id, freeing all data and returning any deposit.
         *
         * The caller must be Root, the `para` owner, or the `para` itself. The para must be a parathread.
         */
        export function deregister(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.deregister, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.deregister {
          return { type: "deregister", ...value }
        }
        /**
         * Deregister a Para Id, freeing all data and returning any deposit.
         *
         * The caller must be Root, the `para` owner, or the `para` itself. The para must be a parathread.
         */
        export interface deregister {
          type: "deregister"
          id: polkadot_parachain.primitives.Id
        }
        /**
         * Force the registration of a Para Id on the relay chain.
         *
         * This function must be called by a Root origin.
         *
         * The deposit taken can be specified for this registration. Any `ParaId`
         * can be registered, including sub-1000 IDs which are System Parachains.
         */
        export function force_register(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.force_register, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.force_register {
          return { type: "force_register", ...value }
        }
        /**
         * Force the registration of a Para Id on the relay chain.
         *
         * This function must be called by a Root origin.
         *
         * The deposit taken can be specified for this registration. Any `ParaId`
         * can be registered, including sub-1000 IDs which are System Parachains.
         */
        export interface force_register {
          type: "force_register"
          who: sp_core.crypto.AccountId32
          deposit: u128
          id: polkadot_parachain.primitives.Id
          genesis_head: polkadot_parachain.primitives.HeadData
          validation_code: polkadot_parachain.primitives.ValidationCode
        }
        /**
         * Register head data and validation code for a reserved Para Id.
         *
         * ## Arguments
         * - `origin`: Must be called by a `Signed` origin.
         * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
         * - `genesis_head`: The genesis head data of the parachain/thread.
         * - `validation_code`: The initial validation code of the parachain/thread.
         *
         * ## Deposits/Fees
         * The origin signed account must reserve a corresponding deposit for the registration. Anything already
         * reserved previously for this para ID is accounted for.
         *
         * ## Events
         * The `Registered` event is emitted in case of success.
         */
        export function register(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.register, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.register {
          return { type: "register", ...value }
        }
        /**
         * Register head data and validation code for a reserved Para Id.
         *
         * ## Arguments
         * - `origin`: Must be called by a `Signed` origin.
         * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
         * - `genesis_head`: The genesis head data of the parachain/thread.
         * - `validation_code`: The initial validation code of the parachain/thread.
         *
         * ## Deposits/Fees
         * The origin signed account must reserve a corresponding deposit for the registration. Anything already
         * reserved previously for this para ID is accounted for.
         *
         * ## Events
         * The `Registered` event is emitted in case of success.
         */
        export interface register {
          type: "register"
          id: polkadot_parachain.primitives.Id
          genesis_head: polkadot_parachain.primitives.HeadData
          validation_code: polkadot_parachain.primitives.ValidationCode
        }
        /**
         * Remove a manager lock from a para. This will allow the manager of a
         * previously locked para to deregister or swap a para without using governance.
         *
         * Can only be called by the Root origin or the parachain.
         */
        export function remove_lock(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.remove_lock, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.remove_lock {
          return { type: "remove_lock", ...value }
        }
        /**
         * Remove a manager lock from a para. This will allow the manager of a
         * previously locked para to deregister or swap a para without using governance.
         *
         * Can only be called by the Root origin or the parachain.
         */
        export interface remove_lock {
          type: "remove_lock"
          para: polkadot_parachain.primitives.Id
        }
        /**
         * Reserve a Para Id on the relay chain.
         *
         * This function will reserve a new Para Id to be owned/managed by the origin account.
         * The origin account is able to register head data and validation code using `register` to create
         * a parathread. Using the Slots pallet, a parathread can then be upgraded to get a parachain slot.
         *
         * ## Arguments
         * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new para ID.
         *
         * ## Deposits/Fees
         * The origin must reserve a deposit of `ParaDeposit` for the registration.
         *
         * ## Events
         * The `Reserved` event is emitted in case of success, which provides the ID reserved for use.
         */
        export function reserve(): polkadot_runtime_common.paras_registrar.pallet.Call.reserve {
          return { type: "reserve" }
        }
        /**
         * Reserve a Para Id on the relay chain.
         *
         * This function will reserve a new Para Id to be owned/managed by the origin account.
         * The origin account is able to register head data and validation code using `register` to create
         * a parathread. Using the Slots pallet, a parathread can then be upgraded to get a parachain slot.
         *
         * ## Arguments
         * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new para ID.
         *
         * ## Deposits/Fees
         * The origin must reserve a deposit of `ParaDeposit` for the registration.
         *
         * ## Events
         * The `Reserved` event is emitted in case of success, which provides the ID reserved for use.
         */
        export interface reserve {
          type: "reserve"
        }
        /**
         * Schedule a parachain upgrade.
         *
         * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
         */
        export function schedule_code_upgrade(
          value: Omit<
            polkadot_runtime_common.paras_registrar.pallet.Call.schedule_code_upgrade,
            "type"
          >,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.schedule_code_upgrade {
          return { type: "schedule_code_upgrade", ...value }
        }
        /**
         * Schedule a parachain upgrade.
         *
         * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
         */
        export interface schedule_code_upgrade {
          type: "schedule_code_upgrade"
          para: polkadot_parachain.primitives.Id
          new_code: polkadot_parachain.primitives.ValidationCode
        }
        /**
         * Set the parachain's current head.
         *
         * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
         */
        export function set_current_head(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.set_current_head, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.set_current_head {
          return { type: "set_current_head", ...value }
        }
        /**
         * Set the parachain's current head.
         *
         * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
         */
        export interface set_current_head {
          type: "set_current_head"
          para: polkadot_parachain.primitives.Id
          new_head: polkadot_parachain.primitives.HeadData
        }
        /**
         * Swap a parachain with another parachain or parathread.
         *
         * The origin must be Root, the `para` owner, or the `para` itself.
         *
         * The swap will happen only if there is already an opposite swap pending. If there is not,
         * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
         *
         * The `ParaId`s remain mapped to the same head data and code so external code can rely on
         * `ParaId` to be a long-term identifier of a notional "parachain". However, their
         * scheduling info (i.e. whether they're a parathread or parachain), auction information
         * and the auction deposit are switched.
         */
        export function swap(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Call.swap, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Call.swap {
          return { type: "swap", ...value }
        }
        /**
         * Swap a parachain with another parachain or parathread.
         *
         * The origin must be Root, the `para` owner, or the `para` itself.
         *
         * The swap will happen only if there is already an opposite swap pending. If there is not,
         * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
         *
         * The `ParaId`s remain mapped to the same head data and code so external code can rely on
         * `ParaId` to be a long-term identifier of a notional "parachain". However, their
         * scheduling info (i.e. whether they're a parathread or parachain), auction information
         * and the auction deposit are switched.
         */
        export interface swap {
          type: "swap"
          id: polkadot_parachain.primitives.Id
          other: polkadot_parachain.primitives.Id
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "NotRegistered"
        | "AlreadyRegistered"
        | "NotOwner"
        | "CodeTooLarge"
        | "HeadDataTooLarge"
        | "NotParachain"
        | "NotParathread"
        | "CannotDeregister"
        | "CannotDowngrade"
        | "CannotUpgrade"
        | "ParaLocked"
        | "NotReserved"
        | "EmptyCode"
        | "CannotSwap"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_common.paras_registrar.pallet.Event.Registered
        | polkadot_runtime_common.paras_registrar.pallet.Event.Deregistered
        | polkadot_runtime_common.paras_registrar.pallet.Event.Reserved
      export namespace Event {
        export function Deregistered(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Event.Deregistered, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Event.Deregistered {
          return { type: "Deregistered", ...value }
        }
        export interface Deregistered {
          type: "Deregistered"
          para_id: polkadot_parachain.primitives.Id
        }
        export function Registered(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Event.Registered, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Event.Registered {
          return { type: "Registered", ...value }
        }
        export interface Registered {
          type: "Registered"
          para_id: polkadot_parachain.primitives.Id
          manager: sp_core.crypto.AccountId32
        }
        export function Reserved(
          value: Omit<polkadot_runtime_common.paras_registrar.pallet.Event.Reserved, "type">,
        ): polkadot_runtime_common.paras_registrar.pallet.Event.Reserved {
          return { type: "Reserved", ...value }
        }
        export interface Reserved {
          type: "Reserved"
          para_id: polkadot_parachain.primitives.Id
          who: sp_core.crypto.AccountId32
        }
      }
    }
  }
  export namespace slots {
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_common.slots.pallet.Call> = _codec.$412
      export const $error: $.Codec<polkadot_runtime_common.slots.pallet.Error> = _codec.$704
      export const $event: $.Codec<polkadot_runtime_common.slots.pallet.Event> = _codec.$118
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_common.slots.pallet.Call.force_lease
        | polkadot_runtime_common.slots.pallet.Call.clear_all_leases
        | polkadot_runtime_common.slots.pallet.Call.trigger_onboard
      export namespace Call {
        /**
         * Clear all leases for a Para Id, refunding any deposits back to the original owners.
         *
         * The dispatch origin for this call must match `T::ForceOrigin`.
         */
        export function clear_all_leases(
          value: Omit<polkadot_runtime_common.slots.pallet.Call.clear_all_leases, "type">,
        ): polkadot_runtime_common.slots.pallet.Call.clear_all_leases {
          return { type: "clear_all_leases", ...value }
        }
        /**
         * Clear all leases for a Para Id, refunding any deposits back to the original owners.
         *
         * The dispatch origin for this call must match `T::ForceOrigin`.
         */
        export interface clear_all_leases {
          type: "clear_all_leases"
          para: polkadot_parachain.primitives.Id
        }
        /**
         * Just a connect into the `lease_out` call, in case Root wants to force some lease to happen
         * independently of any other on-chain mechanism to use it.
         *
         * The dispatch origin for this call must match `T::ForceOrigin`.
         */
        export function force_lease(
          value: Omit<polkadot_runtime_common.slots.pallet.Call.force_lease, "type">,
        ): polkadot_runtime_common.slots.pallet.Call.force_lease {
          return { type: "force_lease", ...value }
        }
        /**
         * Just a connect into the `lease_out` call, in case Root wants to force some lease to happen
         * independently of any other on-chain mechanism to use it.
         *
         * The dispatch origin for this call must match `T::ForceOrigin`.
         */
        export interface force_lease {
          type: "force_lease"
          para: polkadot_parachain.primitives.Id
          leaser: sp_core.crypto.AccountId32
          amount: u128
          period_begin: u32
          period_count: u32
        }
        /**
         * Try to onboard a parachain that has a lease for the current lease period.
         *
         * This function can be useful if there was some state issue with a para that should
         * have onboarded, but was unable to. As long as they have a lease period, we can
         * let them onboard from here.
         *
         * Origin must be signed, but can be called by anyone.
         */
        export function trigger_onboard(
          value: Omit<polkadot_runtime_common.slots.pallet.Call.trigger_onboard, "type">,
        ): polkadot_runtime_common.slots.pallet.Call.trigger_onboard {
          return { type: "trigger_onboard", ...value }
        }
        /**
         * Try to onboard a parachain that has a lease for the current lease period.
         *
         * This function can be useful if there was some state issue with a para that should
         * have onboarded, but was unable to. As long as they have a lease period, we can
         * let them onboard from here.
         *
         * Origin must be signed, but can be called by anyone.
         */
        export interface trigger_onboard {
          type: "trigger_onboard"
          para: polkadot_parachain.primitives.Id
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error = "ParaNotOnboarding" | "LeaseError"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_common.slots.pallet.Event.NewLeasePeriod
        | polkadot_runtime_common.slots.pallet.Event.Leased
      export namespace Event {
        /**
         * A para has won the right to a continuous set of lease periods as a parachain.
         * First balance is any extra amount reserved on top of the para's existing deposit.
         * Second balance is the total amount reserved.
         */
        export function Leased(
          value: Omit<polkadot_runtime_common.slots.pallet.Event.Leased, "type">,
        ): polkadot_runtime_common.slots.pallet.Event.Leased {
          return { type: "Leased", ...value }
        }
        /**
         * A para has won the right to a continuous set of lease periods as a parachain.
         * First balance is any extra amount reserved on top of the para's existing deposit.
         * Second balance is the total amount reserved.
         */
        export interface Leased {
          type: "Leased"
          para_id: polkadot_parachain.primitives.Id
          leaser: sp_core.crypto.AccountId32
          period_begin: u32
          period_count: u32
          extra_reserved: u128
          total_amount: u128
        }
        /** A new `[lease_period]` is beginning. */
        export function NewLeasePeriod(
          value: Omit<polkadot_runtime_common.slots.pallet.Event.NewLeasePeriod, "type">,
        ): polkadot_runtime_common.slots.pallet.Event.NewLeasePeriod {
          return { type: "NewLeasePeriod", ...value }
        }
        /** A new `[lease_period]` is beginning. */
        export interface NewLeasePeriod {
          type: "NewLeasePeriod"
          lease_period: u32
        }
      }
    }
  }
}
export namespace polkadot_runtime_parachains {
  export namespace configuration {
    export const $hostConfiguration: $.Codec<
      polkadot_runtime_parachains.configuration.HostConfiguration
    > = _codec.$638
    export interface HostConfiguration {
      max_code_size: u32
      max_head_data_size: u32
      max_upward_queue_count: u32
      max_upward_queue_size: u32
      max_upward_message_size: u32
      max_upward_message_num_per_candidate: u32
      hrmp_max_message_num_per_candidate: u32
      validation_upgrade_cooldown: u32
      validation_upgrade_delay: u32
      max_pov_size: u32
      max_downward_message_size: u32
      ump_service_total_weight: sp_weights.weight_v2.Weight
      hrmp_max_parachain_outbound_channels: u32
      hrmp_max_parathread_outbound_channels: u32
      hrmp_sender_deposit: u128
      hrmp_recipient_deposit: u128
      hrmp_channel_max_capacity: u32
      hrmp_channel_max_total_size: u32
      hrmp_max_parachain_inbound_channels: u32
      hrmp_max_parathread_inbound_channels: u32
      hrmp_channel_max_message_size: u32
      code_retention_period: u32
      parathread_cores: u32
      parathread_retries: u32
      group_rotation_frequency: u32
      chain_availability_period: u32
      thread_availability_period: u32
      scheduling_lookahead: u32
      max_validators_per_core: u32 | undefined
      max_validators: u32 | undefined
      dispute_period: u32
      dispute_post_conclusion_acceptance_period: u32
      dispute_max_spam_slots: u32
      dispute_conclusion_by_time_out_period: u32
      no_show_slots: u32
      n_delay_tranches: u32
      zeroth_delay_tranche_width: u32
      needed_approvals: u32
      relay_vrf_modulo_samples: u32
      ump_max_individual_weight: sp_weights.weight_v2.Weight
      pvf_checking_enabled: boolean
      pvf_voting_ttl: u32
      minimum_validation_upgrade_delay: u32
    }
    export function HostConfiguration(
      value: polkadot_runtime_parachains.configuration.HostConfiguration,
    ) {
      return value
    }
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.configuration.pallet.Call> =
        _codec.$375
      export const $error: $.Codec<polkadot_runtime_parachains.configuration.pallet.Error> =
        _codec.$641
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_cooldown
        | polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_delay
        | polkadot_runtime_parachains.configuration.pallet.Call.set_code_retention_period
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_code_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_pov_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_head_data_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_cores
        | polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_retries
        | polkadot_runtime_parachains.configuration.pallet.Call.set_group_rotation_frequency
        | polkadot_runtime_parachains.configuration.pallet.Call.set_chain_availability_period
        | polkadot_runtime_parachains.configuration.pallet.Call.set_thread_availability_period
        | polkadot_runtime_parachains.configuration.pallet.Call.set_scheduling_lookahead
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators_per_core
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators
        | polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_period
        | polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_post_conclusion_acceptance_period
        | polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_max_spam_slots
        | polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_conclusion_by_time_out_period
        | polkadot_runtime_parachains.configuration.pallet.Call.set_no_show_slots
        | polkadot_runtime_parachains.configuration.pallet.Call.set_n_delay_tranches
        | polkadot_runtime_parachains.configuration.pallet.Call.set_zeroth_delay_tranche_width
        | polkadot_runtime_parachains.configuration.pallet.Call.set_needed_approvals
        | polkadot_runtime_parachains.configuration.pallet.Call.set_relay_vrf_modulo_samples
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_count
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_downward_message_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_ump_service_total_weight
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_num_per_candidate
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_open_request_ttl
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_sender_deposit
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_recipient_deposit
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_capacity
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_total_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_inbound_channels
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_inbound_channels
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_message_size
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_outbound_channels
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_outbound_channels
        | polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_message_num_per_candidate
        | polkadot_runtime_parachains.configuration.pallet.Call.set_ump_max_individual_weight
        | polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_checking_enabled
        | polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_voting_ttl
        | polkadot_runtime_parachains.configuration.pallet.Call.set_minimum_validation_upgrade_delay
        | polkadot_runtime_parachains.configuration.pallet.Call.set_bypass_consistency_check
      export namespace Call {
        /**
         * Setting this to true will disable consistency checks for the configuration setters.
         * Use with caution.
         */
        export function set_bypass_consistency_check(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_bypass_consistency_check,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_bypass_consistency_check {
          return { type: "set_bypass_consistency_check", ...value }
        }
        /**
         * Setting this to true will disable consistency checks for the configuration setters.
         * Use with caution.
         */
        export interface set_bypass_consistency_check {
          type: "set_bypass_consistency_check"
          new: boolean
        }
        /** Set the availability period for parachains. */
        export function set_chain_availability_period(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_chain_availability_period,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_chain_availability_period {
          return { type: "set_chain_availability_period", ...value }
        }
        /** Set the availability period for parachains. */
        export interface set_chain_availability_period {
          type: "set_chain_availability_period"
          new: u32
        }
        /** Set the acceptance period for an included candidate. */
        export function set_code_retention_period(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_code_retention_period,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_code_retention_period {
          return { type: "set_code_retention_period", ...value }
        }
        /** Set the acceptance period for an included candidate. */
        export interface set_code_retention_period {
          type: "set_code_retention_period"
          new: u32
        }
        /** Set the dispute conclusion by time out period. */
        export function set_dispute_conclusion_by_time_out_period(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_conclusion_by_time_out_period,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_conclusion_by_time_out_period {
          return { type: "set_dispute_conclusion_by_time_out_period", ...value }
        }
        /** Set the dispute conclusion by time out period. */
        export interface set_dispute_conclusion_by_time_out_period {
          type: "set_dispute_conclusion_by_time_out_period"
          new: u32
        }
        /** Set the maximum number of dispute spam slots. */
        export function set_dispute_max_spam_slots(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_max_spam_slots,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_max_spam_slots {
          return { type: "set_dispute_max_spam_slots", ...value }
        }
        /** Set the maximum number of dispute spam slots. */
        export interface set_dispute_max_spam_slots {
          type: "set_dispute_max_spam_slots"
          new: u32
        }
        /** Set the dispute period, in number of sessions to keep for disputes. */
        export function set_dispute_period(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_period,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_period {
          return { type: "set_dispute_period", ...value }
        }
        /** Set the dispute period, in number of sessions to keep for disputes. */
        export interface set_dispute_period {
          type: "set_dispute_period"
          new: u32
        }
        /** Set the dispute post conclusion acceptance period. */
        export function set_dispute_post_conclusion_acceptance_period(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_post_conclusion_acceptance_period,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_dispute_post_conclusion_acceptance_period {
          return { type: "set_dispute_post_conclusion_acceptance_period", ...value }
        }
        /** Set the dispute post conclusion acceptance period. */
        export interface set_dispute_post_conclusion_acceptance_period {
          type: "set_dispute_post_conclusion_acceptance_period"
          new: u32
        }
        /** Set the parachain validator-group rotation frequency */
        export function set_group_rotation_frequency(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_group_rotation_frequency,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_group_rotation_frequency {
          return { type: "set_group_rotation_frequency", ...value }
        }
        /** Set the parachain validator-group rotation frequency */
        export interface set_group_rotation_frequency {
          type: "set_group_rotation_frequency"
          new: u32
        }
        /** Sets the maximum number of messages allowed in an HRMP channel at once. */
        export function set_hrmp_channel_max_capacity(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_capacity,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_capacity {
          return { type: "set_hrmp_channel_max_capacity", ...value }
        }
        /** Sets the maximum number of messages allowed in an HRMP channel at once. */
        export interface set_hrmp_channel_max_capacity {
          type: "set_hrmp_channel_max_capacity"
          new: u32
        }
        /** Sets the maximum size of a message that could ever be put into an HRMP channel. */
        export function set_hrmp_channel_max_message_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_message_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_message_size {
          return { type: "set_hrmp_channel_max_message_size", ...value }
        }
        /** Sets the maximum size of a message that could ever be put into an HRMP channel. */
        export interface set_hrmp_channel_max_message_size {
          type: "set_hrmp_channel_max_message_size"
          new: u32
        }
        /** Sets the maximum total size of messages in bytes allowed in an HRMP channel at once. */
        export function set_hrmp_channel_max_total_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_total_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_channel_max_total_size {
          return { type: "set_hrmp_channel_max_total_size", ...value }
        }
        /** Sets the maximum total size of messages in bytes allowed in an HRMP channel at once. */
        export interface set_hrmp_channel_max_total_size {
          type: "set_hrmp_channel_max_total_size"
          new: u32
        }
        /** Sets the maximum number of outbound HRMP messages can be sent by a candidate. */
        export function set_hrmp_max_message_num_per_candidate(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_message_num_per_candidate,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_message_num_per_candidate {
          return { type: "set_hrmp_max_message_num_per_candidate", ...value }
        }
        /** Sets the maximum number of outbound HRMP messages can be sent by a candidate. */
        export interface set_hrmp_max_message_num_per_candidate {
          type: "set_hrmp_max_message_num_per_candidate"
          new: u32
        }
        /** Sets the maximum number of inbound HRMP channels a parachain is allowed to accept. */
        export function set_hrmp_max_parachain_inbound_channels(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_inbound_channels,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_inbound_channels {
          return { type: "set_hrmp_max_parachain_inbound_channels", ...value }
        }
        /** Sets the maximum number of inbound HRMP channels a parachain is allowed to accept. */
        export interface set_hrmp_max_parachain_inbound_channels {
          type: "set_hrmp_max_parachain_inbound_channels"
          new: u32
        }
        /** Sets the maximum number of outbound HRMP channels a parachain is allowed to open. */
        export function set_hrmp_max_parachain_outbound_channels(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_outbound_channels,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parachain_outbound_channels {
          return { type: "set_hrmp_max_parachain_outbound_channels", ...value }
        }
        /** Sets the maximum number of outbound HRMP channels a parachain is allowed to open. */
        export interface set_hrmp_max_parachain_outbound_channels {
          type: "set_hrmp_max_parachain_outbound_channels"
          new: u32
        }
        /** Sets the maximum number of inbound HRMP channels a parathread is allowed to accept. */
        export function set_hrmp_max_parathread_inbound_channels(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_inbound_channels,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_inbound_channels {
          return { type: "set_hrmp_max_parathread_inbound_channels", ...value }
        }
        /** Sets the maximum number of inbound HRMP channels a parathread is allowed to accept. */
        export interface set_hrmp_max_parathread_inbound_channels {
          type: "set_hrmp_max_parathread_inbound_channels"
          new: u32
        }
        /** Sets the maximum number of outbound HRMP channels a parathread is allowed to open. */
        export function set_hrmp_max_parathread_outbound_channels(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_outbound_channels,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_max_parathread_outbound_channels {
          return { type: "set_hrmp_max_parathread_outbound_channels", ...value }
        }
        /** Sets the maximum number of outbound HRMP channels a parathread is allowed to open. */
        export interface set_hrmp_max_parathread_outbound_channels {
          type: "set_hrmp_max_parathread_outbound_channels"
          new: u32
        }
        /** Sets the number of sessions after which an HRMP open channel request expires. */
        export function set_hrmp_open_request_ttl(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_open_request_ttl,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_open_request_ttl {
          return { type: "set_hrmp_open_request_ttl", ...value }
        }
        /** Sets the number of sessions after which an HRMP open channel request expires. */
        export interface set_hrmp_open_request_ttl {
          type: "set_hrmp_open_request_ttl"
          new: u32
        }
        /**
         * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
         * channel.
         */
        export function set_hrmp_recipient_deposit(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_recipient_deposit,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_recipient_deposit {
          return { type: "set_hrmp_recipient_deposit", ...value }
        }
        /**
         * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
         * channel.
         */
        export interface set_hrmp_recipient_deposit {
          type: "set_hrmp_recipient_deposit"
          new: u128
        }
        /** Sets the amount of funds that the sender should provide for opening an HRMP channel. */
        export function set_hrmp_sender_deposit(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_sender_deposit,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_hrmp_sender_deposit {
          return { type: "set_hrmp_sender_deposit", ...value }
        }
        /** Sets the amount of funds that the sender should provide for opening an HRMP channel. */
        export interface set_hrmp_sender_deposit {
          type: "set_hrmp_sender_deposit"
          new: u128
        }
        /** Set the max validation code size for incoming upgrades. */
        export function set_max_code_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_code_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_code_size {
          return { type: "set_max_code_size", ...value }
        }
        /** Set the max validation code size for incoming upgrades. */
        export interface set_max_code_size {
          type: "set_max_code_size"
          new: u32
        }
        /** Set the critical downward message size. */
        export function set_max_downward_message_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_downward_message_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_downward_message_size {
          return { type: "set_max_downward_message_size", ...value }
        }
        /** Set the critical downward message size. */
        export interface set_max_downward_message_size {
          type: "set_max_downward_message_size"
          new: u32
        }
        /** Set the max head data size for paras. */
        export function set_max_head_data_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_head_data_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_head_data_size {
          return { type: "set_max_head_data_size", ...value }
        }
        /** Set the max head data size for paras. */
        export interface set_max_head_data_size {
          type: "set_max_head_data_size"
          new: u32
        }
        /** Set the max POV block size for incoming upgrades. */
        export function set_max_pov_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_pov_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_pov_size {
          return { type: "set_max_pov_size", ...value }
        }
        /** Set the max POV block size for incoming upgrades. */
        export interface set_max_pov_size {
          type: "set_max_pov_size"
          new: u32
        }
        /** Sets the maximum number of messages that a candidate can contain. */
        export function set_max_upward_message_num_per_candidate(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_num_per_candidate,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_num_per_candidate {
          return { type: "set_max_upward_message_num_per_candidate", ...value }
        }
        /** Sets the maximum number of messages that a candidate can contain. */
        export interface set_max_upward_message_num_per_candidate {
          type: "set_max_upward_message_num_per_candidate"
          new: u32
        }
        /** Sets the maximum size of an upward message that can be sent by a candidate. */
        export function set_max_upward_message_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_message_size {
          return { type: "set_max_upward_message_size", ...value }
        }
        /** Sets the maximum size of an upward message that can be sent by a candidate. */
        export interface set_max_upward_message_size {
          type: "set_max_upward_message_size"
          new: u32
        }
        /** Sets the maximum items that can present in a upward dispatch queue at once. */
        export function set_max_upward_queue_count(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_count,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_count {
          return { type: "set_max_upward_queue_count", ...value }
        }
        /** Sets the maximum items that can present in a upward dispatch queue at once. */
        export interface set_max_upward_queue_count {
          type: "set_max_upward_queue_count"
          new: u32
        }
        /** Sets the maximum total size of items that can present in a upward dispatch queue at once. */
        export function set_max_upward_queue_size(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_size,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_upward_queue_size {
          return { type: "set_max_upward_queue_size", ...value }
        }
        /** Sets the maximum total size of items that can present in a upward dispatch queue at once. */
        export interface set_max_upward_queue_size {
          type: "set_max_upward_queue_size"
          new: u32
        }
        /** Set the maximum number of validators to use in parachain consensus. */
        export function set_max_validators(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators {
          return { type: "set_max_validators", ...value }
        }
        /** Set the maximum number of validators to use in parachain consensus. */
        export interface set_max_validators {
          type: "set_max_validators"
          new: u32 | undefined
        }
        /** Set the maximum number of validators to assign to any core. */
        export function set_max_validators_per_core(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators_per_core,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_max_validators_per_core {
          return { type: "set_max_validators_per_core", ...value }
        }
        /** Set the maximum number of validators to assign to any core. */
        export interface set_max_validators_per_core {
          type: "set_max_validators_per_core"
          new: u32 | undefined
        }
        /**
         * Sets the minimum delay between announcing the upgrade block for a parachain until the
         * upgrade taking place.
         *
         * See the field documentation for information and constraints for the new value.
         */
        export function set_minimum_validation_upgrade_delay(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_minimum_validation_upgrade_delay,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_minimum_validation_upgrade_delay {
          return { type: "set_minimum_validation_upgrade_delay", ...value }
        }
        /**
         * Sets the minimum delay between announcing the upgrade block for a parachain until the
         * upgrade taking place.
         *
         * See the field documentation for information and constraints for the new value.
         */
        export interface set_minimum_validation_upgrade_delay {
          type: "set_minimum_validation_upgrade_delay"
          new: u32
        }
        /** Set the total number of delay tranches. */
        export function set_n_delay_tranches(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_n_delay_tranches,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_n_delay_tranches {
          return { type: "set_n_delay_tranches", ...value }
        }
        /** Set the total number of delay tranches. */
        export interface set_n_delay_tranches {
          type: "set_n_delay_tranches"
          new: u32
        }
        /** Set the number of validators needed to approve a block. */
        export function set_needed_approvals(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_needed_approvals,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_needed_approvals {
          return { type: "set_needed_approvals", ...value }
        }
        /** Set the number of validators needed to approve a block. */
        export interface set_needed_approvals {
          type: "set_needed_approvals"
          new: u32
        }
        /**
         * Set the no show slots, in number of number of consensus slots.
         * Must be at least 1.
         */
        export function set_no_show_slots(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_no_show_slots,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_no_show_slots {
          return { type: "set_no_show_slots", ...value }
        }
        /**
         * Set the no show slots, in number of number of consensus slots.
         * Must be at least 1.
         */
        export interface set_no_show_slots {
          type: "set_no_show_slots"
          new: u32
        }
        /** Set the number of parathread execution cores. */
        export function set_parathread_cores(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_cores,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_cores {
          return { type: "set_parathread_cores", ...value }
        }
        /** Set the number of parathread execution cores. */
        export interface set_parathread_cores {
          type: "set_parathread_cores"
          new: u32
        }
        /** Set the number of retries for a particular parathread. */
        export function set_parathread_retries(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_retries,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_parathread_retries {
          return { type: "set_parathread_retries", ...value }
        }
        /** Set the number of retries for a particular parathread. */
        export interface set_parathread_retries {
          type: "set_parathread_retries"
          new: u32
        }
        /** Enable or disable PVF pre-checking. Consult the field documentation prior executing. */
        export function set_pvf_checking_enabled(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_checking_enabled,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_checking_enabled {
          return { type: "set_pvf_checking_enabled", ...value }
        }
        /** Enable or disable PVF pre-checking. Consult the field documentation prior executing. */
        export interface set_pvf_checking_enabled {
          type: "set_pvf_checking_enabled"
          new: boolean
        }
        /** Set the number of session changes after which a PVF pre-checking voting is rejected. */
        export function set_pvf_voting_ttl(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_voting_ttl,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_pvf_voting_ttl {
          return { type: "set_pvf_voting_ttl", ...value }
        }
        /** Set the number of session changes after which a PVF pre-checking voting is rejected. */
        export interface set_pvf_voting_ttl {
          type: "set_pvf_voting_ttl"
          new: u32
        }
        /** Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion. */
        export function set_relay_vrf_modulo_samples(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_relay_vrf_modulo_samples,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_relay_vrf_modulo_samples {
          return { type: "set_relay_vrf_modulo_samples", ...value }
        }
        /** Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion. */
        export interface set_relay_vrf_modulo_samples {
          type: "set_relay_vrf_modulo_samples"
          new: u32
        }
        /** Set the scheduling lookahead, in expected number of blocks at peak throughput. */
        export function set_scheduling_lookahead(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_scheduling_lookahead,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_scheduling_lookahead {
          return { type: "set_scheduling_lookahead", ...value }
        }
        /** Set the scheduling lookahead, in expected number of blocks at peak throughput. */
        export interface set_scheduling_lookahead {
          type: "set_scheduling_lookahead"
          new: u32
        }
        /** Set the availability period for parathreads. */
        export function set_thread_availability_period(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_thread_availability_period,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_thread_availability_period {
          return { type: "set_thread_availability_period", ...value }
        }
        /** Set the availability period for parathreads. */
        export interface set_thread_availability_period {
          type: "set_thread_availability_period"
          new: u32
        }
        /** Sets the maximum amount of weight any individual upward message may consume. */
        export function set_ump_max_individual_weight(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_ump_max_individual_weight,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_ump_max_individual_weight {
          return { type: "set_ump_max_individual_weight", ...value }
        }
        /** Sets the maximum amount of weight any individual upward message may consume. */
        export interface set_ump_max_individual_weight {
          type: "set_ump_max_individual_weight"
          new: sp_weights.weight_v2.Weight
        }
        /** Sets the soft limit for the phase of dispatching dispatchable upward messages. */
        export function set_ump_service_total_weight(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_ump_service_total_weight,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_ump_service_total_weight {
          return { type: "set_ump_service_total_weight", ...value }
        }
        /** Sets the soft limit for the phase of dispatching dispatchable upward messages. */
        export interface set_ump_service_total_weight {
          type: "set_ump_service_total_weight"
          new: sp_weights.weight_v2.Weight
        }
        /** Set the validation upgrade cooldown. */
        export function set_validation_upgrade_cooldown(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_cooldown,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_cooldown {
          return { type: "set_validation_upgrade_cooldown", ...value }
        }
        /** Set the validation upgrade cooldown. */
        export interface set_validation_upgrade_cooldown {
          type: "set_validation_upgrade_cooldown"
          new: u32
        }
        /** Set the validation upgrade delay. */
        export function set_validation_upgrade_delay(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_delay,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_validation_upgrade_delay {
          return { type: "set_validation_upgrade_delay", ...value }
        }
        /** Set the validation upgrade delay. */
        export interface set_validation_upgrade_delay {
          type: "set_validation_upgrade_delay"
          new: u32
        }
        /** Set the zeroth delay tranche width. */
        export function set_zeroth_delay_tranche_width(
          value: Omit<
            polkadot_runtime_parachains.configuration.pallet.Call.set_zeroth_delay_tranche_width,
            "type"
          >,
        ): polkadot_runtime_parachains.configuration.pallet.Call.set_zeroth_delay_tranche_width {
          return { type: "set_zeroth_delay_tranche_width", ...value }
        }
        /** Set the zeroth delay tranche width. */
        export interface set_zeroth_delay_tranche_width {
          type: "set_zeroth_delay_tranche_width"
          new: u32
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error = "InvalidNewValue"
    }
  }
  export namespace disputes {
    export const $disputeLocation: $.Codec<polkadot_runtime_parachains.disputes.DisputeLocation> =
      _codec.$115
    export const $disputeResult: $.Codec<polkadot_runtime_parachains.disputes.DisputeResult> =
      _codec.$116
    export type DisputeLocation = "Local" | "Remote"
    export type DisputeResult = "Valid" | "Invalid"
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.disputes.pallet.Call> = _codec.$410
      export const $error: $.Codec<polkadot_runtime_parachains.disputes.pallet.Error> = _codec.$700
      export const $event: $.Codec<polkadot_runtime_parachains.disputes.pallet.Event> = _codec.$113
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call = "force_unfreeze"
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "DuplicateDisputeStatementSets"
        | "AncientDisputeStatement"
        | "ValidatorIndexOutOfBounds"
        | "InvalidSignature"
        | "DuplicateStatement"
        | "PotentialSpam"
        | "SingleSidedDispute"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_parachains.disputes.pallet.Event.DisputeInitiated
        | polkadot_runtime_parachains.disputes.pallet.Event.DisputeConcluded
        | polkadot_runtime_parachains.disputes.pallet.Event.DisputeTimedOut
        | polkadot_runtime_parachains.disputes.pallet.Event.Revert
      export namespace Event {
        /**
         * A dispute has concluded for or against a candidate.
         * `\[para id, candidate hash, dispute result\]`
         */
        export function DisputeConcluded(
          ...value: polkadot_runtime_parachains.disputes.pallet.Event.DisputeConcluded["value"]
        ): polkadot_runtime_parachains.disputes.pallet.Event.DisputeConcluded {
          return { type: "DisputeConcluded", value }
        }
        /**
         * A dispute has concluded for or against a candidate.
         * `\[para id, candidate hash, dispute result\]`
         */
        export interface DisputeConcluded {
          type: "DisputeConcluded"
          value: [
            polkadot_core_primitives.CandidateHash,
            polkadot_runtime_parachains.disputes.DisputeResult,
          ]
        }
        /** A dispute has been initiated. \[candidate hash, dispute location\] */
        export function DisputeInitiated(
          ...value: polkadot_runtime_parachains.disputes.pallet.Event.DisputeInitiated["value"]
        ): polkadot_runtime_parachains.disputes.pallet.Event.DisputeInitiated {
          return { type: "DisputeInitiated", value }
        }
        /** A dispute has been initiated. \[candidate hash, dispute location\] */
        export interface DisputeInitiated {
          type: "DisputeInitiated"
          value: [
            polkadot_core_primitives.CandidateHash,
            polkadot_runtime_parachains.disputes.DisputeLocation,
          ]
        }
        /**
         * A dispute has timed out due to insufficient participation.
         * `\[para id, candidate hash\]`
         */
        export function DisputeTimedOut(
          value: polkadot_runtime_parachains.disputes.pallet.Event.DisputeTimedOut["value"],
        ): polkadot_runtime_parachains.disputes.pallet.Event.DisputeTimedOut {
          return { type: "DisputeTimedOut", value }
        }
        /**
         * A dispute has timed out due to insufficient participation.
         * `\[para id, candidate hash\]`
         */
        export interface DisputeTimedOut {
          type: "DisputeTimedOut"
          value: polkadot_core_primitives.CandidateHash
        }
        /**
         * A dispute has concluded with supermajority against a candidate.
         * Block authors should no longer build on top of this head and should
         * instead revert the block at the given height. This should be the
         * number of the child of the last known valid block in the chain.
         */
        export function Revert(
          value: polkadot_runtime_parachains.disputes.pallet.Event.Revert["value"],
        ): polkadot_runtime_parachains.disputes.pallet.Event.Revert {
          return { type: "Revert", value }
        }
        /**
         * A dispute has concluded with supermajority against a candidate.
         * Block authors should no longer build on top of this head and should
         * instead revert the block at the given height. This should be the
         * number of the child of the last known valid block in the chain.
         */
        export interface Revert {
          type: "Revert"
          value: u32
        }
      }
    }
  }
  export namespace dmp {
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.dmp.pallet.Call> = _codec.$407
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call = never
    }
  }
  export namespace hrmp {
    export const $hrmpChannel: $.Codec<polkadot_runtime_parachains.hrmp.HrmpChannel> = _codec.$688
    export const $hrmpOpenChannelRequest: $.Codec<
      polkadot_runtime_parachains.hrmp.HrmpOpenChannelRequest
    > = _codec.$686
    export interface HrmpChannel {
      max_capacity: u32
      max_total_size: u32
      max_message_size: u32
      msg_count: u32
      total_size: u32
      mqc_head: primitive_types.H256 | undefined
      sender_deposit: u128
      recipient_deposit: u128
    }
    export function HrmpChannel(value: polkadot_runtime_parachains.hrmp.HrmpChannel) {
      return value
    }
    export interface HrmpOpenChannelRequest {
      confirmed: boolean
      _age: u32
      sender_deposit: u128
      max_message_size: u32
      max_capacity: u32
      max_total_size: u32
    }
    export function HrmpOpenChannelRequest(
      value: polkadot_runtime_parachains.hrmp.HrmpOpenChannelRequest,
    ) {
      return value
    }
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.hrmp.pallet.Call> = _codec.$409
      export const $error: $.Codec<polkadot_runtime_parachains.hrmp.pallet.Error> = _codec.$694
      export const $event: $.Codec<polkadot_runtime_parachains.hrmp.pallet.Event> = _codec.$111
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_init_open_channel
        | polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_accept_open_channel
        | polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_close_channel
        | polkadot_runtime_parachains.hrmp.pallet.Call.force_clean_hrmp
        | polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_open
        | polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_close
        | polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_cancel_open_request
        | polkadot_runtime_parachains.hrmp.pallet.Call.force_open_hrmp_channel
      export namespace Call {
        /**
         * This extrinsic triggers the cleanup of all the HRMP storage items that
         * a para may have. Normally this happens once per session, but this allows
         * you to trigger the cleanup immediately for a specific parachain.
         *
         * Origin must be Root.
         *
         * Number of inbound and outbound channels for `para` must be provided as witness data of weighing.
         */
        export function force_clean_hrmp(
          value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.force_clean_hrmp, "type">,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.force_clean_hrmp {
          return { type: "force_clean_hrmp", ...value }
        }
        /**
         * This extrinsic triggers the cleanup of all the HRMP storage items that
         * a para may have. Normally this happens once per session, but this allows
         * you to trigger the cleanup immediately for a specific parachain.
         *
         * Origin must be Root.
         *
         * Number of inbound and outbound channels for `para` must be provided as witness data of weighing.
         */
        export interface force_clean_hrmp {
          type: "force_clean_hrmp"
          para: polkadot_parachain.primitives.Id
          inbound: u32
          outbound: u32
        }
        /**
         * Open a channel from a `sender` to a `recipient` `ParaId` using the Root origin. Although
         * opened by Root, the `max_capacity` and `max_message_size` are still subject to the Relay
         * Chain's configured limits.
         *
         * Expected use is when one of the `ParaId`s involved in the channel is governed by the
         * Relay Chain, e.g. a common good parachain.
         */
        export function force_open_hrmp_channel(
          value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.force_open_hrmp_channel, "type">,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.force_open_hrmp_channel {
          return { type: "force_open_hrmp_channel", ...value }
        }
        /**
         * Open a channel from a `sender` to a `recipient` `ParaId` using the Root origin. Although
         * opened by Root, the `max_capacity` and `max_message_size` are still subject to the Relay
         * Chain's configured limits.
         *
         * Expected use is when one of the `ParaId`s involved in the channel is governed by the
         * Relay Chain, e.g. a common good parachain.
         */
        export interface force_open_hrmp_channel {
          type: "force_open_hrmp_channel"
          sender: polkadot_parachain.primitives.Id
          recipient: polkadot_parachain.primitives.Id
          max_capacity: u32
          max_message_size: u32
        }
        /**
         * Force process HRMP close channel requests.
         *
         * If there are pending HRMP close channel requests, you can use this
         * function process all of those requests immediately.
         *
         * Total number of closing channels must be provided as witness data of weighing.
         */
        export function force_process_hrmp_close(
          value: Omit<
            polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_close,
            "type"
          >,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_close {
          return { type: "force_process_hrmp_close", ...value }
        }
        /**
         * Force process HRMP close channel requests.
         *
         * If there are pending HRMP close channel requests, you can use this
         * function process all of those requests immediately.
         *
         * Total number of closing channels must be provided as witness data of weighing.
         */
        export interface force_process_hrmp_close {
          type: "force_process_hrmp_close"
          channels: u32
        }
        /**
         * Force process HRMP open channel requests.
         *
         * If there are pending HRMP open channel requests, you can use this
         * function process all of those requests immediately.
         *
         * Total number of opening channels must be provided as witness data of weighing.
         */
        export function force_process_hrmp_open(
          value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_open, "type">,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.force_process_hrmp_open {
          return { type: "force_process_hrmp_open", ...value }
        }
        /**
         * Force process HRMP open channel requests.
         *
         * If there are pending HRMP open channel requests, you can use this
         * function process all of those requests immediately.
         *
         * Total number of opening channels must be provided as witness data of weighing.
         */
        export interface force_process_hrmp_open {
          type: "force_process_hrmp_open"
          channels: u32
        }
        /**
         * Accept a pending open channel request from the given sender.
         *
         * The channel will be opened only on the next session boundary.
         */
        export function hrmp_accept_open_channel(
          value: Omit<
            polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_accept_open_channel,
            "type"
          >,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_accept_open_channel {
          return { type: "hrmp_accept_open_channel", ...value }
        }
        /**
         * Accept a pending open channel request from the given sender.
         *
         * The channel will be opened only on the next session boundary.
         */
        export interface hrmp_accept_open_channel {
          type: "hrmp_accept_open_channel"
          sender: polkadot_parachain.primitives.Id
        }
        /**
         * This cancels a pending open channel request. It can be canceled by either of the sender
         * or the recipient for that request. The origin must be either of those.
         *
         * The cancellation happens immediately. It is not possible to cancel the request if it is
         * already accepted.
         *
         * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
         * witness data.
         */
        export function hrmp_cancel_open_request(
          value: Omit<
            polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_cancel_open_request,
            "type"
          >,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_cancel_open_request {
          return { type: "hrmp_cancel_open_request", ...value }
        }
        /**
         * This cancels a pending open channel request. It can be canceled by either of the sender
         * or the recipient for that request. The origin must be either of those.
         *
         * The cancellation happens immediately. It is not possible to cancel the request if it is
         * already accepted.
         *
         * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
         * witness data.
         */
        export interface hrmp_cancel_open_request {
          type: "hrmp_cancel_open_request"
          channel_id: polkadot_parachain.primitives.HrmpChannelId
          open_requests: u32
        }
        /**
         * Initiate unilateral closing of a channel. The origin must be either the sender or the
         * recipient in the channel being closed.
         *
         * The closure can only happen on a session change.
         */
        export function hrmp_close_channel(
          value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_close_channel, "type">,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_close_channel {
          return { type: "hrmp_close_channel", ...value }
        }
        /**
         * Initiate unilateral closing of a channel. The origin must be either the sender or the
         * recipient in the channel being closed.
         *
         * The closure can only happen on a session change.
         */
        export interface hrmp_close_channel {
          type: "hrmp_close_channel"
          channel_id: polkadot_parachain.primitives.HrmpChannelId
        }
        /**
         * Initiate opening a channel from a parachain to a given recipient with given channel
         * parameters.
         *
         * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
         * - `proposed_max_message_size` - specifies the maximum size of the messages.
         *
         * These numbers are a subject to the relay-chain configuration limits.
         *
         * The channel can be opened only after the recipient confirms it and only on a session
         * change.
         */
        export function hrmp_init_open_channel(
          value: Omit<polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_init_open_channel, "type">,
        ): polkadot_runtime_parachains.hrmp.pallet.Call.hrmp_init_open_channel {
          return { type: "hrmp_init_open_channel", ...value }
        }
        /**
         * Initiate opening a channel from a parachain to a given recipient with given channel
         * parameters.
         *
         * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
         * - `proposed_max_message_size` - specifies the maximum size of the messages.
         *
         * These numbers are a subject to the relay-chain configuration limits.
         *
         * The channel can be opened only after the recipient confirms it and only on a session
         * change.
         */
        export interface hrmp_init_open_channel {
          type: "hrmp_init_open_channel"
          recipient: polkadot_parachain.primitives.Id
          proposed_max_capacity: u32
          proposed_max_message_size: u32
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "OpenHrmpChannelToSelf"
        | "OpenHrmpChannelInvalidRecipient"
        | "OpenHrmpChannelZeroCapacity"
        | "OpenHrmpChannelCapacityExceedsLimit"
        | "OpenHrmpChannelZeroMessageSize"
        | "OpenHrmpChannelMessageSizeExceedsLimit"
        | "OpenHrmpChannelAlreadyExists"
        | "OpenHrmpChannelAlreadyRequested"
        | "OpenHrmpChannelLimitExceeded"
        | "AcceptHrmpChannelDoesntExist"
        | "AcceptHrmpChannelAlreadyConfirmed"
        | "AcceptHrmpChannelLimitExceeded"
        | "CloseHrmpChannelUnauthorized"
        | "CloseHrmpChannelDoesntExist"
        | "CloseHrmpChannelAlreadyUnderway"
        | "CancelHrmpOpenChannelUnauthorized"
        | "OpenHrmpChannelDoesntExist"
        | "OpenHrmpChannelAlreadyConfirmed"
        | "WrongWitness"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelRequested
        | polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelCanceled
        | polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelAccepted
        | polkadot_runtime_parachains.hrmp.pallet.Event.ChannelClosed
        | polkadot_runtime_parachains.hrmp.pallet.Event.HrmpChannelForceOpened
      export namespace Event {
        /** HRMP channel closed. `[by_parachain, channel_id]` */
        export function ChannelClosed(
          ...value: polkadot_runtime_parachains.hrmp.pallet.Event.ChannelClosed["value"]
        ): polkadot_runtime_parachains.hrmp.pallet.Event.ChannelClosed {
          return { type: "ChannelClosed", value }
        }
        /** HRMP channel closed. `[by_parachain, channel_id]` */
        export interface ChannelClosed {
          type: "ChannelClosed"
          value: [polkadot_parachain.primitives.Id, polkadot_parachain.primitives.HrmpChannelId]
        }
        /**
         * An HRMP channel was opened via Root origin.
         * `[sender, recipient, proposed_max_capacity, proposed_max_message_size]`
         */
        export function HrmpChannelForceOpened(
          ...value: polkadot_runtime_parachains.hrmp.pallet.Event.HrmpChannelForceOpened["value"]
        ): polkadot_runtime_parachains.hrmp.pallet.Event.HrmpChannelForceOpened {
          return { type: "HrmpChannelForceOpened", value }
        }
        /**
         * An HRMP channel was opened via Root origin.
         * `[sender, recipient, proposed_max_capacity, proposed_max_message_size]`
         */
        export interface HrmpChannelForceOpened {
          type: "HrmpChannelForceOpened"
          value: [polkadot_parachain.primitives.Id, polkadot_parachain.primitives.Id, u32, u32]
        }
        /** Open HRMP channel accepted. `[sender, recipient]` */
        export function OpenChannelAccepted(
          ...value: polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelAccepted["value"]
        ): polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelAccepted {
          return { type: "OpenChannelAccepted", value }
        }
        /** Open HRMP channel accepted. `[sender, recipient]` */
        export interface OpenChannelAccepted {
          type: "OpenChannelAccepted"
          value: [polkadot_parachain.primitives.Id, polkadot_parachain.primitives.Id]
        }
        /**
         * An HRMP channel request sent by the receiver was canceled by either party.
         * `[by_parachain, channel_id]`
         */
        export function OpenChannelCanceled(
          ...value: polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelCanceled["value"]
        ): polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelCanceled {
          return { type: "OpenChannelCanceled", value }
        }
        /**
         * An HRMP channel request sent by the receiver was canceled by either party.
         * `[by_parachain, channel_id]`
         */
        export interface OpenChannelCanceled {
          type: "OpenChannelCanceled"
          value: [polkadot_parachain.primitives.Id, polkadot_parachain.primitives.HrmpChannelId]
        }
        /**
         * Open HRMP channel requested.
         * `[sender, recipient, proposed_max_capacity, proposed_max_message_size]`
         */
        export function OpenChannelRequested(
          ...value: polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelRequested["value"]
        ): polkadot_runtime_parachains.hrmp.pallet.Event.OpenChannelRequested {
          return { type: "OpenChannelRequested", value }
        }
        /**
         * Open HRMP channel requested.
         * `[sender, recipient, proposed_max_capacity, proposed_max_message_size]`
         */
        export interface OpenChannelRequested {
          type: "OpenChannelRequested"
          value: [polkadot_parachain.primitives.Id, polkadot_parachain.primitives.Id, u32, u32]
        }
      }
    }
  }
  export namespace inclusion {
    export const $availabilityBitfieldRecord: $.Codec<
      polkadot_runtime_parachains.inclusion.AvailabilityBitfieldRecord
    > = _codec.$644
    export const $candidatePendingAvailability: $.Codec<
      polkadot_runtime_parachains.inclusion.CandidatePendingAvailability
    > = _codec.$645
    export interface AvailabilityBitfieldRecord {
      bitfield: polkadot_primitives.v2.AvailabilityBitfield
      submitted_at: u32
    }
    export function AvailabilityBitfieldRecord(
      value: polkadot_runtime_parachains.inclusion.AvailabilityBitfieldRecord,
    ) {
      return value
    }
    export interface CandidatePendingAvailability {
      core: polkadot_primitives.v2.CoreIndex
      hash: polkadot_core_primitives.CandidateHash
      descriptor: polkadot_primitives.v2.CandidateDescriptor
      availability_votes: BitSequence
      backers: BitSequence
      relay_parent_number: u32
      backed_in_number: u32
      backing_group: polkadot_primitives.v2.GroupIndex
    }
    export function CandidatePendingAvailability(
      value: polkadot_runtime_parachains.inclusion.CandidatePendingAvailability,
    ) {
      return value
    }
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.inclusion.pallet.Call> = _codec.$377
      export const $error: $.Codec<polkadot_runtime_parachains.inclusion.pallet.Error> = _codec.$646
      export const $event: $.Codec<polkadot_runtime_parachains.inclusion.pallet.Event> = _codec.$95
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call = never
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "UnsortedOrDuplicateValidatorIndices"
        | "UnsortedOrDuplicateDisputeStatementSet"
        | "UnsortedOrDuplicateBackedCandidates"
        | "UnexpectedRelayParent"
        | "WrongBitfieldSize"
        | "BitfieldAllZeros"
        | "BitfieldDuplicateOrUnordered"
        | "ValidatorIndexOutOfBounds"
        | "InvalidBitfieldSignature"
        | "UnscheduledCandidate"
        | "CandidateScheduledBeforeParaFree"
        | "WrongCollator"
        | "ScheduledOutOfOrder"
        | "HeadDataTooLarge"
        | "PrematureCodeUpgrade"
        | "NewCodeTooLarge"
        | "CandidateNotInParentContext"
        | "InvalidGroupIndex"
        | "InsufficientBacking"
        | "InvalidBacking"
        | "NotCollatorSigned"
        | "ValidationDataHashMismatch"
        | "IncorrectDownwardMessageHandling"
        | "InvalidUpwardMessages"
        | "HrmpWatermarkMishandling"
        | "InvalidOutboundHrmp"
        | "InvalidValidationCodeHash"
        | "ParaHeadMismatch"
        | "BitfieldReferencesFreedCore"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_parachains.inclusion.pallet.Event.CandidateBacked
        | polkadot_runtime_parachains.inclusion.pallet.Event.CandidateIncluded
        | polkadot_runtime_parachains.inclusion.pallet.Event.CandidateTimedOut
      export namespace Event {
        /** A candidate was backed. `[candidate, head_data]` */
        export function CandidateBacked(
          ...value: polkadot_runtime_parachains.inclusion.pallet.Event.CandidateBacked["value"]
        ): polkadot_runtime_parachains.inclusion.pallet.Event.CandidateBacked {
          return { type: "CandidateBacked", value }
        }
        /** A candidate was backed. `[candidate, head_data]` */
        export interface CandidateBacked {
          type: "CandidateBacked"
          value: [
            polkadot_primitives.v2.CandidateReceipt,
            polkadot_parachain.primitives.HeadData,
            polkadot_primitives.v2.CoreIndex,
            polkadot_primitives.v2.GroupIndex,
          ]
        }
        /** A candidate was included. `[candidate, head_data]` */
        export function CandidateIncluded(
          ...value: polkadot_runtime_parachains.inclusion.pallet.Event.CandidateIncluded["value"]
        ): polkadot_runtime_parachains.inclusion.pallet.Event.CandidateIncluded {
          return { type: "CandidateIncluded", value }
        }
        /** A candidate was included. `[candidate, head_data]` */
        export interface CandidateIncluded {
          type: "CandidateIncluded"
          value: [
            polkadot_primitives.v2.CandidateReceipt,
            polkadot_parachain.primitives.HeadData,
            polkadot_primitives.v2.CoreIndex,
            polkadot_primitives.v2.GroupIndex,
          ]
        }
        /** A candidate timed out. `[candidate, head_data]` */
        export function CandidateTimedOut(
          ...value: polkadot_runtime_parachains.inclusion.pallet.Event.CandidateTimedOut["value"]
        ): polkadot_runtime_parachains.inclusion.pallet.Event.CandidateTimedOut {
          return { type: "CandidateTimedOut", value }
        }
        /** A candidate timed out. `[candidate, head_data]` */
        export interface CandidateTimedOut {
          type: "CandidateTimedOut"
          value: [
            polkadot_primitives.v2.CandidateReceipt,
            polkadot_parachain.primitives.HeadData,
            polkadot_primitives.v2.CoreIndex,
          ]
        }
      }
    }
  }
  export namespace initializer {
    export const $bufferedSessionChange: $.Codec<
      polkadot_runtime_parachains.initializer.BufferedSessionChange
    > = _codec.$681
    export interface BufferedSessionChange {
      validators: Array<polkadot_primitives.v2.validator_app.Public>
      queued: Array<polkadot_primitives.v2.validator_app.Public>
      session_index: u32
    }
    export function BufferedSessionChange(
      value: polkadot_runtime_parachains.initializer.BufferedSessionChange,
    ) {
      return value
    }
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.initializer.pallet.Call> = _codec.$406
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call = polkadot_runtime_parachains.initializer.pallet.Call.force_approve
      export namespace Call {
        /**
         * Issue a signal to the consensus engine to forcibly act as though all parachain
         * blocks in all relay chain blocks up to and including the given number in the current
         * chain are valid and should be finalized.
         */
        export function force_approve(
          value: Omit<polkadot_runtime_parachains.initializer.pallet.Call.force_approve, "type">,
        ): polkadot_runtime_parachains.initializer.pallet.Call.force_approve {
          return { type: "force_approve", ...value }
        }
        /**
         * Issue a signal to the consensus engine to forcibly act as though all parachain
         * blocks in all relay chain blocks up to and including the given number in the current
         * chain are valid and should be finalized.
         */
        export interface force_approve {
          type: "force_approve"
          up_to: u32
        }
      }
    }
  }
  export namespace origin {
    export namespace pallet {
      export const $origin: $.Codec<polkadot_runtime_parachains.origin.pallet.Origin> = _codec.$260
      export type Origin = polkadot_runtime_parachains.origin.pallet.Origin.Parachain
      export namespace Origin {
        export function Parachain(
          value: polkadot_runtime_parachains.origin.pallet.Origin.Parachain["value"],
        ): polkadot_runtime_parachains.origin.pallet.Origin.Parachain {
          return { type: "Parachain", value }
        }
        export interface Parachain {
          type: "Parachain"
          value: polkadot_parachain.primitives.Id
        }
      }
    }
  }
  export namespace paras {
    export const $paraGenesisArgs: $.Codec<polkadot_runtime_parachains.paras.ParaGenesisArgs> =
      _codec.$678
    export const $paraLifecycle: $.Codec<polkadot_runtime_parachains.paras.ParaLifecycle> =
      _codec.$670
    export const $paraPastCodeMeta: $.Codec<polkadot_runtime_parachains.paras.ParaPastCodeMeta> =
      _codec.$672
    export const $pvfCheckActiveVoteState: $.Codec<
      polkadot_runtime_parachains.paras.PvfCheckActiveVoteState
    > = _codec.$666
    export const $pvfCheckCause: $.Codec<polkadot_runtime_parachains.paras.PvfCheckCause> =
      _codec.$668
    export const $replacementTimes: $.Codec<polkadot_runtime_parachains.paras.ReplacementTimes> =
      _codec.$674
    export interface ParaGenesisArgs {
      genesis_head: polkadot_parachain.primitives.HeadData
      validation_code: polkadot_parachain.primitives.ValidationCode
      parachain: boolean
    }
    export function ParaGenesisArgs(value: polkadot_runtime_parachains.paras.ParaGenesisArgs) {
      return value
    }
    export type ParaLifecycle =
      | "Onboarding"
      | "Parathread"
      | "Parachain"
      | "UpgradingParathread"
      | "DowngradingParachain"
      | "OffboardingParathread"
      | "OffboardingParachain"
    export interface ParaPastCodeMeta {
      upgrade_times: Array<polkadot_runtime_parachains.paras.ReplacementTimes>
      last_pruned: u32 | undefined
    }
    export function ParaPastCodeMeta(value: polkadot_runtime_parachains.paras.ParaPastCodeMeta) {
      return value
    }
    export interface PvfCheckActiveVoteState {
      votes_accept: BitSequence
      votes_reject: BitSequence
      age: u32
      created_at: u32
      causes: Array<polkadot_runtime_parachains.paras.PvfCheckCause>
    }
    export function PvfCheckActiveVoteState(
      value: polkadot_runtime_parachains.paras.PvfCheckActiveVoteState,
    ) {
      return value
    }
    export type PvfCheckCause =
      | polkadot_runtime_parachains.paras.PvfCheckCause.Onboarding
      | polkadot_runtime_parachains.paras.PvfCheckCause.Upgrade
    export namespace PvfCheckCause {
      export function Onboarding(
        value: polkadot_runtime_parachains.paras.PvfCheckCause.Onboarding["value"],
      ): polkadot_runtime_parachains.paras.PvfCheckCause.Onboarding {
        return { type: "Onboarding", value }
      }
      export interface Onboarding {
        type: "Onboarding"
        value: polkadot_parachain.primitives.Id
      }
      export function Upgrade(
        value: Omit<polkadot_runtime_parachains.paras.PvfCheckCause.Upgrade, "type">,
      ): polkadot_runtime_parachains.paras.PvfCheckCause.Upgrade {
        return { type: "Upgrade", ...value }
      }
      export interface Upgrade {
        type: "Upgrade"
        id: polkadot_parachain.primitives.Id
        relay_parent_number: u32
      }
    }
    export interface ReplacementTimes {
      expected_at: u32
      activated_at: u32
    }
    export function ReplacementTimes(value: polkadot_runtime_parachains.paras.ReplacementTimes) {
      return value
    }
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.paras.pallet.Call> = _codec.$404
      export const $error: $.Codec<polkadot_runtime_parachains.paras.pallet.Error> = _codec.$679
      export const $event: $.Codec<polkadot_runtime_parachains.paras.pallet.Event> = _codec.$107
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call =
        | polkadot_runtime_parachains.paras.pallet.Call.force_set_current_code
        | polkadot_runtime_parachains.paras.pallet.Call.force_set_current_head
        | polkadot_runtime_parachains.paras.pallet.Call.force_schedule_code_upgrade
        | polkadot_runtime_parachains.paras.pallet.Call.force_note_new_head
        | polkadot_runtime_parachains.paras.pallet.Call.force_queue_action
        | polkadot_runtime_parachains.paras.pallet.Call.add_trusted_validation_code
        | polkadot_runtime_parachains.paras.pallet.Call.poke_unused_validation_code
        | polkadot_runtime_parachains.paras.pallet.Call.include_pvf_check_statement
      export namespace Call {
        /**
         * Adds the validation code to the storage.
         *
         * The code will not be added if it is already present. Additionally, if PVF pre-checking
         * is running for that code, it will be instantly accepted.
         *
         * Otherwise, the code will be added into the storage. Note that the code will be added
         * into storage with reference count 0. This is to account the fact that there are no users
         * for this code yet. The caller will have to make sure that this code eventually gets
         * used by some parachain or removed from the storage to avoid storage leaks. For the latter
         * prefer to use the `poke_unused_validation_code` dispatchable to raw storage manipulation.
         *
         * This function is mainly meant to be used for upgrading parachains that do not follow
         * the go-ahead signal while the PVF pre-checking feature is enabled.
         */
        export function add_trusted_validation_code(
          value: Omit<
            polkadot_runtime_parachains.paras.pallet.Call.add_trusted_validation_code,
            "type"
          >,
        ): polkadot_runtime_parachains.paras.pallet.Call.add_trusted_validation_code {
          return { type: "add_trusted_validation_code", ...value }
        }
        /**
         * Adds the validation code to the storage.
         *
         * The code will not be added if it is already present. Additionally, if PVF pre-checking
         * is running for that code, it will be instantly accepted.
         *
         * Otherwise, the code will be added into the storage. Note that the code will be added
         * into storage with reference count 0. This is to account the fact that there are no users
         * for this code yet. The caller will have to make sure that this code eventually gets
         * used by some parachain or removed from the storage to avoid storage leaks. For the latter
         * prefer to use the `poke_unused_validation_code` dispatchable to raw storage manipulation.
         *
         * This function is mainly meant to be used for upgrading parachains that do not follow
         * the go-ahead signal while the PVF pre-checking feature is enabled.
         */
        export interface add_trusted_validation_code {
          type: "add_trusted_validation_code"
          validation_code: polkadot_parachain.primitives.ValidationCode
        }
        /** Note a new block head for para within the context of the current block. */
        export function force_note_new_head(
          value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_note_new_head, "type">,
        ): polkadot_runtime_parachains.paras.pallet.Call.force_note_new_head {
          return { type: "force_note_new_head", ...value }
        }
        /** Note a new block head for para within the context of the current block. */
        export interface force_note_new_head {
          type: "force_note_new_head"
          para: polkadot_parachain.primitives.Id
          new_head: polkadot_parachain.primitives.HeadData
        }
        /**
         * Put a parachain directly into the next session's action queue.
         * We can't queue it any sooner than this without going into the
         * initializer...
         */
        export function force_queue_action(
          value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_queue_action, "type">,
        ): polkadot_runtime_parachains.paras.pallet.Call.force_queue_action {
          return { type: "force_queue_action", ...value }
        }
        /**
         * Put a parachain directly into the next session's action queue.
         * We can't queue it any sooner than this without going into the
         * initializer...
         */
        export interface force_queue_action {
          type: "force_queue_action"
          para: polkadot_parachain.primitives.Id
        }
        /** Schedule an upgrade as if it was scheduled in the given relay parent block. */
        export function force_schedule_code_upgrade(
          value: Omit<
            polkadot_runtime_parachains.paras.pallet.Call.force_schedule_code_upgrade,
            "type"
          >,
        ): polkadot_runtime_parachains.paras.pallet.Call.force_schedule_code_upgrade {
          return { type: "force_schedule_code_upgrade", ...value }
        }
        /** Schedule an upgrade as if it was scheduled in the given relay parent block. */
        export interface force_schedule_code_upgrade {
          type: "force_schedule_code_upgrade"
          para: polkadot_parachain.primitives.Id
          new_code: polkadot_parachain.primitives.ValidationCode
          relay_parent_number: u32
        }
        /** Set the storage for the parachain validation code immediately. */
        export function force_set_current_code(
          value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_set_current_code, "type">,
        ): polkadot_runtime_parachains.paras.pallet.Call.force_set_current_code {
          return { type: "force_set_current_code", ...value }
        }
        /** Set the storage for the parachain validation code immediately. */
        export interface force_set_current_code {
          type: "force_set_current_code"
          para: polkadot_parachain.primitives.Id
          new_code: polkadot_parachain.primitives.ValidationCode
        }
        /** Set the storage for the current parachain head data immediately. */
        export function force_set_current_head(
          value: Omit<polkadot_runtime_parachains.paras.pallet.Call.force_set_current_head, "type">,
        ): polkadot_runtime_parachains.paras.pallet.Call.force_set_current_head {
          return { type: "force_set_current_head", ...value }
        }
        /** Set the storage for the current parachain head data immediately. */
        export interface force_set_current_head {
          type: "force_set_current_head"
          para: polkadot_parachain.primitives.Id
          new_head: polkadot_parachain.primitives.HeadData
        }
        /**
         * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
         * enacts the results if that was the last vote before achieving the supermajority.
         */
        export function include_pvf_check_statement(
          value: Omit<
            polkadot_runtime_parachains.paras.pallet.Call.include_pvf_check_statement,
            "type"
          >,
        ): polkadot_runtime_parachains.paras.pallet.Call.include_pvf_check_statement {
          return { type: "include_pvf_check_statement", ...value }
        }
        /**
         * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
         * enacts the results if that was the last vote before achieving the supermajority.
         */
        export interface include_pvf_check_statement {
          type: "include_pvf_check_statement"
          stmt: polkadot_primitives.v2.PvfCheckStatement
          signature: polkadot_primitives.v2.validator_app.Signature
        }
        /**
         * Remove the validation code from the storage iff the reference count is 0.
         *
         * This is better than removing the storage directly, because it will not remove the code
         * that was suddenly got used by some parachain while this dispatchable was pending
         * dispatching.
         */
        export function poke_unused_validation_code(
          value: Omit<
            polkadot_runtime_parachains.paras.pallet.Call.poke_unused_validation_code,
            "type"
          >,
        ): polkadot_runtime_parachains.paras.pallet.Call.poke_unused_validation_code {
          return { type: "poke_unused_validation_code", ...value }
        }
        /**
         * Remove the validation code from the storage iff the reference count is 0.
         *
         * This is better than removing the storage directly, because it will not remove the code
         * that was suddenly got used by some parachain while this dispatchable was pending
         * dispatching.
         */
        export interface poke_unused_validation_code {
          type: "poke_unused_validation_code"
          validation_code_hash: polkadot_parachain.primitives.ValidationCodeHash
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "NotRegistered"
        | "CannotOnboard"
        | "CannotOffboard"
        | "CannotUpgrade"
        | "CannotDowngrade"
        | "PvfCheckStatementStale"
        | "PvfCheckStatementFuture"
        | "PvfCheckValidatorIndexOutOfBounds"
        | "PvfCheckInvalidSignature"
        | "PvfCheckDoubleVote"
        | "PvfCheckSubjectInvalid"
        | "PvfCheckDisabled"
        | "CannotUpgradeCode"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_parachains.paras.pallet.Event.CurrentCodeUpdated
        | polkadot_runtime_parachains.paras.pallet.Event.CurrentHeadUpdated
        | polkadot_runtime_parachains.paras.pallet.Event.CodeUpgradeScheduled
        | polkadot_runtime_parachains.paras.pallet.Event.NewHeadNoted
        | polkadot_runtime_parachains.paras.pallet.Event.ActionQueued
        | polkadot_runtime_parachains.paras.pallet.Event.PvfCheckStarted
        | polkadot_runtime_parachains.paras.pallet.Event.PvfCheckAccepted
        | polkadot_runtime_parachains.paras.pallet.Event.PvfCheckRejected
      export namespace Event {
        /** A para has been queued to execute pending actions. `para_id` */
        export function ActionQueued(
          ...value: polkadot_runtime_parachains.paras.pallet.Event.ActionQueued["value"]
        ): polkadot_runtime_parachains.paras.pallet.Event.ActionQueued {
          return { type: "ActionQueued", value }
        }
        /** A para has been queued to execute pending actions. `para_id` */
        export interface ActionQueued {
          type: "ActionQueued"
          value: [polkadot_parachain.primitives.Id, u32]
        }
        /** A code upgrade has been scheduled for a Para. `para_id` */
        export function CodeUpgradeScheduled(
          value: polkadot_runtime_parachains.paras.pallet.Event.CodeUpgradeScheduled["value"],
        ): polkadot_runtime_parachains.paras.pallet.Event.CodeUpgradeScheduled {
          return { type: "CodeUpgradeScheduled", value }
        }
        /** A code upgrade has been scheduled for a Para. `para_id` */
        export interface CodeUpgradeScheduled {
          type: "CodeUpgradeScheduled"
          value: polkadot_parachain.primitives.Id
        }
        /** Current code has been updated for a Para. `para_id` */
        export function CurrentCodeUpdated(
          value: polkadot_runtime_parachains.paras.pallet.Event.CurrentCodeUpdated["value"],
        ): polkadot_runtime_parachains.paras.pallet.Event.CurrentCodeUpdated {
          return { type: "CurrentCodeUpdated", value }
        }
        /** Current code has been updated for a Para. `para_id` */
        export interface CurrentCodeUpdated {
          type: "CurrentCodeUpdated"
          value: polkadot_parachain.primitives.Id
        }
        /** Current head has been updated for a Para. `para_id` */
        export function CurrentHeadUpdated(
          value: polkadot_runtime_parachains.paras.pallet.Event.CurrentHeadUpdated["value"],
        ): polkadot_runtime_parachains.paras.pallet.Event.CurrentHeadUpdated {
          return { type: "CurrentHeadUpdated", value }
        }
        /** Current head has been updated for a Para. `para_id` */
        export interface CurrentHeadUpdated {
          type: "CurrentHeadUpdated"
          value: polkadot_parachain.primitives.Id
        }
        /** A new head has been noted for a Para. `para_id` */
        export function NewHeadNoted(
          value: polkadot_runtime_parachains.paras.pallet.Event.NewHeadNoted["value"],
        ): polkadot_runtime_parachains.paras.pallet.Event.NewHeadNoted {
          return { type: "NewHeadNoted", value }
        }
        /** A new head has been noted for a Para. `para_id` */
        export interface NewHeadNoted {
          type: "NewHeadNoted"
          value: polkadot_parachain.primitives.Id
        }
        /**
         * The given validation code was accepted by the PVF pre-checking vote.
         * `code_hash` `para_id`
         */
        export function PvfCheckAccepted(
          ...value: polkadot_runtime_parachains.paras.pallet.Event.PvfCheckAccepted["value"]
        ): polkadot_runtime_parachains.paras.pallet.Event.PvfCheckAccepted {
          return { type: "PvfCheckAccepted", value }
        }
        /**
         * The given validation code was accepted by the PVF pre-checking vote.
         * `code_hash` `para_id`
         */
        export interface PvfCheckAccepted {
          type: "PvfCheckAccepted"
          value: [
            polkadot_parachain.primitives.ValidationCodeHash,
            polkadot_parachain.primitives.Id,
          ]
        }
        /**
         * The given validation code was rejected by the PVF pre-checking vote.
         * `code_hash` `para_id`
         */
        export function PvfCheckRejected(
          ...value: polkadot_runtime_parachains.paras.pallet.Event.PvfCheckRejected["value"]
        ): polkadot_runtime_parachains.paras.pallet.Event.PvfCheckRejected {
          return { type: "PvfCheckRejected", value }
        }
        /**
         * The given validation code was rejected by the PVF pre-checking vote.
         * `code_hash` `para_id`
         */
        export interface PvfCheckRejected {
          type: "PvfCheckRejected"
          value: [
            polkadot_parachain.primitives.ValidationCodeHash,
            polkadot_parachain.primitives.Id,
          ]
        }
        /**
         * The given para either initiated or subscribed to a PVF check for the given validation
         * code. `code_hash` `para_id`
         */
        export function PvfCheckStarted(
          ...value: polkadot_runtime_parachains.paras.pallet.Event.PvfCheckStarted["value"]
        ): polkadot_runtime_parachains.paras.pallet.Event.PvfCheckStarted {
          return { type: "PvfCheckStarted", value }
        }
        /**
         * The given para either initiated or subscribed to a PVF check for the given validation
         * code. `code_hash` `para_id`
         */
        export interface PvfCheckStarted {
          type: "PvfCheckStarted"
          value: [
            polkadot_parachain.primitives.ValidationCodeHash,
            polkadot_parachain.primitives.Id,
          ]
        }
      }
    }
  }
  export namespace paras_inherent {
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.paras_inherent.pallet.Call> =
        _codec.$378
      export const $error: $.Codec<polkadot_runtime_parachains.paras_inherent.pallet.Error> =
        _codec.$652
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call = polkadot_runtime_parachains.paras_inherent.pallet.Call.enter
      export namespace Call {
        /** Enter the paras inherent. This will process bitfields and backed candidates. */
        export function enter(
          value: Omit<polkadot_runtime_parachains.paras_inherent.pallet.Call.enter, "type">,
        ): polkadot_runtime_parachains.paras_inherent.pallet.Call.enter {
          return { type: "enter", ...value }
        }
        /** Enter the paras inherent. This will process bitfields and backed candidates. */
        export interface enter {
          type: "enter"
          data: polkadot_primitives.v2.InherentData
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error =
        | "TooManyInclusionInherents"
        | "InvalidParentHeader"
        | "CandidateConcludedInvalid"
        | "InherentOverweight"
        | "DisputeStatementsUnsortedOrDuplicates"
        | "DisputeInvalid"
    }
  }
  export namespace scheduler {
    export const $assignmentKind: $.Codec<polkadot_runtime_parachains.scheduler.AssignmentKind> =
      _codec.$665
    export const $coreAssignment: $.Codec<polkadot_runtime_parachains.scheduler.CoreAssignment> =
      _codec.$664
    export const $parathreadClaimQueue: $.Codec<
      polkadot_runtime_parachains.scheduler.ParathreadClaimQueue
    > = _codec.$654
    export const $queuedParathread: $.Codec<
      polkadot_runtime_parachains.scheduler.QueuedParathread
    > = _codec.$656
    export type AssignmentKind =
      | polkadot_runtime_parachains.scheduler.AssignmentKind.Parachain
      | polkadot_runtime_parachains.scheduler.AssignmentKind.Parathread
    export namespace AssignmentKind {
      export function Parachain(): polkadot_runtime_parachains.scheduler.AssignmentKind.Parachain {
        return { type: "Parachain" }
      }
      export interface Parachain {
        type: "Parachain"
      }
      export function Parathread(
        ...value: polkadot_runtime_parachains.scheduler.AssignmentKind.Parathread["value"]
      ): polkadot_runtime_parachains.scheduler.AssignmentKind.Parathread {
        return { type: "Parathread", value }
      }
      export interface Parathread {
        type: "Parathread"
        value: [polkadot_primitives.v2.collator_app.Public, u32]
      }
    }
    export interface CoreAssignment {
      core: polkadot_primitives.v2.CoreIndex
      para_id: polkadot_parachain.primitives.Id
      kind: polkadot_runtime_parachains.scheduler.AssignmentKind
      group_idx: polkadot_primitives.v2.GroupIndex
    }
    export function CoreAssignment(value: polkadot_runtime_parachains.scheduler.CoreAssignment) {
      return value
    }
    export interface ParathreadClaimQueue {
      queue: Array<polkadot_runtime_parachains.scheduler.QueuedParathread>
      next_core_offset: u32
    }
    export function ParathreadClaimQueue(
      value: polkadot_runtime_parachains.scheduler.ParathreadClaimQueue,
    ) {
      return value
    }
    export interface QueuedParathread {
      claim: polkadot_primitives.v2.ParathreadEntry
      core_offset: u32
    }
    export function QueuedParathread(
      value: polkadot_runtime_parachains.scheduler.QueuedParathread,
    ) {
      return value
    }
  }
  export namespace shared {
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.shared.pallet.Call> = _codec.$376
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call = never
    }
  }
  export namespace ump {
    export namespace pallet {
      export const $call: $.Codec<polkadot_runtime_parachains.ump.pallet.Call> = _codec.$408
      export const $error: $.Codec<polkadot_runtime_parachains.ump.pallet.Error> = _codec.$685
      export const $event: $.Codec<polkadot_runtime_parachains.ump.pallet.Event> = _codec.$108
      /** Contains one variant per dispatchable that can be called by an extrinsic. */
      export type Call = polkadot_runtime_parachains.ump.pallet.Call.service_overweight
      export namespace Call {
        /**
         * Service a single overweight upward message.
         *
         * - `origin`: Must pass `ExecuteOverweightOrigin`.
         * - `index`: The index of the overweight message to service.
         * - `weight_limit`: The amount of weight that message execution may take.
         *
         * Errors:
         * - `UnknownMessageIndex`: Message of `index` is unknown.
         * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
         *
         * Events:
         * - `OverweightServiced`: On success.
         */
        export function service_overweight(
          value: Omit<polkadot_runtime_parachains.ump.pallet.Call.service_overweight, "type">,
        ): polkadot_runtime_parachains.ump.pallet.Call.service_overweight {
          return { type: "service_overweight", ...value }
        }
        /**
         * Service a single overweight upward message.
         *
         * - `origin`: Must pass `ExecuteOverweightOrigin`.
         * - `index`: The index of the overweight message to service.
         * - `weight_limit`: The amount of weight that message execution may take.
         *
         * Errors:
         * - `UnknownMessageIndex`: Message of `index` is unknown.
         * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
         *
         * Events:
         * - `OverweightServiced`: On success.
         */
        export interface service_overweight {
          type: "service_overweight"
          index: u64
          weight_limit: sp_weights.weight_v2.Weight
        }
      }
      /** Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/) of this pallet. */
      export type Error = "UnknownMessageIndex" | "WeightOverLimit"
      /** The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted by this pallet. */
      export type Event =
        | polkadot_runtime_parachains.ump.pallet.Event.InvalidFormat
        | polkadot_runtime_parachains.ump.pallet.Event.UnsupportedVersion
        | polkadot_runtime_parachains.ump.pallet.Event.ExecutedUpward
        | polkadot_runtime_parachains.ump.pallet.Event.WeightExhausted
        | polkadot_runtime_parachains.ump.pallet.Event.UpwardMessagesReceived
        | polkadot_runtime_parachains.ump.pallet.Event.OverweightEnqueued
        | polkadot_runtime_parachains.ump.pallet.Event.OverweightServiced
      export namespace Event {
        /**
         * Upward message executed with the given outcome.
         * \[ id, outcome \]
         */
        export function ExecutedUpward(
          ...value: polkadot_runtime_parachains.ump.pallet.Event.ExecutedUpward["value"]
        ): polkadot_runtime_parachains.ump.pallet.Event.ExecutedUpward {
          return { type: "ExecutedUpward", value }
        }
        /**
         * Upward message executed with the given outcome.
         * \[ id, outcome \]
         */
        export interface ExecutedUpward {
          type: "ExecutedUpward"
          value: [Uint8Array, xcm.v2.traits.Outcome]
        }
        /**
         * Upward message is invalid XCM.
         * \[ id \]
         */
        export function InvalidFormat(
          value: polkadot_runtime_parachains.ump.pallet.Event.InvalidFormat["value"],
        ): polkadot_runtime_parachains.ump.pallet.Event.InvalidFormat {
          return { type: "InvalidFormat", value }
        }
        /**
         * Upward message is invalid XCM.
         * \[ id \]
         */
        export interface InvalidFormat {
          type: "InvalidFormat"
          value: Uint8Array
        }
        /**
         * The weight budget was exceeded for an individual upward message.
         *
         * This message can be later dispatched manually using `service_overweight` dispatchable
         * using the assigned `overweight_index`.
         *
         * \[ para, id, overweight_index, required \]
         */
        export function OverweightEnqueued(
          ...value: polkadot_runtime_parachains.ump.pallet.Event.OverweightEnqueued["value"]
        ): polkadot_runtime_parachains.ump.pallet.Event.OverweightEnqueued {
          return { type: "OverweightEnqueued", value }
        }
        /**
         * The weight budget was exceeded for an individual upward message.
         *
         * This message can be later dispatched manually using `service_overweight` dispatchable
         * using the assigned `overweight_index`.
         *
         * \[ para, id, overweight_index, required \]
         */
        export interface OverweightEnqueued {
          type: "OverweightEnqueued"
          value: [polkadot_parachain.primitives.Id, Uint8Array, u64, sp_weights.weight_v2.Weight]
        }
        /**
         * Upward message from the overweight queue was executed with the given actual weight
         * used.
         *
         * \[ overweight_index, used \]
         */
        export function OverweightServiced(
          ...value: polkadot_runtime_parachains.ump.pallet.Event.OverweightServiced["value"]
        ): polkadot_runtime_parachains.ump.pallet.Event.OverweightServiced {
          return { type: "OverweightServiced", value }
        }
        /**
         * Upward message from the overweight queue was executed with the given actual weight
         * used.
         *
         * \[ overweight_index, used \]
         */
        export interface OverweightServiced {
          type: "OverweightServiced"
          value: [u64, sp_weights.weight_v2.Weight]
        }
        /**
         * Upward message is unsupported version of XCM.
         * \[ id \]
         */
        export function UnsupportedVersion(
          value: polkadot_runtime_parachains.ump.pallet.Event.UnsupportedVersion["value"],
        ): polkadot_runtime_parachains.ump.pallet.Event.UnsupportedVersion {
          return { type: "UnsupportedVersion", value }
        }
        /**
         * Upward message is unsupported version of XCM.
         * \[ id \]
         */
        export interface UnsupportedVersion {
          type: "UnsupportedVersion"
          value: Uint8Array
        }
        /**
         * Some upward messages have been received and will be processed.
         * \[ para, count, size \]
         */
        export function UpwardMessagesReceived(
          ...value: polkadot_runtime_parachains.ump.pallet.Event.UpwardMessagesReceived["value"]
        ): polkadot_runtime_parachains.ump.pallet.Event.UpwardMessagesReceived {
          return { type: "UpwardMessagesReceived", value }
        }
        /**
         * Some upward messages have been received and will be processed.
         * \[ para, count, size \]
         */
        export interface UpwardMessagesReceived {
          type: "UpwardMessagesReceived"
          value: [polkadot_parachain.primitives.Id, u32, u32]
        }
        /**
         * The weight limit for handling upward messages was reached.
         * \[ id, remaining, required \]
         */
        export function WeightExhausted(
          ...value: polkadot_runtime_parachains.ump.pallet.Event.WeightExhausted["value"]
        ): polkadot_runtime_parachains.ump.pallet.Event.WeightExhausted {
          return { type: "WeightExhausted", value }
        }
        /**
         * The weight limit for handling upward messages was reached.
         * \[ id, remaining, required \]
         */
        export interface WeightExhausted {
          type: "WeightExhausted"
          value: [Uint8Array, sp_weights.weight_v2.Weight, sp_weights.weight_v2.Weight]
        }
      }
    }
  }
}
export namespace primitive_types {
  export const $h256: $.Codec<primitive_types.H256> = _codec.$11
  export type H256 = Uint8Array
  export function H256(value: primitive_types.H256) {
    return value
  }
}
export namespace sp_arithmetic {
  export namespace fixed_point {
    export const $fixedU128: $.Codec<sp_arithmetic.fixed_point.FixedU128> = _codec.$479
    export type FixedU128 = u128
    export function FixedU128(value: sp_arithmetic.fixed_point.FixedU128) {
      return value
    }
  }
  export namespace per_things {
    export const $perU16: $.Codec<sp_arithmetic.per_things.PerU16> = _codec.$320
    export const $perbill: $.Codec<sp_arithmetic.per_things.Perbill> = _codec.$42
    export const $percent: $.Codec<sp_arithmetic.per_things.Percent> = _codec.$205
    export const $permill: $.Codec<sp_arithmetic.per_things.Permill> = _codec.$558
    export type PerU16 = u16
    export function PerU16(value: sp_arithmetic.per_things.PerU16) {
      return value
    }
    export type Perbill = u32
    export function Perbill(value: sp_arithmetic.per_things.Perbill) {
      return value
    }
    export type Percent = u8
    export function Percent(value: sp_arithmetic.per_things.Percent) {
      return value
    }
    export type Permill = u32
    export function Permill(value: sp_arithmetic.per_things.Permill) {
      return value
    }
  }
}
export namespace sp_authority_discovery {
  export namespace app {
    export const $public: $.Codec<sp_authority_discovery.app.Public> = _codec.$215
    export type Public = sp_core.sr25519.Public
    export function Public(value: sp_authority_discovery.app.Public) {
      return value
    }
  }
}
export namespace sp_consensus_babe {
  export const $allowedSlots: $.Codec<sp_consensus_babe.AllowedSlots> = _codec.$194
  export const $babeEpochConfiguration: $.Codec<sp_consensus_babe.BabeEpochConfiguration> =
    _codec.$466
  export type AllowedSlots =
    | "PrimarySlots"
    | "PrimaryAndSecondaryPlainSlots"
    | "PrimaryAndSecondaryVRFSlots"
  export interface BabeEpochConfiguration {
    c: [u64, u64]
    allowed_slots: sp_consensus_babe.AllowedSlots
  }
  export function BabeEpochConfiguration(value: sp_consensus_babe.BabeEpochConfiguration) {
    return value
  }
  export namespace app {
    export const $public: $.Codec<sp_consensus_babe.app.Public> = _codec.$189
    export type Public = sp_core.sr25519.Public
    export function Public(value: sp_consensus_babe.app.Public) {
      return value
    }
  }
  export namespace digests {
    export const $nextConfigDescriptor: $.Codec<sp_consensus_babe.digests.NextConfigDescriptor> =
      _codec.$192
    export const $preDigest: $.Codec<sp_consensus_babe.digests.PreDigest> = _codec.$462
    export const $primaryPreDigest: $.Codec<sp_consensus_babe.digests.PrimaryPreDigest> =
      _codec.$463
    export const $secondaryPlainPreDigest: $.Codec<
      sp_consensus_babe.digests.SecondaryPlainPreDigest
    > = _codec.$464
    export const $secondaryVRFPreDigest: $.Codec<sp_consensus_babe.digests.SecondaryVRFPreDigest> =
      _codec.$465
    export type NextConfigDescriptor = sp_consensus_babe.digests.NextConfigDescriptor.V1
    export namespace NextConfigDescriptor {
      export function V1(
        value: Omit<sp_consensus_babe.digests.NextConfigDescriptor.V1, "type">,
      ): sp_consensus_babe.digests.NextConfigDescriptor.V1 {
        return { type: "V1", ...value }
      }
      export interface V1 {
        type: "V1"
        c: [u64, u64]
        allowed_slots: sp_consensus_babe.AllowedSlots
      }
    }
    export type PreDigest =
      | sp_consensus_babe.digests.PreDigest.Primary
      | sp_consensus_babe.digests.PreDigest.SecondaryPlain
      | sp_consensus_babe.digests.PreDigest.SecondaryVRF
    export namespace PreDigest {
      export function Primary(
        value: sp_consensus_babe.digests.PreDigest.Primary["value"],
      ): sp_consensus_babe.digests.PreDigest.Primary {
        return { type: "Primary", value }
      }
      export interface Primary {
        type: "Primary"
        value: sp_consensus_babe.digests.PrimaryPreDigest
      }
      export function SecondaryPlain(
        value: sp_consensus_babe.digests.PreDigest.SecondaryPlain["value"],
      ): sp_consensus_babe.digests.PreDigest.SecondaryPlain {
        return { type: "SecondaryPlain", value }
      }
      export interface SecondaryPlain {
        type: "SecondaryPlain"
        value: sp_consensus_babe.digests.SecondaryPlainPreDigest
      }
      export function SecondaryVRF(
        value: sp_consensus_babe.digests.PreDigest.SecondaryVRF["value"],
      ): sp_consensus_babe.digests.PreDigest.SecondaryVRF {
        return { type: "SecondaryVRF", value }
      }
      export interface SecondaryVRF {
        type: "SecondaryVRF"
        value: sp_consensus_babe.digests.SecondaryVRFPreDigest
      }
    }
    export interface PrimaryPreDigest {
      authority_index: u32
      slot: sp_consensus_slots.Slot
      vrf_output: Uint8Array
      vrf_proof: Uint8Array
    }
    export function PrimaryPreDigest(value: sp_consensus_babe.digests.PrimaryPreDigest) {
      return value
    }
    export interface SecondaryPlainPreDigest {
      authority_index: u32
      slot: sp_consensus_slots.Slot
    }
    export function SecondaryPlainPreDigest(
      value: sp_consensus_babe.digests.SecondaryPlainPreDigest,
    ) {
      return value
    }
    export interface SecondaryVRFPreDigest {
      authority_index: u32
      slot: sp_consensus_slots.Slot
      vrf_output: Uint8Array
      vrf_proof: Uint8Array
    }
    export function SecondaryVRFPreDigest(value: sp_consensus_babe.digests.SecondaryVRFPreDigest) {
      return value
    }
  }
}
export namespace sp_consensus_slots {
  export const $equivocationProof: $.Codec<sp_consensus_slots.EquivocationProof> = _codec.$186
  export const $slot: $.Codec<sp_consensus_slots.Slot> = _codec.$190
  export interface EquivocationProof {
    offender: sp_consensus_babe.app.Public
    slot: sp_consensus_slots.Slot
    first_header: sp_runtime.generic.header.Header
    second_header: sp_runtime.generic.header.Header
  }
  export function EquivocationProof(value: sp_consensus_slots.EquivocationProof) {
    return value
  }
  export type Slot = u64
  export function Slot(value: sp_consensus_slots.Slot) {
    return value
  }
}
export namespace sp_core {
  export const $opaquePeerId: $.Codec<sp_core.OpaquePeerId> = _codec.$230
  export const $void: $.Codec<sp_core.Void> = _codec.$262
  export type OpaquePeerId = Uint8Array
  export function OpaquePeerId(value: sp_core.OpaquePeerId) {
    return value
  }
  export type Void = never
  export namespace crypto {
    export const $accountId32: $.Codec<sp_core.crypto.AccountId32> = _codec.$0
    export const $keyTypeId: $.Codec<sp_core.crypto.KeyTypeId> = _codec.$514
    export type AccountId32 = Uint8Array
    export function AccountId32(value: sp_core.crypto.AccountId32) {
      return value
    }
    export type KeyTypeId = Uint8Array
    export function KeyTypeId(value: sp_core.crypto.KeyTypeId) {
      return value
    }
  }
  export namespace ecdsa {
    export const $public: $.Codec<sp_core.ecdsa.Public> = _codec.$418
    export const $signature: $.Codec<sp_core.ecdsa.Signature> = _codec.$422
    export type Public = Uint8Array
    export function Public(value: sp_core.ecdsa.Public) {
      return value
    }
    export type Signature = Uint8Array
    export function Signature(value: sp_core.ecdsa.Signature) {
      return value
    }
  }
  export namespace ed25519 {
    export const $public: $.Codec<sp_core.ed25519.Public> = _codec.$51
    export const $signature: $.Codec<sp_core.ed25519.Signature> = _codec.$222
    export type Public = Uint8Array
    export function Public(value: sp_core.ed25519.Public) {
      return value
    }
    export type Signature = Uint8Array
    export function Signature(value: sp_core.ed25519.Signature) {
      return value
    }
  }
  export namespace offchain {
    export const $opaqueMultiaddr: $.Codec<sp_core.offchain.OpaqueMultiaddr> = _codec.$232
    export const $opaqueNetworkState: $.Codec<sp_core.offchain.OpaqueNetworkState> = _codec.$229
    export type OpaqueMultiaddr = Uint8Array
    export function OpaqueMultiaddr(value: sp_core.offchain.OpaqueMultiaddr) {
      return value
    }
    export interface OpaqueNetworkState {
      peer_id: sp_core.OpaquePeerId
      external_addresses: Array<sp_core.offchain.OpaqueMultiaddr>
    }
    export function OpaqueNetworkState(value: sp_core.offchain.OpaqueNetworkState) {
      return value
    }
  }
  export namespace sr25519 {
    export const $public: $.Codec<sp_core.sr25519.Public> = _codec.$54
    export const $signature: $.Codec<sp_core.sr25519.Signature> = _codec.$101
    export type Public = Uint8Array
    export function Public(value: sp_core.sr25519.Public) {
      return value
    }
    export type Signature = Uint8Array
    export function Signature(value: sp_core.sr25519.Signature) {
      return value
    }
  }
}
export namespace sp_finality_grandpa {
  export const $equivocation: $.Codec<sp_finality_grandpa.Equivocation> = _codec.$218
  export const $equivocationProof: $.Codec<sp_finality_grandpa.EquivocationProof> = _codec.$217
  export type Equivocation =
    | sp_finality_grandpa.Equivocation.Prevote
    | sp_finality_grandpa.Equivocation.Precommit
  export namespace Equivocation {
    export function Precommit(
      value: sp_finality_grandpa.Equivocation.Precommit["value"],
    ): sp_finality_grandpa.Equivocation.Precommit {
      return { type: "Precommit", value }
    }
    export interface Precommit {
      type: "Precommit"
      value: finality_grandpa.Equivocation.$$finality_grandpa.Precommit
    }
    export function Prevote(
      value: sp_finality_grandpa.Equivocation.Prevote["value"],
    ): sp_finality_grandpa.Equivocation.Prevote {
      return { type: "Prevote", value }
    }
    export interface Prevote {
      type: "Prevote"
      value: finality_grandpa.Equivocation.$$finality_grandpa.Prevote
    }
  }
  export interface EquivocationProof {
    set_id: u64
    equivocation: sp_finality_grandpa.Equivocation
  }
  export function EquivocationProof(value: sp_finality_grandpa.EquivocationProof) {
    return value
  }
  export namespace app {
    export const $public: $.Codec<sp_finality_grandpa.app.Public> = _codec.$50
    export const $signature: $.Codec<sp_finality_grandpa.app.Signature> = _codec.$221
    export type Public = sp_core.ed25519.Public
    export function Public(value: sp_finality_grandpa.app.Public) {
      return value
    }
    export type Signature = sp_core.ed25519.Signature
    export function Signature(value: sp_finality_grandpa.app.Signature) {
      return value
    }
  }
}
export namespace sp_npos_elections {
  export const $electionScore: $.Codec<sp_npos_elections.ElectionScore> = _codec.$88
  export const $support: $.Codec<sp_npos_elections.Support> = _codec.$367
  export interface ElectionScore {
    minimal_stake: u128
    sum_stake: u128
    sum_stake_squared: u128
  }
  export function ElectionScore(value: sp_npos_elections.ElectionScore) {
    return value
  }
  export interface Support {
    total: u128
    voters: Array<[sp_core.crypto.AccountId32, u128]>
  }
  export function Support(value: sp_npos_elections.Support) {
    return value
  }
}
export namespace sp_runtime {
  export const $arithmeticError: $.Codec<sp_runtime.ArithmeticError> = _codec.$27
  export const $dispatchError: $.Codec<sp_runtime.DispatchError> = _codec.$24
  export const $moduleError: $.Codec<sp_runtime.ModuleError> = _codec.$25
  export const $multiSignature: $.Codec<sp_runtime.MultiSignature> = _codec.$421
  export const $multiSigner: $.Codec<sp_runtime.MultiSigner> = _codec.$417
  export const $tokenError: $.Codec<sp_runtime.TokenError> = _codec.$26
  export const $transactionalError: $.Codec<sp_runtime.TransactionalError> = _codec.$28
  export type ArithmeticError = "Underflow" | "Overflow" | "DivisionByZero"
  export type DispatchError =
    | sp_runtime.DispatchError.Other
    | sp_runtime.DispatchError.CannotLookup
    | sp_runtime.DispatchError.BadOrigin
    | sp_runtime.DispatchError.Module
    | sp_runtime.DispatchError.ConsumerRemaining
    | sp_runtime.DispatchError.NoProviders
    | sp_runtime.DispatchError.TooManyConsumers
    | sp_runtime.DispatchError.Token
    | sp_runtime.DispatchError.Arithmetic
    | sp_runtime.DispatchError.Transactional
    | sp_runtime.DispatchError.Exhausted
    | sp_runtime.DispatchError.Corruption
    | sp_runtime.DispatchError.Unavailable
  export namespace DispatchError {
    export function Arithmetic(
      value: sp_runtime.DispatchError.Arithmetic["value"],
    ): sp_runtime.DispatchError.Arithmetic {
      return { type: "Arithmetic", value }
    }
    export interface Arithmetic {
      type: "Arithmetic"
      value: sp_runtime.ArithmeticError
    }
    export function BadOrigin(): sp_runtime.DispatchError.BadOrigin {
      return { type: "BadOrigin" }
    }
    export interface BadOrigin {
      type: "BadOrigin"
    }
    export function CannotLookup(): sp_runtime.DispatchError.CannotLookup {
      return { type: "CannotLookup" }
    }
    export interface CannotLookup {
      type: "CannotLookup"
    }
    export function ConsumerRemaining(): sp_runtime.DispatchError.ConsumerRemaining {
      return { type: "ConsumerRemaining" }
    }
    export interface ConsumerRemaining {
      type: "ConsumerRemaining"
    }
    export function Corruption(): sp_runtime.DispatchError.Corruption {
      return { type: "Corruption" }
    }
    export interface Corruption {
      type: "Corruption"
    }
    export function Exhausted(): sp_runtime.DispatchError.Exhausted {
      return { type: "Exhausted" }
    }
    export interface Exhausted {
      type: "Exhausted"
    }
    export function Module(
      value: sp_runtime.DispatchError.Module["value"],
    ): sp_runtime.DispatchError.Module {
      return { type: "Module", value }
    }
    export interface Module {
      type: "Module"
      value: sp_runtime.ModuleError
    }
    export function NoProviders(): sp_runtime.DispatchError.NoProviders {
      return { type: "NoProviders" }
    }
    export interface NoProviders {
      type: "NoProviders"
    }
    export function Other(): sp_runtime.DispatchError.Other {
      return { type: "Other" }
    }
    export interface Other {
      type: "Other"
    }
    export function Token(
      value: sp_runtime.DispatchError.Token["value"],
    ): sp_runtime.DispatchError.Token {
      return { type: "Token", value }
    }
    export interface Token {
      type: "Token"
      value: sp_runtime.TokenError
    }
    export function TooManyConsumers(): sp_runtime.DispatchError.TooManyConsumers {
      return { type: "TooManyConsumers" }
    }
    export interface TooManyConsumers {
      type: "TooManyConsumers"
    }
    export function Transactional(
      value: sp_runtime.DispatchError.Transactional["value"],
    ): sp_runtime.DispatchError.Transactional {
      return { type: "Transactional", value }
    }
    export interface Transactional {
      type: "Transactional"
      value: sp_runtime.TransactionalError
    }
    export function Unavailable(): sp_runtime.DispatchError.Unavailable {
      return { type: "Unavailable" }
    }
    export interface Unavailable {
      type: "Unavailable"
    }
  }
  export interface ModuleError {
    index: u8
    error: Uint8Array
  }
  export function ModuleError(value: sp_runtime.ModuleError) {
    return value
  }
  export type MultiSignature =
    | sp_runtime.MultiSignature.Ed25519
    | sp_runtime.MultiSignature.Sr25519
    | sp_runtime.MultiSignature.Ecdsa
  export namespace MultiSignature {
    export function Ecdsa(
      value: sp_runtime.MultiSignature.Ecdsa["value"],
    ): sp_runtime.MultiSignature.Ecdsa {
      return { type: "Ecdsa", value }
    }
    export interface Ecdsa {
      type: "Ecdsa"
      value: sp_core.ecdsa.Signature
    }
    export function Ed25519(
      value: sp_runtime.MultiSignature.Ed25519["value"],
    ): sp_runtime.MultiSignature.Ed25519 {
      return { type: "Ed25519", value }
    }
    export interface Ed25519 {
      type: "Ed25519"
      value: sp_core.ed25519.Signature
    }
    export function Sr25519(
      value: sp_runtime.MultiSignature.Sr25519["value"],
    ): sp_runtime.MultiSignature.Sr25519 {
      return { type: "Sr25519", value }
    }
    export interface Sr25519 {
      type: "Sr25519"
      value: sp_core.sr25519.Signature
    }
  }
  export type MultiSigner =
    | sp_runtime.MultiSigner.Ed25519
    | sp_runtime.MultiSigner.Sr25519
    | sp_runtime.MultiSigner.Ecdsa
  export namespace MultiSigner {
    export function Ecdsa(
      value: sp_runtime.MultiSigner.Ecdsa["value"],
    ): sp_runtime.MultiSigner.Ecdsa {
      return { type: "Ecdsa", value }
    }
    export interface Ecdsa {
      type: "Ecdsa"
      value: sp_core.ecdsa.Public
    }
    export function Ed25519(
      value: sp_runtime.MultiSigner.Ed25519["value"],
    ): sp_runtime.MultiSigner.Ed25519 {
      return { type: "Ed25519", value }
    }
    export interface Ed25519 {
      type: "Ed25519"
      value: sp_core.ed25519.Public
    }
    export function Sr25519(
      value: sp_runtime.MultiSigner.Sr25519["value"],
    ): sp_runtime.MultiSigner.Sr25519 {
      return { type: "Sr25519", value }
    }
    export interface Sr25519 {
      type: "Sr25519"
      value: sp_core.sr25519.Public
    }
  }
  export type TokenError =
    | "NoFunds"
    | "WouldDie"
    | "BelowMinimum"
    | "CannotCreate"
    | "UnknownAsset"
    | "Frozen"
    | "Unsupported"
  export type TransactionalError = "LimitReached" | "NoLayer"
  export namespace generic {
    export namespace digest {
      export const $digest: $.Codec<sp_runtime.generic.digest.Digest> = _codec.$13
      export const $digestItem: $.Codec<sp_runtime.generic.digest.DigestItem> = _codec.$15
      export interface Digest {
        logs: Array<sp_runtime.generic.digest.DigestItem>
      }
      export function Digest(value: sp_runtime.generic.digest.Digest) {
        return value
      }
      export type DigestItem =
        | sp_runtime.generic.digest.DigestItem.PreRuntime
        | sp_runtime.generic.digest.DigestItem.Consensus
        | sp_runtime.generic.digest.DigestItem.Seal
        | sp_runtime.generic.digest.DigestItem.Other
        | sp_runtime.generic.digest.DigestItem.RuntimeEnvironmentUpdated
      export namespace DigestItem {
        export function Consensus(
          ...value: sp_runtime.generic.digest.DigestItem.Consensus["value"]
        ): sp_runtime.generic.digest.DigestItem.Consensus {
          return { type: "Consensus", value }
        }
        export interface Consensus {
          type: "Consensus"
          value: [Uint8Array, Uint8Array]
        }
        export function Other(
          value: sp_runtime.generic.digest.DigestItem.Other["value"],
        ): sp_runtime.generic.digest.DigestItem.Other {
          return { type: "Other", value }
        }
        export interface Other {
          type: "Other"
          value: Uint8Array
        }
        export function PreRuntime(
          ...value: sp_runtime.generic.digest.DigestItem.PreRuntime["value"]
        ): sp_runtime.generic.digest.DigestItem.PreRuntime {
          return { type: "PreRuntime", value }
        }
        export interface PreRuntime {
          type: "PreRuntime"
          value: [Uint8Array, Uint8Array]
        }
        export function RuntimeEnvironmentUpdated(): sp_runtime.generic.digest.DigestItem.RuntimeEnvironmentUpdated {
          return { type: "RuntimeEnvironmentUpdated" }
        }
        export interface RuntimeEnvironmentUpdated {
          type: "RuntimeEnvironmentUpdated"
        }
        export function Seal(
          ...value: sp_runtime.generic.digest.DigestItem.Seal["value"]
        ): sp_runtime.generic.digest.DigestItem.Seal {
          return { type: "Seal", value }
        }
        export interface Seal {
          type: "Seal"
          value: [Uint8Array, Uint8Array]
        }
      }
    }
    export namespace header {
      export const $header: $.Codec<sp_runtime.generic.header.Header> = _codec.$187
      export interface Header {
        parent_hash: primitive_types.H256
        number: Compact<u32>
        state_root: primitive_types.H256
        extrinsics_root: primitive_types.H256
        digest: sp_runtime.generic.digest.Digest
      }
      export function Header(value: sp_runtime.generic.header.Header) {
        return value
      }
    }
  }
  export namespace multiaddress {
    export const $multiAddress: $.Codec<sp_runtime.multiaddress.MultiAddress> = _codec.$197
    export type MultiAddress =
      | sp_runtime.multiaddress.MultiAddress.Id
      | sp_runtime.multiaddress.MultiAddress.Index
      | sp_runtime.multiaddress.MultiAddress.Raw
      | sp_runtime.multiaddress.MultiAddress.Address32
      | sp_runtime.multiaddress.MultiAddress.Address20
    export namespace MultiAddress {
      export function Address20(
        value: sp_runtime.multiaddress.MultiAddress.Address20["value"],
      ): sp_runtime.multiaddress.MultiAddress.Address20 {
        return { type: "Address20", value }
      }
      export interface Address20 {
        type: "Address20"
        value: Uint8Array
      }
      export function Address32(
        value: sp_runtime.multiaddress.MultiAddress.Address32["value"],
      ): sp_runtime.multiaddress.MultiAddress.Address32 {
        return { type: "Address32", value }
      }
      export interface Address32 {
        type: "Address32"
        value: Uint8Array
      }
      export function Id(
        value: sp_runtime.multiaddress.MultiAddress.Id["value"],
      ): sp_runtime.multiaddress.MultiAddress.Id {
        return { type: "Id", value }
      }
      export interface Id {
        type: "Id"
        value: sp_core.crypto.AccountId32
      }
      export function Index(
        value: sp_runtime.multiaddress.MultiAddress.Index["value"],
      ): sp_runtime.multiaddress.MultiAddress.Index {
        return { type: "Index", value }
      }
      export interface Index {
        type: "Index"
        value: Compact<null>
      }
      export function Raw(
        value: sp_runtime.multiaddress.MultiAddress.Raw["value"],
      ): sp_runtime.multiaddress.MultiAddress.Raw {
        return { type: "Raw", value }
      }
      export interface Raw {
        type: "Raw"
        value: Uint8Array
      }
    }
  }
  export namespace traits {
    export const $blakeTwo256: $.Codec<sp_runtime.traits.BlakeTwo256> = _codec.$188
    export function BlakeTwo256() {
      return null
    }
    export type BlakeTwo256 = null
  }
}
export namespace sp_session {
  export const $membershipProof: $.Codec<sp_session.MembershipProof> = _codec.$191
  export interface MembershipProof {
    session: u32
    trie_nodes: Array<Uint8Array>
    validator_count: u32
  }
  export function MembershipProof(value: sp_session.MembershipProof) {
    return value
  }
}
export namespace sp_staking {
  export namespace offence {
    export const $offenceDetails: $.Codec<sp_staking.offence.OffenceDetails> = _codec.$509
    export interface OffenceDetails {
      offender: [sp_core.crypto.AccountId32, pallet_staking.Exposure]
      reporters: Array<sp_core.crypto.AccountId32>
    }
    export function OffenceDetails(value: sp_staking.offence.OffenceDetails) {
      return value
    }
  }
}
export namespace sp_version {
  export const $runtimeVersion: $.Codec<sp_version.RuntimeVersion> = _codec.$172
  export interface RuntimeVersion {
    spec_name: string
    impl_name: string
    authoring_version: u32
    spec_version: u32
    impl_version: u32
    apis: Array<[Uint8Array, u32]>
    transaction_version: u32
    state_version: u8
  }
  export function RuntimeVersion(value: sp_version.RuntimeVersion) {
    return value
  }
}
export namespace sp_weights {
  export const $oldWeight: $.Codec<sp_weights.OldWeight> = _codec.$239
  export const $runtimeDbWeight: $.Codec<sp_weights.RuntimeDbWeight> = _codec.$171
  export type OldWeight = u64
  export function OldWeight(value: sp_weights.OldWeight) {
    return value
  }
  export interface RuntimeDbWeight {
    read: u64
    write: u64
  }
  export function RuntimeDbWeight(value: sp_weights.RuntimeDbWeight) {
    return value
  }
  export namespace weight_v2 {
    export const $weight: $.Codec<sp_weights.weight_v2.Weight> = _codec.$8
    export interface Weight {
      ref_time: Compact<u64>
      proof_size: Compact<u64>
    }
    export function Weight(value: sp_weights.weight_v2.Weight) {
      return value
    }
  }
}
export type u128 = bigint
export type u16 = number
export type u32 = number
export type u64 = bigint
export type u8 = number
export namespace xcm {
  export const $versionedMultiAssets: $.Codec<xcm.VersionedMultiAssets> = _codec.$150
  export const $versionedMultiLocation: $.Codec<xcm.VersionedMultiLocation> = _codec.$155
  export const $versionedResponse: $.Codec<xcm.VersionedResponse> = _codec.$716
  export const $versionedXcm: $.Codec<xcm.VersionedXcm> = _codec.$424
  export type VersionedMultiAssets = xcm.VersionedMultiAssets.V0 | xcm.VersionedMultiAssets.V1
  export namespace VersionedMultiAssets {
    export function V0(value: xcm.VersionedMultiAssets.V0["value"]): xcm.VersionedMultiAssets.V0 {
      return { type: "V0", value }
    }
    export interface V0 {
      type: "V0"
      value: Array<xcm.v0.multi_asset.MultiAsset>
    }
    export function V1(value: xcm.VersionedMultiAssets.V1["value"]): xcm.VersionedMultiAssets.V1 {
      return { type: "V1", value }
    }
    export interface V1 {
      type: "V1"
      value: xcm.v1.multiasset.MultiAssets
    }
  }
  export type VersionedMultiLocation =
    | xcm.VersionedMultiLocation.V0
    | xcm.VersionedMultiLocation.V1
  export namespace VersionedMultiLocation {
    export function V0(
      value: xcm.VersionedMultiLocation.V0["value"],
    ): xcm.VersionedMultiLocation.V0 {
      return { type: "V0", value }
    }
    export interface V0 {
      type: "V0"
      value: xcm.v0.multi_location.MultiLocation
    }
    export function V1(
      value: xcm.VersionedMultiLocation.V1["value"],
    ): xcm.VersionedMultiLocation.V1 {
      return { type: "V1", value }
    }
    export interface V1 {
      type: "V1"
      value: xcm.v1.multilocation.MultiLocation
    }
  }
  export type VersionedResponse =
    | xcm.VersionedResponse.V0
    | xcm.VersionedResponse.V1
    | xcm.VersionedResponse.V2
  export namespace VersionedResponse {
    export function V0(value: xcm.VersionedResponse.V0["value"]): xcm.VersionedResponse.V0 {
      return { type: "V0", value }
    }
    export interface V0 {
      type: "V0"
      value: xcm.v0.Response
    }
    export function V1(value: xcm.VersionedResponse.V1["value"]): xcm.VersionedResponse.V1 {
      return { type: "V1", value }
    }
    export interface V1 {
      type: "V1"
      value: xcm.v1.Response
    }
    export function V2(value: xcm.VersionedResponse.V2["value"]): xcm.VersionedResponse.V2 {
      return { type: "V2", value }
    }
    export interface V2 {
      type: "V2"
      value: xcm.v2.Response
    }
  }
  export type VersionedXcm = xcm.VersionedXcm.V0 | xcm.VersionedXcm.V1 | xcm.VersionedXcm.V2
  export namespace VersionedXcm {
    export function V0(value: xcm.VersionedXcm.V0["value"]): xcm.VersionedXcm.V0 {
      return { type: "V0", value }
    }
    export interface V0 {
      type: "V0"
      value: xcm.v0.Xcm
    }
    export function V1(value: xcm.VersionedXcm.V1["value"]): xcm.VersionedXcm.V1 {
      return { type: "V1", value }
    }
    export interface V1 {
      type: "V1"
      value: xcm.v1.Xcm
    }
    export function V2(value: xcm.VersionedXcm.V2["value"]): xcm.VersionedXcm.V2 {
      return { type: "V2", value }
    }
    export interface V2 {
      type: "V2"
      value: Array<xcm.v2.Instruction>
    }
  }
  export namespace v0 {
    export const $originKind: $.Codec<xcm.v0.OriginKind> = _codec.$143
    export const $response: $.Codec<xcm.v0.Response> = _codec.$429
    export const $xcm: $.Codec<xcm.v0.Xcm> = _codec.$425
    export type OriginKind = "Native" | "SovereignAccount" | "Superuser" | "Xcm"
    export type Response = xcm.v0.Response.Assets
    export namespace Response {
      export function Assets(value: xcm.v0.Response.Assets["value"]): xcm.v0.Response.Assets {
        return { type: "Assets", value }
      }
      export interface Assets {
        type: "Assets"
        value: Array<xcm.v0.multi_asset.MultiAsset>
      }
    }
    export type Xcm =
      | xcm.v0.Xcm.WithdrawAsset
      | xcm.v0.Xcm.ReserveAssetDeposit
      | xcm.v0.Xcm.TeleportAsset
      | xcm.v0.Xcm.QueryResponse
      | xcm.v0.Xcm.TransferAsset
      | xcm.v0.Xcm.TransferReserveAsset
      | xcm.v0.Xcm.Transact
      | xcm.v0.Xcm.HrmpNewChannelOpenRequest
      | xcm.v0.Xcm.HrmpChannelAccepted
      | xcm.v0.Xcm.HrmpChannelClosing
      | xcm.v0.Xcm.RelayedFrom
    export namespace Xcm {
      export function HrmpChannelAccepted(
        value: Omit<xcm.v0.Xcm.HrmpChannelAccepted, "type">,
      ): xcm.v0.Xcm.HrmpChannelAccepted {
        return { type: "HrmpChannelAccepted", ...value }
      }
      export interface HrmpChannelAccepted {
        type: "HrmpChannelAccepted"
        recipient: Compact<u32>
      }
      export function HrmpChannelClosing(
        value: Omit<xcm.v0.Xcm.HrmpChannelClosing, "type">,
      ): xcm.v0.Xcm.HrmpChannelClosing {
        return { type: "HrmpChannelClosing", ...value }
      }
      export interface HrmpChannelClosing {
        type: "HrmpChannelClosing"
        initiator: Compact<u32>
        sender: Compact<u32>
        recipient: Compact<u32>
      }
      export function HrmpNewChannelOpenRequest(
        value: Omit<xcm.v0.Xcm.HrmpNewChannelOpenRequest, "type">,
      ): xcm.v0.Xcm.HrmpNewChannelOpenRequest {
        return { type: "HrmpNewChannelOpenRequest", ...value }
      }
      export interface HrmpNewChannelOpenRequest {
        type: "HrmpNewChannelOpenRequest"
        sender: Compact<u32>
        max_message_size: Compact<u32>
        max_capacity: Compact<u32>
      }
      export function QueryResponse(
        value: Omit<xcm.v0.Xcm.QueryResponse, "type">,
      ): xcm.v0.Xcm.QueryResponse {
        return { type: "QueryResponse", ...value }
      }
      export interface QueryResponse {
        type: "QueryResponse"
        query_id: Compact<u64>
        response: xcm.v0.Response
      }
      export function RelayedFrom(
        value: Omit<xcm.v0.Xcm.RelayedFrom, "type">,
      ): xcm.v0.Xcm.RelayedFrom {
        return { type: "RelayedFrom", ...value }
      }
      export interface RelayedFrom {
        type: "RelayedFrom"
        who: xcm.v0.multi_location.MultiLocation
        message: xcm.v0.Xcm
      }
      export function ReserveAssetDeposit(
        value: Omit<xcm.v0.Xcm.ReserveAssetDeposit, "type">,
      ): xcm.v0.Xcm.ReserveAssetDeposit {
        return { type: "ReserveAssetDeposit", ...value }
      }
      export interface ReserveAssetDeposit {
        type: "ReserveAssetDeposit"
        assets: Array<xcm.v0.multi_asset.MultiAsset>
        effects: Array<xcm.v0.order.Order>
      }
      export function TeleportAsset(
        value: Omit<xcm.v0.Xcm.TeleportAsset, "type">,
      ): xcm.v0.Xcm.TeleportAsset {
        return { type: "TeleportAsset", ...value }
      }
      export interface TeleportAsset {
        type: "TeleportAsset"
        assets: Array<xcm.v0.multi_asset.MultiAsset>
        effects: Array<xcm.v0.order.Order>
      }
      export function Transact(value: Omit<xcm.v0.Xcm.Transact, "type">): xcm.v0.Xcm.Transact {
        return { type: "Transact", ...value }
      }
      export interface Transact {
        type: "Transact"
        origin_type: xcm.v0.OriginKind
        require_weight_at_most: u64
        call: { encoded: Uint8Array }
      }
      export function TransferAsset(
        value: Omit<xcm.v0.Xcm.TransferAsset, "type">,
      ): xcm.v0.Xcm.TransferAsset {
        return { type: "TransferAsset", ...value }
      }
      export interface TransferAsset {
        type: "TransferAsset"
        assets: Array<xcm.v0.multi_asset.MultiAsset>
        dest: xcm.v0.multi_location.MultiLocation
      }
      export function TransferReserveAsset(
        value: Omit<xcm.v0.Xcm.TransferReserveAsset, "type">,
      ): xcm.v0.Xcm.TransferReserveAsset {
        return { type: "TransferReserveAsset", ...value }
      }
      export interface TransferReserveAsset {
        type: "TransferReserveAsset"
        assets: Array<xcm.v0.multi_asset.MultiAsset>
        dest: xcm.v0.multi_location.MultiLocation
        effects: Array<xcm.v0.order.Order>
      }
      export function WithdrawAsset(
        value: Omit<xcm.v0.Xcm.WithdrawAsset, "type">,
      ): xcm.v0.Xcm.WithdrawAsset {
        return { type: "WithdrawAsset", ...value }
      }
      export interface WithdrawAsset {
        type: "WithdrawAsset"
        assets: Array<xcm.v0.multi_asset.MultiAsset>
        effects: Array<xcm.v0.order.Order>
      }
    }
    export namespace junction {
      export const $bodyId: $.Codec<xcm.v0.junction.BodyId> = _codec.$128
      export const $bodyPart: $.Codec<xcm.v0.junction.BodyPart> = _codec.$129
      export const $junction: $.Codec<xcm.v0.junction.Junction> = _codec.$154
      export const $networkId: $.Codec<xcm.v0.junction.NetworkId> = _codec.$126
      export type BodyId =
        | xcm.v0.junction.BodyId.Unit
        | xcm.v0.junction.BodyId.Named
        | xcm.v0.junction.BodyId.Index
        | xcm.v0.junction.BodyId.Executive
        | xcm.v0.junction.BodyId.Technical
        | xcm.v0.junction.BodyId.Legislative
        | xcm.v0.junction.BodyId.Judicial
      export namespace BodyId {
        export function Executive(): xcm.v0.junction.BodyId.Executive {
          return { type: "Executive" }
        }
        export interface Executive {
          type: "Executive"
        }
        export function Index(
          value: xcm.v0.junction.BodyId.Index["value"],
        ): xcm.v0.junction.BodyId.Index {
          return { type: "Index", value }
        }
        export interface Index {
          type: "Index"
          value: Compact<u32>
        }
        export function Judicial(): xcm.v0.junction.BodyId.Judicial {
          return { type: "Judicial" }
        }
        export interface Judicial {
          type: "Judicial"
        }
        export function Legislative(): xcm.v0.junction.BodyId.Legislative {
          return { type: "Legislative" }
        }
        export interface Legislative {
          type: "Legislative"
        }
        export function Named(
          value: xcm.v0.junction.BodyId.Named["value"],
        ): xcm.v0.junction.BodyId.Named {
          return { type: "Named", value }
        }
        export interface Named {
          type: "Named"
          value: Uint8Array
        }
        export function Technical(): xcm.v0.junction.BodyId.Technical {
          return { type: "Technical" }
        }
        export interface Technical {
          type: "Technical"
        }
        export function Unit(): xcm.v0.junction.BodyId.Unit {
          return { type: "Unit" }
        }
        export interface Unit {
          type: "Unit"
        }
      }
      export type BodyPart =
        | xcm.v0.junction.BodyPart.Voice
        | xcm.v0.junction.BodyPart.Members
        | xcm.v0.junction.BodyPart.Fraction
        | xcm.v0.junction.BodyPart.AtLeastProportion
        | xcm.v0.junction.BodyPart.MoreThanProportion
      export namespace BodyPart {
        export function AtLeastProportion(
          value: Omit<xcm.v0.junction.BodyPart.AtLeastProportion, "type">,
        ): xcm.v0.junction.BodyPart.AtLeastProportion {
          return { type: "AtLeastProportion", ...value }
        }
        export interface AtLeastProportion {
          type: "AtLeastProportion"
          nom: Compact<u32>
          denom: Compact<u32>
        }
        export function Fraction(
          value: Omit<xcm.v0.junction.BodyPart.Fraction, "type">,
        ): xcm.v0.junction.BodyPart.Fraction {
          return { type: "Fraction", ...value }
        }
        export interface Fraction {
          type: "Fraction"
          nom: Compact<u32>
          denom: Compact<u32>
        }
        export function Members(
          value: Omit<xcm.v0.junction.BodyPart.Members, "type">,
        ): xcm.v0.junction.BodyPart.Members {
          return { type: "Members", ...value }
        }
        export interface Members {
          type: "Members"
          count: Compact<u32>
        }
        export function MoreThanProportion(
          value: Omit<xcm.v0.junction.BodyPart.MoreThanProportion, "type">,
        ): xcm.v0.junction.BodyPart.MoreThanProportion {
          return { type: "MoreThanProportion", ...value }
        }
        export interface MoreThanProportion {
          type: "MoreThanProportion"
          nom: Compact<u32>
          denom: Compact<u32>
        }
        export function Voice(): xcm.v0.junction.BodyPart.Voice {
          return { type: "Voice" }
        }
        export interface Voice {
          type: "Voice"
        }
      }
      export type Junction =
        | xcm.v0.junction.Junction.Parent
        | xcm.v0.junction.Junction.Parachain
        | xcm.v0.junction.Junction.AccountId32
        | xcm.v0.junction.Junction.AccountIndex64
        | xcm.v0.junction.Junction.AccountKey20
        | xcm.v0.junction.Junction.PalletInstance
        | xcm.v0.junction.Junction.GeneralIndex
        | xcm.v0.junction.Junction.GeneralKey
        | xcm.v0.junction.Junction.OnlyChild
        | xcm.v0.junction.Junction.Plurality
      export namespace Junction {
        export function AccountId32(
          value: Omit<xcm.v0.junction.Junction.AccountId32, "type">,
        ): xcm.v0.junction.Junction.AccountId32 {
          return { type: "AccountId32", ...value }
        }
        export interface AccountId32 {
          type: "AccountId32"
          network: xcm.v0.junction.NetworkId
          id: Uint8Array
        }
        export function AccountIndex64(
          value: Omit<xcm.v0.junction.Junction.AccountIndex64, "type">,
        ): xcm.v0.junction.Junction.AccountIndex64 {
          return { type: "AccountIndex64", ...value }
        }
        export interface AccountIndex64 {
          type: "AccountIndex64"
          network: xcm.v0.junction.NetworkId
          index: Compact<u64>
        }
        export function AccountKey20(
          value: Omit<xcm.v0.junction.Junction.AccountKey20, "type">,
        ): xcm.v0.junction.Junction.AccountKey20 {
          return { type: "AccountKey20", ...value }
        }
        export interface AccountKey20 {
          type: "AccountKey20"
          network: xcm.v0.junction.NetworkId
          key: Uint8Array
        }
        export function GeneralIndex(
          value: xcm.v0.junction.Junction.GeneralIndex["value"],
        ): xcm.v0.junction.Junction.GeneralIndex {
          return { type: "GeneralIndex", value }
        }
        export interface GeneralIndex {
          type: "GeneralIndex"
          value: Compact<u128>
        }
        export function GeneralKey(
          value: xcm.v0.junction.Junction.GeneralKey["value"],
        ): xcm.v0.junction.Junction.GeneralKey {
          return { type: "GeneralKey", value }
        }
        export interface GeneralKey {
          type: "GeneralKey"
          value: Uint8Array
        }
        export function OnlyChild(): xcm.v0.junction.Junction.OnlyChild {
          return { type: "OnlyChild" }
        }
        export interface OnlyChild {
          type: "OnlyChild"
        }
        export function PalletInstance(
          value: xcm.v0.junction.Junction.PalletInstance["value"],
        ): xcm.v0.junction.Junction.PalletInstance {
          return { type: "PalletInstance", value }
        }
        export interface PalletInstance {
          type: "PalletInstance"
          value: u8
        }
        export function Parachain(
          value: xcm.v0.junction.Junction.Parachain["value"],
        ): xcm.v0.junction.Junction.Parachain {
          return { type: "Parachain", value }
        }
        export interface Parachain {
          type: "Parachain"
          value: Compact<u32>
        }
        export function Parent(): xcm.v0.junction.Junction.Parent {
          return { type: "Parent" }
        }
        export interface Parent {
          type: "Parent"
        }
        export function Plurality(
          value: Omit<xcm.v0.junction.Junction.Plurality, "type">,
        ): xcm.v0.junction.Junction.Plurality {
          return { type: "Plurality", ...value }
        }
        export interface Plurality {
          type: "Plurality"
          id: xcm.v0.junction.BodyId
          part: xcm.v0.junction.BodyPart
        }
      }
      export type NetworkId =
        | xcm.v0.junction.NetworkId.Any
        | xcm.v0.junction.NetworkId.Named
        | xcm.v0.junction.NetworkId.Polkadot
        | xcm.v0.junction.NetworkId.Kusama
      export namespace NetworkId {
        export function Any(): xcm.v0.junction.NetworkId.Any {
          return { type: "Any" }
        }
        export interface Any {
          type: "Any"
        }
        export function Kusama(): xcm.v0.junction.NetworkId.Kusama {
          return { type: "Kusama" }
        }
        export interface Kusama {
          type: "Kusama"
        }
        export function Named(
          value: xcm.v0.junction.NetworkId.Named["value"],
        ): xcm.v0.junction.NetworkId.Named {
          return { type: "Named", value }
        }
        export interface Named {
          type: "Named"
          value: Uint8Array
        }
        export function Polkadot(): xcm.v0.junction.NetworkId.Polkadot {
          return { type: "Polkadot" }
        }
        export interface Polkadot {
          type: "Polkadot"
        }
      }
    }
    export namespace multi_asset {
      export const $multiAsset: $.Codec<xcm.v0.multi_asset.MultiAsset> = _codec.$152
      export type MultiAsset =
        | xcm.v0.multi_asset.MultiAsset.None
        | xcm.v0.multi_asset.MultiAsset.All
        | xcm.v0.multi_asset.MultiAsset.AllFungible
        | xcm.v0.multi_asset.MultiAsset.AllNonFungible
        | xcm.v0.multi_asset.MultiAsset.AllAbstractFungible
        | xcm.v0.multi_asset.MultiAsset.AllAbstractNonFungible
        | xcm.v0.multi_asset.MultiAsset.AllConcreteFungible
        | xcm.v0.multi_asset.MultiAsset.AllConcreteNonFungible
        | xcm.v0.multi_asset.MultiAsset.AbstractFungible
        | xcm.v0.multi_asset.MultiAsset.AbstractNonFungible
        | xcm.v0.multi_asset.MultiAsset.ConcreteFungible
        | xcm.v0.multi_asset.MultiAsset.ConcreteNonFungible
      export namespace MultiAsset {
        export function AbstractFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.AbstractFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.AbstractFungible {
          return { type: "AbstractFungible", ...value }
        }
        export interface AbstractFungible {
          type: "AbstractFungible"
          id: Uint8Array
          amount: Compact<u128>
        }
        export function AbstractNonFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.AbstractNonFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.AbstractNonFungible {
          return { type: "AbstractNonFungible", ...value }
        }
        export interface AbstractNonFungible {
          type: "AbstractNonFungible"
          class: Uint8Array
          instance: xcm.v1.multiasset.AssetInstance
        }
        export function All(): xcm.v0.multi_asset.MultiAsset.All {
          return { type: "All" }
        }
        export interface All {
          type: "All"
        }
        export function AllAbstractFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.AllAbstractFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.AllAbstractFungible {
          return { type: "AllAbstractFungible", ...value }
        }
        export interface AllAbstractFungible {
          type: "AllAbstractFungible"
          id: Uint8Array
        }
        export function AllAbstractNonFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.AllAbstractNonFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.AllAbstractNonFungible {
          return { type: "AllAbstractNonFungible", ...value }
        }
        export interface AllAbstractNonFungible {
          type: "AllAbstractNonFungible"
          class: Uint8Array
        }
        export function AllConcreteFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.AllConcreteFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.AllConcreteFungible {
          return { type: "AllConcreteFungible", ...value }
        }
        export interface AllConcreteFungible {
          type: "AllConcreteFungible"
          id: xcm.v0.multi_location.MultiLocation
        }
        export function AllConcreteNonFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.AllConcreteNonFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.AllConcreteNonFungible {
          return { type: "AllConcreteNonFungible", ...value }
        }
        export interface AllConcreteNonFungible {
          type: "AllConcreteNonFungible"
          class: xcm.v0.multi_location.MultiLocation
        }
        export function AllFungible(): xcm.v0.multi_asset.MultiAsset.AllFungible {
          return { type: "AllFungible" }
        }
        export interface AllFungible {
          type: "AllFungible"
        }
        export function AllNonFungible(): xcm.v0.multi_asset.MultiAsset.AllNonFungible {
          return { type: "AllNonFungible" }
        }
        export interface AllNonFungible {
          type: "AllNonFungible"
        }
        export function ConcreteFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.ConcreteFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.ConcreteFungible {
          return { type: "ConcreteFungible", ...value }
        }
        export interface ConcreteFungible {
          type: "ConcreteFungible"
          id: xcm.v0.multi_location.MultiLocation
          amount: Compact<u128>
        }
        export function ConcreteNonFungible(
          value: Omit<xcm.v0.multi_asset.MultiAsset.ConcreteNonFungible, "type">,
        ): xcm.v0.multi_asset.MultiAsset.ConcreteNonFungible {
          return { type: "ConcreteNonFungible", ...value }
        }
        export interface ConcreteNonFungible {
          type: "ConcreteNonFungible"
          class: xcm.v0.multi_location.MultiLocation
          instance: xcm.v1.multiasset.AssetInstance
        }
        export function None(): xcm.v0.multi_asset.MultiAsset.None {
          return { type: "None" }
        }
        export interface None {
          type: "None"
        }
      }
    }
    export namespace multi_location {
      export const $multiLocation: $.Codec<xcm.v0.multi_location.MultiLocation> = _codec.$153
      export type MultiLocation =
        | xcm.v0.multi_location.MultiLocation.Null
        | xcm.v0.multi_location.MultiLocation.X1
        | xcm.v0.multi_location.MultiLocation.X2
        | xcm.v0.multi_location.MultiLocation.X3
        | xcm.v0.multi_location.MultiLocation.X4
        | xcm.v0.multi_location.MultiLocation.X5
        | xcm.v0.multi_location.MultiLocation.X6
        | xcm.v0.multi_location.MultiLocation.X7
        | xcm.v0.multi_location.MultiLocation.X8
      export namespace MultiLocation {
        export function Null(): xcm.v0.multi_location.MultiLocation.Null {
          return { type: "Null" }
        }
        export interface Null {
          type: "Null"
        }
        export function X1(
          value: xcm.v0.multi_location.MultiLocation.X1["value"],
        ): xcm.v0.multi_location.MultiLocation.X1 {
          return { type: "X1", value }
        }
        export interface X1 {
          type: "X1"
          value: xcm.v0.junction.Junction
        }
        export function X2(
          ...value: xcm.v0.multi_location.MultiLocation.X2["value"]
        ): xcm.v0.multi_location.MultiLocation.X2 {
          return { type: "X2", value }
        }
        export interface X2 {
          type: "X2"
          value: [xcm.v0.junction.Junction, xcm.v0.junction.Junction]
        }
        export function X3(
          ...value: xcm.v0.multi_location.MultiLocation.X3["value"]
        ): xcm.v0.multi_location.MultiLocation.X3 {
          return { type: "X3", value }
        }
        export interface X3 {
          type: "X3"
          value: [xcm.v0.junction.Junction, xcm.v0.junction.Junction, xcm.v0.junction.Junction]
        }
        export function X4(
          ...value: xcm.v0.multi_location.MultiLocation.X4["value"]
        ): xcm.v0.multi_location.MultiLocation.X4 {
          return { type: "X4", value }
        }
        export interface X4 {
          type: "X4"
          value: [
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
          ]
        }
        export function X5(
          ...value: xcm.v0.multi_location.MultiLocation.X5["value"]
        ): xcm.v0.multi_location.MultiLocation.X5 {
          return { type: "X5", value }
        }
        export interface X5 {
          type: "X5"
          value: [
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
          ]
        }
        export function X6(
          ...value: xcm.v0.multi_location.MultiLocation.X6["value"]
        ): xcm.v0.multi_location.MultiLocation.X6 {
          return { type: "X6", value }
        }
        export interface X6 {
          type: "X6"
          value: [
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
          ]
        }
        export function X7(
          ...value: xcm.v0.multi_location.MultiLocation.X7["value"]
        ): xcm.v0.multi_location.MultiLocation.X7 {
          return { type: "X7", value }
        }
        export interface X7 {
          type: "X7"
          value: [
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
          ]
        }
        export function X8(
          ...value: xcm.v0.multi_location.MultiLocation.X8["value"]
        ): xcm.v0.multi_location.MultiLocation.X8 {
          return { type: "X8", value }
        }
        export interface X8 {
          type: "X8"
          value: [
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
            xcm.v0.junction.Junction,
          ]
        }
      }
    }
    export namespace order {
      export const $order: $.Codec<xcm.v0.order.Order> = _codec.$427
      export type Order =
        | xcm.v0.order.Order.Null
        | xcm.v0.order.Order.DepositAsset
        | xcm.v0.order.Order.DepositReserveAsset
        | xcm.v0.order.Order.ExchangeAsset
        | xcm.v0.order.Order.InitiateReserveWithdraw
        | xcm.v0.order.Order.InitiateTeleport
        | xcm.v0.order.Order.QueryHolding
        | xcm.v0.order.Order.BuyExecution
      export namespace Order {
        export function BuyExecution(
          value: Omit<xcm.v0.order.Order.BuyExecution, "type">,
        ): xcm.v0.order.Order.BuyExecution {
          return { type: "BuyExecution", ...value }
        }
        export interface BuyExecution {
          type: "BuyExecution"
          fees: xcm.v0.multi_asset.MultiAsset
          weight: u64
          debt: u64
          halt_on_error: boolean
          xcm: Array<xcm.v0.Xcm>
        }
        export function DepositAsset(
          value: Omit<xcm.v0.order.Order.DepositAsset, "type">,
        ): xcm.v0.order.Order.DepositAsset {
          return { type: "DepositAsset", ...value }
        }
        export interface DepositAsset {
          type: "DepositAsset"
          assets: Array<xcm.v0.multi_asset.MultiAsset>
          dest: xcm.v0.multi_location.MultiLocation
        }
        export function DepositReserveAsset(
          value: Omit<xcm.v0.order.Order.DepositReserveAsset, "type">,
        ): xcm.v0.order.Order.DepositReserveAsset {
          return { type: "DepositReserveAsset", ...value }
        }
        export interface DepositReserveAsset {
          type: "DepositReserveAsset"
          assets: Array<xcm.v0.multi_asset.MultiAsset>
          dest: xcm.v0.multi_location.MultiLocation
          effects: Array<xcm.v0.order.Order>
        }
        export function ExchangeAsset(
          value: Omit<xcm.v0.order.Order.ExchangeAsset, "type">,
        ): xcm.v0.order.Order.ExchangeAsset {
          return { type: "ExchangeAsset", ...value }
        }
        export interface ExchangeAsset {
          type: "ExchangeAsset"
          give: Array<xcm.v0.multi_asset.MultiAsset>
          receive: Array<xcm.v0.multi_asset.MultiAsset>
        }
        export function InitiateReserveWithdraw(
          value: Omit<xcm.v0.order.Order.InitiateReserveWithdraw, "type">,
        ): xcm.v0.order.Order.InitiateReserveWithdraw {
          return { type: "InitiateReserveWithdraw", ...value }
        }
        export interface InitiateReserveWithdraw {
          type: "InitiateReserveWithdraw"
          assets: Array<xcm.v0.multi_asset.MultiAsset>
          reserve: xcm.v0.multi_location.MultiLocation
          effects: Array<xcm.v0.order.Order>
        }
        export function InitiateTeleport(
          value: Omit<xcm.v0.order.Order.InitiateTeleport, "type">,
        ): xcm.v0.order.Order.InitiateTeleport {
          return { type: "InitiateTeleport", ...value }
        }
        export interface InitiateTeleport {
          type: "InitiateTeleport"
          assets: Array<xcm.v0.multi_asset.MultiAsset>
          dest: xcm.v0.multi_location.MultiLocation
          effects: Array<xcm.v0.order.Order>
        }
        export function Null(): xcm.v0.order.Order.Null {
          return { type: "Null" }
        }
        export interface Null {
          type: "Null"
        }
        export function QueryHolding(
          value: Omit<xcm.v0.order.Order.QueryHolding, "type">,
        ): xcm.v0.order.Order.QueryHolding {
          return { type: "QueryHolding", ...value }
        }
        export interface QueryHolding {
          type: "QueryHolding"
          query_id: Compact<u64>
          dest: xcm.v0.multi_location.MultiLocation
          assets: Array<xcm.v0.multi_asset.MultiAsset>
        }
      }
    }
  }
  export namespace v1 {
    export const $response: $.Codec<xcm.v1.Response> = _codec.$434
    export const $xcm: $.Codec<xcm.v1.Xcm> = _codec.$430
    export type Response = xcm.v1.Response.Assets | xcm.v1.Response.Version
    export namespace Response {
      export function Assets(value: xcm.v1.Response.Assets["value"]): xcm.v1.Response.Assets {
        return { type: "Assets", value }
      }
      export interface Assets {
        type: "Assets"
        value: xcm.v1.multiasset.MultiAssets
      }
      export function Version(value: xcm.v1.Response.Version["value"]): xcm.v1.Response.Version {
        return { type: "Version", value }
      }
      export interface Version {
        type: "Version"
        value: u32
      }
    }
    export type Xcm =
      | xcm.v1.Xcm.WithdrawAsset
      | xcm.v1.Xcm.ReserveAssetDeposited
      | xcm.v1.Xcm.ReceiveTeleportedAsset
      | xcm.v1.Xcm.QueryResponse
      | xcm.v1.Xcm.TransferAsset
      | xcm.v1.Xcm.TransferReserveAsset
      | xcm.v1.Xcm.Transact
      | xcm.v1.Xcm.HrmpNewChannelOpenRequest
      | xcm.v1.Xcm.HrmpChannelAccepted
      | xcm.v1.Xcm.HrmpChannelClosing
      | xcm.v1.Xcm.RelayedFrom
      | xcm.v1.Xcm.SubscribeVersion
      | xcm.v1.Xcm.UnsubscribeVersion
    export namespace Xcm {
      export function HrmpChannelAccepted(
        value: Omit<xcm.v1.Xcm.HrmpChannelAccepted, "type">,
      ): xcm.v1.Xcm.HrmpChannelAccepted {
        return { type: "HrmpChannelAccepted", ...value }
      }
      export interface HrmpChannelAccepted {
        type: "HrmpChannelAccepted"
        recipient: Compact<u32>
      }
      export function HrmpChannelClosing(
        value: Omit<xcm.v1.Xcm.HrmpChannelClosing, "type">,
      ): xcm.v1.Xcm.HrmpChannelClosing {
        return { type: "HrmpChannelClosing", ...value }
      }
      export interface HrmpChannelClosing {
        type: "HrmpChannelClosing"
        initiator: Compact<u32>
        sender: Compact<u32>
        recipient: Compact<u32>
      }
      export function HrmpNewChannelOpenRequest(
        value: Omit<xcm.v1.Xcm.HrmpNewChannelOpenRequest, "type">,
      ): xcm.v1.Xcm.HrmpNewChannelOpenRequest {
        return { type: "HrmpNewChannelOpenRequest", ...value }
      }
      export interface HrmpNewChannelOpenRequest {
        type: "HrmpNewChannelOpenRequest"
        sender: Compact<u32>
        max_message_size: Compact<u32>
        max_capacity: Compact<u32>
      }
      export function QueryResponse(
        value: Omit<xcm.v1.Xcm.QueryResponse, "type">,
      ): xcm.v1.Xcm.QueryResponse {
        return { type: "QueryResponse", ...value }
      }
      export interface QueryResponse {
        type: "QueryResponse"
        query_id: Compact<u64>
        response: xcm.v1.Response
      }
      export function ReceiveTeleportedAsset(
        value: Omit<xcm.v1.Xcm.ReceiveTeleportedAsset, "type">,
      ): xcm.v1.Xcm.ReceiveTeleportedAsset {
        return { type: "ReceiveTeleportedAsset", ...value }
      }
      export interface ReceiveTeleportedAsset {
        type: "ReceiveTeleportedAsset"
        assets: xcm.v1.multiasset.MultiAssets
        effects: Array<xcm.v1.order.Order>
      }
      export function RelayedFrom(
        value: Omit<xcm.v1.Xcm.RelayedFrom, "type">,
      ): xcm.v1.Xcm.RelayedFrom {
        return { type: "RelayedFrom", ...value }
      }
      export interface RelayedFrom {
        type: "RelayedFrom"
        who: xcm.v1.multilocation.Junctions
        message: xcm.v1.Xcm
      }
      export function ReserveAssetDeposited(
        value: Omit<xcm.v1.Xcm.ReserveAssetDeposited, "type">,
      ): xcm.v1.Xcm.ReserveAssetDeposited {
        return { type: "ReserveAssetDeposited", ...value }
      }
      export interface ReserveAssetDeposited {
        type: "ReserveAssetDeposited"
        assets: xcm.v1.multiasset.MultiAssets
        effects: Array<xcm.v1.order.Order>
      }
      export function SubscribeVersion(
        value: Omit<xcm.v1.Xcm.SubscribeVersion, "type">,
      ): xcm.v1.Xcm.SubscribeVersion {
        return { type: "SubscribeVersion", ...value }
      }
      export interface SubscribeVersion {
        type: "SubscribeVersion"
        query_id: Compact<u64>
        max_response_weight: Compact<u64>
      }
      export function Transact(value: Omit<xcm.v1.Xcm.Transact, "type">): xcm.v1.Xcm.Transact {
        return { type: "Transact", ...value }
      }
      export interface Transact {
        type: "Transact"
        origin_type: xcm.v0.OriginKind
        require_weight_at_most: u64
        call: { encoded: Uint8Array }
      }
      export function TransferAsset(
        value: Omit<xcm.v1.Xcm.TransferAsset, "type">,
      ): xcm.v1.Xcm.TransferAsset {
        return { type: "TransferAsset", ...value }
      }
      export interface TransferAsset {
        type: "TransferAsset"
        assets: xcm.v1.multiasset.MultiAssets
        beneficiary: xcm.v1.multilocation.MultiLocation
      }
      export function TransferReserveAsset(
        value: Omit<xcm.v1.Xcm.TransferReserveAsset, "type">,
      ): xcm.v1.Xcm.TransferReserveAsset {
        return { type: "TransferReserveAsset", ...value }
      }
      export interface TransferReserveAsset {
        type: "TransferReserveAsset"
        assets: xcm.v1.multiasset.MultiAssets
        dest: xcm.v1.multilocation.MultiLocation
        effects: Array<xcm.v1.order.Order>
      }
      export function UnsubscribeVersion(): xcm.v1.Xcm.UnsubscribeVersion {
        return { type: "UnsubscribeVersion" }
      }
      export interface UnsubscribeVersion {
        type: "UnsubscribeVersion"
      }
      export function WithdrawAsset(
        value: Omit<xcm.v1.Xcm.WithdrawAsset, "type">,
      ): xcm.v1.Xcm.WithdrawAsset {
        return { type: "WithdrawAsset", ...value }
      }
      export interface WithdrawAsset {
        type: "WithdrawAsset"
        assets: xcm.v1.multiasset.MultiAssets
        effects: Array<xcm.v1.order.Order>
      }
    }
    export namespace junction {
      export const $junction: $.Codec<xcm.v1.junction.Junction> = _codec.$124
      export type Junction =
        | xcm.v1.junction.Junction.Parachain
        | xcm.v1.junction.Junction.AccountId32
        | xcm.v1.junction.Junction.AccountIndex64
        | xcm.v1.junction.Junction.AccountKey20
        | xcm.v1.junction.Junction.PalletInstance
        | xcm.v1.junction.Junction.GeneralIndex
        | xcm.v1.junction.Junction.GeneralKey
        | xcm.v1.junction.Junction.OnlyChild
        | xcm.v1.junction.Junction.Plurality
      export namespace Junction {
        export function AccountId32(
          value: Omit<xcm.v1.junction.Junction.AccountId32, "type">,
        ): xcm.v1.junction.Junction.AccountId32 {
          return { type: "AccountId32", ...value }
        }
        export interface AccountId32 {
          type: "AccountId32"
          network: xcm.v0.junction.NetworkId
          id: Uint8Array
        }
        export function AccountIndex64(
          value: Omit<xcm.v1.junction.Junction.AccountIndex64, "type">,
        ): xcm.v1.junction.Junction.AccountIndex64 {
          return { type: "AccountIndex64", ...value }
        }
        export interface AccountIndex64 {
          type: "AccountIndex64"
          network: xcm.v0.junction.NetworkId
          index: Compact<u64>
        }
        export function AccountKey20(
          value: Omit<xcm.v1.junction.Junction.AccountKey20, "type">,
        ): xcm.v1.junction.Junction.AccountKey20 {
          return { type: "AccountKey20", ...value }
        }
        export interface AccountKey20 {
          type: "AccountKey20"
          network: xcm.v0.junction.NetworkId
          key: Uint8Array
        }
        export function GeneralIndex(
          value: xcm.v1.junction.Junction.GeneralIndex["value"],
        ): xcm.v1.junction.Junction.GeneralIndex {
          return { type: "GeneralIndex", value }
        }
        export interface GeneralIndex {
          type: "GeneralIndex"
          value: Compact<u128>
        }
        export function GeneralKey(
          value: xcm.v1.junction.Junction.GeneralKey["value"],
        ): xcm.v1.junction.Junction.GeneralKey {
          return { type: "GeneralKey", value }
        }
        export interface GeneralKey {
          type: "GeneralKey"
          value: Uint8Array
        }
        export function OnlyChild(): xcm.v1.junction.Junction.OnlyChild {
          return { type: "OnlyChild" }
        }
        export interface OnlyChild {
          type: "OnlyChild"
        }
        export function PalletInstance(
          value: xcm.v1.junction.Junction.PalletInstance["value"],
        ): xcm.v1.junction.Junction.PalletInstance {
          return { type: "PalletInstance", value }
        }
        export interface PalletInstance {
          type: "PalletInstance"
          value: u8
        }
        export function Parachain(
          value: xcm.v1.junction.Junction.Parachain["value"],
        ): xcm.v1.junction.Junction.Parachain {
          return { type: "Parachain", value }
        }
        export interface Parachain {
          type: "Parachain"
          value: Compact<u32>
        }
        export function Plurality(
          value: Omit<xcm.v1.junction.Junction.Plurality, "type">,
        ): xcm.v1.junction.Junction.Plurality {
          return { type: "Plurality", ...value }
        }
        export interface Plurality {
          type: "Plurality"
          id: xcm.v0.junction.BodyId
          part: xcm.v0.junction.BodyPart
        }
      }
    }
    export namespace multiasset {
      export const $assetId: $.Codec<xcm.v1.multiasset.AssetId> = _codec.$136
      export const $assetInstance: $.Codec<xcm.v1.multiasset.AssetInstance> = _codec.$138
      export const $fungibility: $.Codec<xcm.v1.multiasset.Fungibility> = _codec.$137
      export const $multiAsset: $.Codec<xcm.v1.multiasset.MultiAsset> = _codec.$135
      export const $multiAssetFilter: $.Codec<xcm.v1.multiasset.MultiAssetFilter> = _codec.$145
      export const $multiAssets: $.Codec<xcm.v1.multiasset.MultiAssets> = _codec.$133
      export const $wildFungibility: $.Codec<xcm.v1.multiasset.WildFungibility> = _codec.$147
      export const $wildMultiAsset: $.Codec<xcm.v1.multiasset.WildMultiAsset> = _codec.$146
      export type AssetId = xcm.v1.multiasset.AssetId.Concrete | xcm.v1.multiasset.AssetId.Abstract
      export namespace AssetId {
        export function Abstract(
          value: xcm.v1.multiasset.AssetId.Abstract["value"],
        ): xcm.v1.multiasset.AssetId.Abstract {
          return { type: "Abstract", value }
        }
        export interface Abstract {
          type: "Abstract"
          value: Uint8Array
        }
        export function Concrete(
          value: xcm.v1.multiasset.AssetId.Concrete["value"],
        ): xcm.v1.multiasset.AssetId.Concrete {
          return { type: "Concrete", value }
        }
        export interface Concrete {
          type: "Concrete"
          value: xcm.v1.multilocation.MultiLocation
        }
      }
      export type AssetInstance =
        | xcm.v1.multiasset.AssetInstance.Undefined
        | xcm.v1.multiasset.AssetInstance.Index
        | xcm.v1.multiasset.AssetInstance.Array4
        | xcm.v1.multiasset.AssetInstance.Array8
        | xcm.v1.multiasset.AssetInstance.Array16
        | xcm.v1.multiasset.AssetInstance.Array32
        | xcm.v1.multiasset.AssetInstance.Blob
      export namespace AssetInstance {
        export function Array16(
          value: xcm.v1.multiasset.AssetInstance.Array16["value"],
        ): xcm.v1.multiasset.AssetInstance.Array16 {
          return { type: "Array16", value }
        }
        export interface Array16 {
          type: "Array16"
          value: Uint8Array
        }
        export function Array32(
          value: xcm.v1.multiasset.AssetInstance.Array32["value"],
        ): xcm.v1.multiasset.AssetInstance.Array32 {
          return { type: "Array32", value }
        }
        export interface Array32 {
          type: "Array32"
          value: Uint8Array
        }
        export function Array4(
          value: xcm.v1.multiasset.AssetInstance.Array4["value"],
        ): xcm.v1.multiasset.AssetInstance.Array4 {
          return { type: "Array4", value }
        }
        export interface Array4 {
          type: "Array4"
          value: Uint8Array
        }
        export function Array8(
          value: xcm.v1.multiasset.AssetInstance.Array8["value"],
        ): xcm.v1.multiasset.AssetInstance.Array8 {
          return { type: "Array8", value }
        }
        export interface Array8 {
          type: "Array8"
          value: Uint8Array
        }
        export function Blob(
          value: xcm.v1.multiasset.AssetInstance.Blob["value"],
        ): xcm.v1.multiasset.AssetInstance.Blob {
          return { type: "Blob", value }
        }
        export interface Blob {
          type: "Blob"
          value: Uint8Array
        }
        export function Index(
          value: xcm.v1.multiasset.AssetInstance.Index["value"],
        ): xcm.v1.multiasset.AssetInstance.Index {
          return { type: "Index", value }
        }
        export interface Index {
          type: "Index"
          value: Compact<u128>
        }
        export function Undefined(): xcm.v1.multiasset.AssetInstance.Undefined {
          return { type: "Undefined" }
        }
        export interface Undefined {
          type: "Undefined"
        }
      }
      export type Fungibility =
        | xcm.v1.multiasset.Fungibility.Fungible
        | xcm.v1.multiasset.Fungibility.NonFungible
      export namespace Fungibility {
        export function Fungible(
          value: xcm.v1.multiasset.Fungibility.Fungible["value"],
        ): xcm.v1.multiasset.Fungibility.Fungible {
          return { type: "Fungible", value }
        }
        export interface Fungible {
          type: "Fungible"
          value: Compact<u128>
        }
        export function NonFungible(
          value: xcm.v1.multiasset.Fungibility.NonFungible["value"],
        ): xcm.v1.multiasset.Fungibility.NonFungible {
          return { type: "NonFungible", value }
        }
        export interface NonFungible {
          type: "NonFungible"
          value: xcm.v1.multiasset.AssetInstance
        }
      }
      export interface MultiAsset {
        id: xcm.v1.multiasset.AssetId
        fun: xcm.v1.multiasset.Fungibility
      }
      export function MultiAsset(value: xcm.v1.multiasset.MultiAsset) {
        return value
      }
      export type MultiAssetFilter =
        | xcm.v1.multiasset.MultiAssetFilter.Definite
        | xcm.v1.multiasset.MultiAssetFilter.Wild
      export namespace MultiAssetFilter {
        export function Definite(
          value: xcm.v1.multiasset.MultiAssetFilter.Definite["value"],
        ): xcm.v1.multiasset.MultiAssetFilter.Definite {
          return { type: "Definite", value }
        }
        export interface Definite {
          type: "Definite"
          value: xcm.v1.multiasset.MultiAssets
        }
        export function Wild(
          value: xcm.v1.multiasset.MultiAssetFilter.Wild["value"],
        ): xcm.v1.multiasset.MultiAssetFilter.Wild {
          return { type: "Wild", value }
        }
        export interface Wild {
          type: "Wild"
          value: xcm.v1.multiasset.WildMultiAsset
        }
      }
      export type MultiAssets = Array<xcm.v1.multiasset.MultiAsset>
      export function MultiAssets(value: xcm.v1.multiasset.MultiAssets) {
        return value
      }
      export type WildFungibility = "Fungible" | "NonFungible"
      export type WildMultiAsset =
        | xcm.v1.multiasset.WildMultiAsset.All
        | xcm.v1.multiasset.WildMultiAsset.AllOf
      export namespace WildMultiAsset {
        export function All(): xcm.v1.multiasset.WildMultiAsset.All {
          return { type: "All" }
        }
        export interface All {
          type: "All"
        }
        export function AllOf(
          value: Omit<xcm.v1.multiasset.WildMultiAsset.AllOf, "type">,
        ): xcm.v1.multiasset.WildMultiAsset.AllOf {
          return { type: "AllOf", ...value }
        }
        export interface AllOf {
          type: "AllOf"
          id: xcm.v1.multiasset.AssetId
          fun: xcm.v1.multiasset.WildFungibility
        }
      }
    }
    export namespace multilocation {
      export const $junctions: $.Codec<xcm.v1.multilocation.Junctions> = _codec.$123
      export const $multiLocation: $.Codec<xcm.v1.multilocation.MultiLocation> = _codec.$122
      export type Junctions =
        | xcm.v1.multilocation.Junctions.Here
        | xcm.v1.multilocation.Junctions.X1
        | xcm.v1.multilocation.Junctions.X2
        | xcm.v1.multilocation.Junctions.X3
        | xcm.v1.multilocation.Junctions.X4
        | xcm.v1.multilocation.Junctions.X5
        | xcm.v1.multilocation.Junctions.X6
        | xcm.v1.multilocation.Junctions.X7
        | xcm.v1.multilocation.Junctions.X8
      export namespace Junctions {
        export function Here(): xcm.v1.multilocation.Junctions.Here {
          return { type: "Here" }
        }
        export interface Here {
          type: "Here"
        }
        export function X1(
          value: xcm.v1.multilocation.Junctions.X1["value"],
        ): xcm.v1.multilocation.Junctions.X1 {
          return { type: "X1", value }
        }
        export interface X1 {
          type: "X1"
          value: xcm.v1.junction.Junction
        }
        export function X2(
          ...value: xcm.v1.multilocation.Junctions.X2["value"]
        ): xcm.v1.multilocation.Junctions.X2 {
          return { type: "X2", value }
        }
        export interface X2 {
          type: "X2"
          value: [xcm.v1.junction.Junction, xcm.v1.junction.Junction]
        }
        export function X3(
          ...value: xcm.v1.multilocation.Junctions.X3["value"]
        ): xcm.v1.multilocation.Junctions.X3 {
          return { type: "X3", value }
        }
        export interface X3 {
          type: "X3"
          value: [xcm.v1.junction.Junction, xcm.v1.junction.Junction, xcm.v1.junction.Junction]
        }
        export function X4(
          ...value: xcm.v1.multilocation.Junctions.X4["value"]
        ): xcm.v1.multilocation.Junctions.X4 {
          return { type: "X4", value }
        }
        export interface X4 {
          type: "X4"
          value: [
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
          ]
        }
        export function X5(
          ...value: xcm.v1.multilocation.Junctions.X5["value"]
        ): xcm.v1.multilocation.Junctions.X5 {
          return { type: "X5", value }
        }
        export interface X5 {
          type: "X5"
          value: [
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
          ]
        }
        export function X6(
          ...value: xcm.v1.multilocation.Junctions.X6["value"]
        ): xcm.v1.multilocation.Junctions.X6 {
          return { type: "X6", value }
        }
        export interface X6 {
          type: "X6"
          value: [
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
          ]
        }
        export function X7(
          ...value: xcm.v1.multilocation.Junctions.X7["value"]
        ): xcm.v1.multilocation.Junctions.X7 {
          return { type: "X7", value }
        }
        export interface X7 {
          type: "X7"
          value: [
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
          ]
        }
        export function X8(
          ...value: xcm.v1.multilocation.Junctions.X8["value"]
        ): xcm.v1.multilocation.Junctions.X8 {
          return { type: "X8", value }
        }
        export interface X8 {
          type: "X8"
          value: [
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
            xcm.v1.junction.Junction,
          ]
        }
      }
      export interface MultiLocation {
        parents: u8
        interior: xcm.v1.multilocation.Junctions
      }
      export function MultiLocation(value: xcm.v1.multilocation.MultiLocation) {
        return value
      }
    }
    export namespace order {
      export const $order: $.Codec<xcm.v1.order.Order> = _codec.$432
      export type Order =
        | xcm.v1.order.Order.Noop
        | xcm.v1.order.Order.DepositAsset
        | xcm.v1.order.Order.DepositReserveAsset
        | xcm.v1.order.Order.ExchangeAsset
        | xcm.v1.order.Order.InitiateReserveWithdraw
        | xcm.v1.order.Order.InitiateTeleport
        | xcm.v1.order.Order.QueryHolding
        | xcm.v1.order.Order.BuyExecution
      export namespace Order {
        export function BuyExecution(
          value: Omit<xcm.v1.order.Order.BuyExecution, "type">,
        ): xcm.v1.order.Order.BuyExecution {
          return { type: "BuyExecution", ...value }
        }
        export interface BuyExecution {
          type: "BuyExecution"
          fees: xcm.v1.multiasset.MultiAsset
          weight: u64
          debt: u64
          halt_on_error: boolean
          instructions: Array<xcm.v1.Xcm>
        }
        export function DepositAsset(
          value: Omit<xcm.v1.order.Order.DepositAsset, "type">,
        ): xcm.v1.order.Order.DepositAsset {
          return { type: "DepositAsset", ...value }
        }
        export interface DepositAsset {
          type: "DepositAsset"
          assets: xcm.v1.multiasset.MultiAssetFilter
          max_assets: u32
          beneficiary: xcm.v1.multilocation.MultiLocation
        }
        export function DepositReserveAsset(
          value: Omit<xcm.v1.order.Order.DepositReserveAsset, "type">,
        ): xcm.v1.order.Order.DepositReserveAsset {
          return { type: "DepositReserveAsset", ...value }
        }
        export interface DepositReserveAsset {
          type: "DepositReserveAsset"
          assets: xcm.v1.multiasset.MultiAssetFilter
          max_assets: u32
          dest: xcm.v1.multilocation.MultiLocation
          effects: Array<xcm.v1.order.Order>
        }
        export function ExchangeAsset(
          value: Omit<xcm.v1.order.Order.ExchangeAsset, "type">,
        ): xcm.v1.order.Order.ExchangeAsset {
          return { type: "ExchangeAsset", ...value }
        }
        export interface ExchangeAsset {
          type: "ExchangeAsset"
          give: xcm.v1.multiasset.MultiAssetFilter
          receive: xcm.v1.multiasset.MultiAssets
        }
        export function InitiateReserveWithdraw(
          value: Omit<xcm.v1.order.Order.InitiateReserveWithdraw, "type">,
        ): xcm.v1.order.Order.InitiateReserveWithdraw {
          return { type: "InitiateReserveWithdraw", ...value }
        }
        export interface InitiateReserveWithdraw {
          type: "InitiateReserveWithdraw"
          assets: xcm.v1.multiasset.MultiAssetFilter
          reserve: xcm.v1.multilocation.MultiLocation
          effects: Array<xcm.v1.order.Order>
        }
        export function InitiateTeleport(
          value: Omit<xcm.v1.order.Order.InitiateTeleport, "type">,
        ): xcm.v1.order.Order.InitiateTeleport {
          return { type: "InitiateTeleport", ...value }
        }
        export interface InitiateTeleport {
          type: "InitiateTeleport"
          assets: xcm.v1.multiasset.MultiAssetFilter
          dest: xcm.v1.multilocation.MultiLocation
          effects: Array<xcm.v1.order.Order>
        }
        export function Noop(): xcm.v1.order.Order.Noop {
          return { type: "Noop" }
        }
        export interface Noop {
          type: "Noop"
        }
        export function QueryHolding(
          value: Omit<xcm.v1.order.Order.QueryHolding, "type">,
        ): xcm.v1.order.Order.QueryHolding {
          return { type: "QueryHolding", ...value }
        }
        export interface QueryHolding {
          type: "QueryHolding"
          query_id: Compact<u64>
          dest: xcm.v1.multilocation.MultiLocation
          assets: xcm.v1.multiasset.MultiAssetFilter
        }
      }
    }
  }
  export namespace v2 {
    export const $instruction: $.Codec<xcm.v2.Instruction> = _codec.$132
    export const $response: $.Codec<xcm.v2.Response> = _codec.$140
    export const $weightLimit: $.Codec<xcm.v2.WeightLimit> = _codec.$148
    export type Instruction =
      | xcm.v2.Instruction.WithdrawAsset
      | xcm.v2.Instruction.ReserveAssetDeposited
      | xcm.v2.Instruction.ReceiveTeleportedAsset
      | xcm.v2.Instruction.QueryResponse
      | xcm.v2.Instruction.TransferAsset
      | xcm.v2.Instruction.TransferReserveAsset
      | xcm.v2.Instruction.Transact
      | xcm.v2.Instruction.HrmpNewChannelOpenRequest
      | xcm.v2.Instruction.HrmpChannelAccepted
      | xcm.v2.Instruction.HrmpChannelClosing
      | xcm.v2.Instruction.ClearOrigin
      | xcm.v2.Instruction.DescendOrigin
      | xcm.v2.Instruction.ReportError
      | xcm.v2.Instruction.DepositAsset
      | xcm.v2.Instruction.DepositReserveAsset
      | xcm.v2.Instruction.ExchangeAsset
      | xcm.v2.Instruction.InitiateReserveWithdraw
      | xcm.v2.Instruction.InitiateTeleport
      | xcm.v2.Instruction.QueryHolding
      | xcm.v2.Instruction.BuyExecution
      | xcm.v2.Instruction.RefundSurplus
      | xcm.v2.Instruction.SetErrorHandler
      | xcm.v2.Instruction.SetAppendix
      | xcm.v2.Instruction.ClearError
      | xcm.v2.Instruction.ClaimAsset
      | xcm.v2.Instruction.Trap
      | xcm.v2.Instruction.SubscribeVersion
      | xcm.v2.Instruction.UnsubscribeVersion
    export namespace Instruction {
      export function BuyExecution(
        value: Omit<xcm.v2.Instruction.BuyExecution, "type">,
      ): xcm.v2.Instruction.BuyExecution {
        return { type: "BuyExecution", ...value }
      }
      export interface BuyExecution {
        type: "BuyExecution"
        fees: xcm.v1.multiasset.MultiAsset
        weight_limit: xcm.v2.WeightLimit
      }
      export function ClaimAsset(
        value: Omit<xcm.v2.Instruction.ClaimAsset, "type">,
      ): xcm.v2.Instruction.ClaimAsset {
        return { type: "ClaimAsset", ...value }
      }
      export interface ClaimAsset {
        type: "ClaimAsset"
        assets: xcm.v1.multiasset.MultiAssets
        ticket: xcm.v1.multilocation.MultiLocation
      }
      export function ClearError(): xcm.v2.Instruction.ClearError {
        return { type: "ClearError" }
      }
      export interface ClearError {
        type: "ClearError"
      }
      export function ClearOrigin(): xcm.v2.Instruction.ClearOrigin {
        return { type: "ClearOrigin" }
      }
      export interface ClearOrigin {
        type: "ClearOrigin"
      }
      export function DepositAsset(
        value: Omit<xcm.v2.Instruction.DepositAsset, "type">,
      ): xcm.v2.Instruction.DepositAsset {
        return { type: "DepositAsset", ...value }
      }
      export interface DepositAsset {
        type: "DepositAsset"
        assets: xcm.v1.multiasset.MultiAssetFilter
        max_assets: Compact<u32>
        beneficiary: xcm.v1.multilocation.MultiLocation
      }
      export function DepositReserveAsset(
        value: Omit<xcm.v2.Instruction.DepositReserveAsset, "type">,
      ): xcm.v2.Instruction.DepositReserveAsset {
        return { type: "DepositReserveAsset", ...value }
      }
      export interface DepositReserveAsset {
        type: "DepositReserveAsset"
        assets: xcm.v1.multiasset.MultiAssetFilter
        max_assets: Compact<u32>
        dest: xcm.v1.multilocation.MultiLocation
        xcm: Array<xcm.v2.Instruction>
      }
      export function DescendOrigin(
        value: xcm.v2.Instruction.DescendOrigin["value"],
      ): xcm.v2.Instruction.DescendOrigin {
        return { type: "DescendOrigin", value }
      }
      export interface DescendOrigin {
        type: "DescendOrigin"
        value: xcm.v1.multilocation.Junctions
      }
      export function ExchangeAsset(
        value: Omit<xcm.v2.Instruction.ExchangeAsset, "type">,
      ): xcm.v2.Instruction.ExchangeAsset {
        return { type: "ExchangeAsset", ...value }
      }
      export interface ExchangeAsset {
        type: "ExchangeAsset"
        give: xcm.v1.multiasset.MultiAssetFilter
        receive: xcm.v1.multiasset.MultiAssets
      }
      export function HrmpChannelAccepted(
        value: Omit<xcm.v2.Instruction.HrmpChannelAccepted, "type">,
      ): xcm.v2.Instruction.HrmpChannelAccepted {
        return { type: "HrmpChannelAccepted", ...value }
      }
      export interface HrmpChannelAccepted {
        type: "HrmpChannelAccepted"
        recipient: Compact<u32>
      }
      export function HrmpChannelClosing(
        value: Omit<xcm.v2.Instruction.HrmpChannelClosing, "type">,
      ): xcm.v2.Instruction.HrmpChannelClosing {
        return { type: "HrmpChannelClosing", ...value }
      }
      export interface HrmpChannelClosing {
        type: "HrmpChannelClosing"
        initiator: Compact<u32>
        sender: Compact<u32>
        recipient: Compact<u32>
      }
      export function HrmpNewChannelOpenRequest(
        value: Omit<xcm.v2.Instruction.HrmpNewChannelOpenRequest, "type">,
      ): xcm.v2.Instruction.HrmpNewChannelOpenRequest {
        return { type: "HrmpNewChannelOpenRequest", ...value }
      }
      export interface HrmpNewChannelOpenRequest {
        type: "HrmpNewChannelOpenRequest"
        sender: Compact<u32>
        max_message_size: Compact<u32>
        max_capacity: Compact<u32>
      }
      export function InitiateReserveWithdraw(
        value: Omit<xcm.v2.Instruction.InitiateReserveWithdraw, "type">,
      ): xcm.v2.Instruction.InitiateReserveWithdraw {
        return { type: "InitiateReserveWithdraw", ...value }
      }
      export interface InitiateReserveWithdraw {
        type: "InitiateReserveWithdraw"
        assets: xcm.v1.multiasset.MultiAssetFilter
        reserve: xcm.v1.multilocation.MultiLocation
        xcm: Array<xcm.v2.Instruction>
      }
      export function InitiateTeleport(
        value: Omit<xcm.v2.Instruction.InitiateTeleport, "type">,
      ): xcm.v2.Instruction.InitiateTeleport {
        return { type: "InitiateTeleport", ...value }
      }
      export interface InitiateTeleport {
        type: "InitiateTeleport"
        assets: xcm.v1.multiasset.MultiAssetFilter
        dest: xcm.v1.multilocation.MultiLocation
        xcm: Array<xcm.v2.Instruction>
      }
      export function QueryHolding(
        value: Omit<xcm.v2.Instruction.QueryHolding, "type">,
      ): xcm.v2.Instruction.QueryHolding {
        return { type: "QueryHolding", ...value }
      }
      export interface QueryHolding {
        type: "QueryHolding"
        query_id: Compact<u64>
        dest: xcm.v1.multilocation.MultiLocation
        assets: xcm.v1.multiasset.MultiAssetFilter
        max_response_weight: Compact<u64>
      }
      export function QueryResponse(
        value: Omit<xcm.v2.Instruction.QueryResponse, "type">,
      ): xcm.v2.Instruction.QueryResponse {
        return { type: "QueryResponse", ...value }
      }
      export interface QueryResponse {
        type: "QueryResponse"
        query_id: Compact<u64>
        response: xcm.v2.Response
        max_weight: Compact<u64>
      }
      export function ReceiveTeleportedAsset(
        value: xcm.v2.Instruction.ReceiveTeleportedAsset["value"],
      ): xcm.v2.Instruction.ReceiveTeleportedAsset {
        return { type: "ReceiveTeleportedAsset", value }
      }
      export interface ReceiveTeleportedAsset {
        type: "ReceiveTeleportedAsset"
        value: xcm.v1.multiasset.MultiAssets
      }
      export function RefundSurplus(): xcm.v2.Instruction.RefundSurplus {
        return { type: "RefundSurplus" }
      }
      export interface RefundSurplus {
        type: "RefundSurplus"
      }
      export function ReportError(
        value: Omit<xcm.v2.Instruction.ReportError, "type">,
      ): xcm.v2.Instruction.ReportError {
        return { type: "ReportError", ...value }
      }
      export interface ReportError {
        type: "ReportError"
        query_id: Compact<u64>
        dest: xcm.v1.multilocation.MultiLocation
        max_response_weight: Compact<u64>
      }
      export function ReserveAssetDeposited(
        value: xcm.v2.Instruction.ReserveAssetDeposited["value"],
      ): xcm.v2.Instruction.ReserveAssetDeposited {
        return { type: "ReserveAssetDeposited", value }
      }
      export interface ReserveAssetDeposited {
        type: "ReserveAssetDeposited"
        value: xcm.v1.multiasset.MultiAssets
      }
      export function SetAppendix(
        value: xcm.v2.Instruction.SetAppendix["value"],
      ): xcm.v2.Instruction.SetAppendix {
        return { type: "SetAppendix", value }
      }
      export interface SetAppendix {
        type: "SetAppendix"
        value: Array<xcm.v2.Instruction>
      }
      export function SetErrorHandler(
        value: xcm.v2.Instruction.SetErrorHandler["value"],
      ): xcm.v2.Instruction.SetErrorHandler {
        return { type: "SetErrorHandler", value }
      }
      export interface SetErrorHandler {
        type: "SetErrorHandler"
        value: Array<xcm.v2.Instruction>
      }
      export function SubscribeVersion(
        value: Omit<xcm.v2.Instruction.SubscribeVersion, "type">,
      ): xcm.v2.Instruction.SubscribeVersion {
        return { type: "SubscribeVersion", ...value }
      }
      export interface SubscribeVersion {
        type: "SubscribeVersion"
        query_id: Compact<u64>
        max_response_weight: Compact<u64>
      }
      export function Transact(
        value: Omit<xcm.v2.Instruction.Transact, "type">,
      ): xcm.v2.Instruction.Transact {
        return { type: "Transact", ...value }
      }
      export interface Transact {
        type: "Transact"
        origin_type: xcm.v0.OriginKind
        require_weight_at_most: Compact<u64>
        call: { encoded: Uint8Array }
      }
      export function TransferAsset(
        value: Omit<xcm.v2.Instruction.TransferAsset, "type">,
      ): xcm.v2.Instruction.TransferAsset {
        return { type: "TransferAsset", ...value }
      }
      export interface TransferAsset {
        type: "TransferAsset"
        assets: xcm.v1.multiasset.MultiAssets
        beneficiary: xcm.v1.multilocation.MultiLocation
      }
      export function TransferReserveAsset(
        value: Omit<xcm.v2.Instruction.TransferReserveAsset, "type">,
      ): xcm.v2.Instruction.TransferReserveAsset {
        return { type: "TransferReserveAsset", ...value }
      }
      export interface TransferReserveAsset {
        type: "TransferReserveAsset"
        assets: xcm.v1.multiasset.MultiAssets
        dest: xcm.v1.multilocation.MultiLocation
        xcm: Array<xcm.v2.Instruction>
      }
      export function Trap(value: xcm.v2.Instruction.Trap["value"]): xcm.v2.Instruction.Trap {
        return { type: "Trap", value }
      }
      export interface Trap {
        type: "Trap"
        value: Compact<u64>
      }
      export function UnsubscribeVersion(): xcm.v2.Instruction.UnsubscribeVersion {
        return { type: "UnsubscribeVersion" }
      }
      export interface UnsubscribeVersion {
        type: "UnsubscribeVersion"
      }
      export function WithdrawAsset(
        value: xcm.v2.Instruction.WithdrawAsset["value"],
      ): xcm.v2.Instruction.WithdrawAsset {
        return { type: "WithdrawAsset", value }
      }
      export interface WithdrawAsset {
        type: "WithdrawAsset"
        value: xcm.v1.multiasset.MultiAssets
      }
    }
    export type Response =
      | xcm.v2.Response.Null
      | xcm.v2.Response.Assets
      | xcm.v2.Response.ExecutionResult
      | xcm.v2.Response.Version
    export namespace Response {
      export function Assets(value: xcm.v2.Response.Assets["value"]): xcm.v2.Response.Assets {
        return { type: "Assets", value }
      }
      export interface Assets {
        type: "Assets"
        value: xcm.v1.multiasset.MultiAssets
      }
      export function ExecutionResult(
        value: xcm.v2.Response.ExecutionResult["value"],
      ): xcm.v2.Response.ExecutionResult {
        return { type: "ExecutionResult", value }
      }
      export interface ExecutionResult {
        type: "ExecutionResult"
        value: [u32, xcm.v2.traits.Error] | undefined
      }
      export function Null(): xcm.v2.Response.Null {
        return { type: "Null" }
      }
      export interface Null {
        type: "Null"
      }
      export function Version(value: xcm.v2.Response.Version["value"]): xcm.v2.Response.Version {
        return { type: "Version", value }
      }
      export interface Version {
        type: "Version"
        value: u32
      }
    }
    export type WeightLimit = xcm.v2.WeightLimit.Unlimited | xcm.v2.WeightLimit.Limited
    export namespace WeightLimit {
      export function Limited(
        value: xcm.v2.WeightLimit.Limited["value"],
      ): xcm.v2.WeightLimit.Limited {
        return { type: "Limited", value }
      }
      export interface Limited {
        type: "Limited"
        value: Compact<u64>
      }
      export function Unlimited(): xcm.v2.WeightLimit.Unlimited {
        return { type: "Unlimited" }
      }
      export interface Unlimited {
        type: "Unlimited"
      }
    }
    export namespace traits {
      export const $error: $.Codec<xcm.v2.traits.Error> = _codec.$110
      export const $outcome: $.Codec<xcm.v2.traits.Outcome> = _codec.$109
      export type Error =
        | xcm.v2.traits.Error.Overflow
        | xcm.v2.traits.Error.Unimplemented
        | xcm.v2.traits.Error.UntrustedReserveLocation
        | xcm.v2.traits.Error.UntrustedTeleportLocation
        | xcm.v2.traits.Error.MultiLocationFull
        | xcm.v2.traits.Error.MultiLocationNotInvertible
        | xcm.v2.traits.Error.BadOrigin
        | xcm.v2.traits.Error.InvalidLocation
        | xcm.v2.traits.Error.AssetNotFound
        | xcm.v2.traits.Error.FailedToTransactAsset
        | xcm.v2.traits.Error.NotWithdrawable
        | xcm.v2.traits.Error.LocationCannotHold
        | xcm.v2.traits.Error.ExceedsMaxMessageSize
        | xcm.v2.traits.Error.DestinationUnsupported
        | xcm.v2.traits.Error.Transport
        | xcm.v2.traits.Error.Unroutable
        | xcm.v2.traits.Error.UnknownClaim
        | xcm.v2.traits.Error.FailedToDecode
        | xcm.v2.traits.Error.MaxWeightInvalid
        | xcm.v2.traits.Error.NotHoldingFees
        | xcm.v2.traits.Error.TooExpensive
        | xcm.v2.traits.Error.Trap
        | xcm.v2.traits.Error.UnhandledXcmVersion
        | xcm.v2.traits.Error.WeightLimitReached
        | xcm.v2.traits.Error.Barrier
        | xcm.v2.traits.Error.WeightNotComputable
      export namespace Error {
        export function AssetNotFound(): xcm.v2.traits.Error.AssetNotFound {
          return { type: "AssetNotFound" }
        }
        export interface AssetNotFound {
          type: "AssetNotFound"
        }
        export function BadOrigin(): xcm.v2.traits.Error.BadOrigin {
          return { type: "BadOrigin" }
        }
        export interface BadOrigin {
          type: "BadOrigin"
        }
        export function Barrier(): xcm.v2.traits.Error.Barrier {
          return { type: "Barrier" }
        }
        export interface Barrier {
          type: "Barrier"
        }
        export function DestinationUnsupported(): xcm.v2.traits.Error.DestinationUnsupported {
          return { type: "DestinationUnsupported" }
        }
        export interface DestinationUnsupported {
          type: "DestinationUnsupported"
        }
        export function ExceedsMaxMessageSize(): xcm.v2.traits.Error.ExceedsMaxMessageSize {
          return { type: "ExceedsMaxMessageSize" }
        }
        export interface ExceedsMaxMessageSize {
          type: "ExceedsMaxMessageSize"
        }
        export function FailedToDecode(): xcm.v2.traits.Error.FailedToDecode {
          return { type: "FailedToDecode" }
        }
        export interface FailedToDecode {
          type: "FailedToDecode"
        }
        export function FailedToTransactAsset(): xcm.v2.traits.Error.FailedToTransactAsset {
          return { type: "FailedToTransactAsset" }
        }
        export interface FailedToTransactAsset {
          type: "FailedToTransactAsset"
        }
        export function InvalidLocation(): xcm.v2.traits.Error.InvalidLocation {
          return { type: "InvalidLocation" }
        }
        export interface InvalidLocation {
          type: "InvalidLocation"
        }
        export function LocationCannotHold(): xcm.v2.traits.Error.LocationCannotHold {
          return { type: "LocationCannotHold" }
        }
        export interface LocationCannotHold {
          type: "LocationCannotHold"
        }
        export function MaxWeightInvalid(): xcm.v2.traits.Error.MaxWeightInvalid {
          return { type: "MaxWeightInvalid" }
        }
        export interface MaxWeightInvalid {
          type: "MaxWeightInvalid"
        }
        export function MultiLocationFull(): xcm.v2.traits.Error.MultiLocationFull {
          return { type: "MultiLocationFull" }
        }
        export interface MultiLocationFull {
          type: "MultiLocationFull"
        }
        export function MultiLocationNotInvertible(): xcm.v2.traits.Error.MultiLocationNotInvertible {
          return { type: "MultiLocationNotInvertible" }
        }
        export interface MultiLocationNotInvertible {
          type: "MultiLocationNotInvertible"
        }
        export function NotHoldingFees(): xcm.v2.traits.Error.NotHoldingFees {
          return { type: "NotHoldingFees" }
        }
        export interface NotHoldingFees {
          type: "NotHoldingFees"
        }
        export function NotWithdrawable(): xcm.v2.traits.Error.NotWithdrawable {
          return { type: "NotWithdrawable" }
        }
        export interface NotWithdrawable {
          type: "NotWithdrawable"
        }
        export function Overflow(): xcm.v2.traits.Error.Overflow {
          return { type: "Overflow" }
        }
        export interface Overflow {
          type: "Overflow"
        }
        export function TooExpensive(): xcm.v2.traits.Error.TooExpensive {
          return { type: "TooExpensive" }
        }
        export interface TooExpensive {
          type: "TooExpensive"
        }
        export function Transport(): xcm.v2.traits.Error.Transport {
          return { type: "Transport" }
        }
        export interface Transport {
          type: "Transport"
        }
        export function Trap(value: xcm.v2.traits.Error.Trap["value"]): xcm.v2.traits.Error.Trap {
          return { type: "Trap", value }
        }
        export interface Trap {
          type: "Trap"
          value: u64
        }
        export function UnhandledXcmVersion(): xcm.v2.traits.Error.UnhandledXcmVersion {
          return { type: "UnhandledXcmVersion" }
        }
        export interface UnhandledXcmVersion {
          type: "UnhandledXcmVersion"
        }
        export function Unimplemented(): xcm.v2.traits.Error.Unimplemented {
          return { type: "Unimplemented" }
        }
        export interface Unimplemented {
          type: "Unimplemented"
        }
        export function UnknownClaim(): xcm.v2.traits.Error.UnknownClaim {
          return { type: "UnknownClaim" }
        }
        export interface UnknownClaim {
          type: "UnknownClaim"
        }
        export function Unroutable(): xcm.v2.traits.Error.Unroutable {
          return { type: "Unroutable" }
        }
        export interface Unroutable {
          type: "Unroutable"
        }
        export function UntrustedReserveLocation(): xcm.v2.traits.Error.UntrustedReserveLocation {
          return { type: "UntrustedReserveLocation" }
        }
        export interface UntrustedReserveLocation {
          type: "UntrustedReserveLocation"
        }
        export function UntrustedTeleportLocation(): xcm.v2.traits.Error.UntrustedTeleportLocation {
          return { type: "UntrustedTeleportLocation" }
        }
        export interface UntrustedTeleportLocation {
          type: "UntrustedTeleportLocation"
        }
        export function WeightLimitReached(
          value: xcm.v2.traits.Error.WeightLimitReached["value"],
        ): xcm.v2.traits.Error.WeightLimitReached {
          return { type: "WeightLimitReached", value }
        }
        export interface WeightLimitReached {
          type: "WeightLimitReached"
          value: u64
        }
        export function WeightNotComputable(): xcm.v2.traits.Error.WeightNotComputable {
          return { type: "WeightNotComputable" }
        }
        export interface WeightNotComputable {
          type: "WeightNotComputable"
        }
      }
      export type Outcome =
        | xcm.v2.traits.Outcome.Complete
        | xcm.v2.traits.Outcome.Incomplete
        | xcm.v2.traits.Outcome.Error
      export namespace Outcome {
        export function Complete(
          value: xcm.v2.traits.Outcome.Complete["value"],
        ): xcm.v2.traits.Outcome.Complete {
          return { type: "Complete", value }
        }
        export interface Complete {
          type: "Complete"
          value: u64
        }
        export function Error(
          value: xcm.v2.traits.Outcome.Error["value"],
        ): xcm.v2.traits.Outcome.Error {
          return { type: "Error", value }
        }
        export interface Error {
          type: "Error"
          value: xcm.v2.traits.Error
        }
        export function Incomplete(
          ...value: xcm.v2.traits.Outcome.Incomplete["value"]
        ): xcm.v2.traits.Outcome.Incomplete {
          return { type: "Incomplete", value }
        }
        export interface Incomplete {
          type: "Incomplete"
          value: [u64, xcm.v2.traits.Error]
        }
      }
    }
  }
}
